---
title: "Procesamiento de Señales e Imagenes"
description: "PSIM -- 101849"
subtitle: "Ingeniería Biomédica"
lang: es
author: "Ph.D. Pablo Eduardo Caicedo Rodríguez"
date: last-modified
format:
    revealjs: 
        code-tools: true
        code-overflow: wrap
        code-line-numbers: true
        code-copy: true
        fig-align: center
        self-contained: true
        theme: 
        - simple
        - ../../recursos/estilos/metropolis.scss
        slide-number: true
        preview-links: auto
        logo: ../../recursos/imagenes/generales/Escuela_Rosario_logo.png
        css: ../../recursos/estilos/styles_pres.scss
        footer: <https://pablocaicedor.github.io/>
        transition: fade
        progress: true
        scrollable: true
        mainfont: "Fira Code"
---

# ¡Bienvenidos! {background-image="https://images.unsplash.com/photo-1579154204601-01588f351e67?q=80&w=2070&auto=format&fit=crop" background-opacity="0.3"}

::: {.notes}
¡Hola a todos y bienvenidos! Soy Pablo Caicedo, y hoy vamos a hacer algo increíble: vamos a aprender a ver lo invisible. Vamos a explorar cómo le enseñamos a las computadoras a entender el lenguaje secreto del cuerpo humano. Este campo se llama Procesamiento de Señales e Imágenes Biomédicas, y es una de las áreas más emocionantes de la ingeniería y la medicina hoy en día.
:::

---

## La Gran Pregunta

::: {.callout-note}
> ¿Y si tu celular pudiera detectar una enfermedad cardíaca con solo tocarlo?
>
> ¿Y si una computadora pudiera ver un tumor que el ojo humano más experto aún no distingue?
:::




::: {.notes}
Imaginen por un momento... ¿Y si su celular pudiera detectar una enfermedad cardíaca con solo tocarlo? ¿Y si una computadora pudiera ver un tumor en una radiografía, incluso antes de que el ojo humano más experto lo note? Esto no es ciencia ficción. Es lo que hacemos todos los días en este campo. La pregunta no es 'si' es posible, sino 'cómo' lo hacemos posible.
:::

---

## Bienvenida

**Procesamiento de señales e imágenes**  
*De los sonidos y las fotos a la salud y la tecnología.*

::: {.notes}
Guion: Preguntar a los estudiantes: ¿Qué señales usan sin darse cuenta? (Wi-Fi, música, ritmo del corazón). Explicar que hoy aprenderán a mirar cómo las computadoras entienden esas señales e imágenes.
:::

## Nuestro Viaje de Hoy

1.  **Los Lenguajes Secretos del Cuerpo:** Descubriremos las señales eléctricas que nos mantienen vivos.

2.  **Una Imagen Vale Más que Mil Pruebas:** Veremos cómo convertimos el interior del cuerpo en imágenes.

3.  **El Truco de Magia: 'Procesar':** Aprenderemos a limpiar y mejorar estos datos para encontrar pistas.

4.  **¡Tu Turno! Conviértete en Ingeniero/a Biomédico/a:** Realizarán análisis reales en nuestro laboratorio digital.

::: {.notes}
Para entender cómo funciona esta 'magia', nuestro viaje de hoy tendrá cuatro paradas. Primero, descifraremos los lenguajes secretos del cuerpo, las señales eléctricas. Luego, veremos cómo creamos imágenes del interior de nuestro cuerpo. Después, revelaremos el truco de magia que llamamos 'procesamiento' para limpiar y mejorar estos datos. Y finalmente, la parte más emocionante: ustedes mismos se convertirán en ingenieros y realizarán análisis en nuestro laboratorio digital.
:::

---

# Parte I: Señales Biomédicas {background-image="../../recursos/imagenes/Talleres/laboratorio01.png" background-opacity="0.3"}

---

## ¿Qué es una Señal? Información en Movimiento

```{python}
#| echo: false
#| fig-cap: "Una señal es simplemente información que cambia con el tiempo."

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Estilo de la gráfica
sns.set_style("whitegrid")
plt.rcParams['font.family'] = 'Fira Code'

# Generar datos para una onda sinusoidal
tiempo = np.linspace(0, 10, 500)
amplitud = np.sin(tiempo)

# Crear la gráfica
fig, ax = plt.subplots(figsize=(10, 5))
ax.plot(tiempo, amplitud, lw=3, color='#007acc')
ax.set_title("Ejemplo de una Señal Simple", fontsize=16)
ax.set_xlabel("Tiempo (segundos)", fontsize=12)
ax.set_ylabel("Valor / Amplitud", fontsize=12)
ax.grid(True, which='both', linestyle='--', linewidth=0.5)
ax.set_ylim(-1.5, 1.5)
plt.show()
```

::: {.notes}
Empecemos por lo básico. ¿Qué es una señal? Es simplemente información que cambia con el tiempo. Piensen en la música: las notas suben y bajan, creando una melodía. Eso es una señal. O la temperatura a lo largo de un día: sube al mediodía y baja por la noche. En el cuerpo, en lugar de notas o grados, medimos cosas como la actividad eléctrica, que sube y baja de formas muy específicas.
:::

---

## La Sinfonía Eléctrica del Cuerpo

:::: {.columns}

::: {.column width="45%"}
El **Electrocardiograma (ECG)** es el ritmo del corazón, nuestro tambor principal.
```{python}
#| echo: false
#| fig-cap: "Señal de ECG ideal, mostrando el patrón rítmico del corazón."

def generar_ecg_limpio(n_latidos=3, fs=500):
    """Genera una señal de ECG sintética y limpia."""
    t_latido = np.linspace(-0.5, 0.5, fs // 2)
    
    # Ondas P, QRS, T (simplificadas)
    p = 0.1 * np.exp(- (t_latido - 0.2)**2 / 0.001)
    qrs = 1.0 * np.exp(-t_latido**2 / 0.0005) - 0.2 * np.exp(-(t_latido-0.02)**2 / 0.001)
    t = 0.2 * np.exp(- (t_latido + 0.2)**2 / 0.005)
    
    latido = p + qrs + t
    ecg = np.tile(latido, n_latidos)
    tiempo = np.arange(len(ecg)) / fs
    return tiempo, ecg

tiempo_limpio, ecg_limpio = generar_ecg_limpio(n_latidos=4, fs=500)

fig, ax = plt.subplots(figsize=(8, 4))
ax.plot(tiempo_limpio, ecg_limpio, color='red', lw=2)
ax.set_title("Señal de un Corazón Sano (ECG)", fontsize=14)
ax.set_xlabel("Tiempo (s)", fontsize=10)
ax.set_ylabel("Amplitud (mV)", fontsize=10)
ax.grid(True, linestyle='--', alpha=0.6)
plt.tight_layout()
plt.show()

```
:::

::: {.column width="45%"}
**¿Qué nos dice el ECG?**

-   ¿Cuál es el **ritmo cardíaco**?
-   ¿El corazón late muy **rápido** o muy **lento**?
-   ¿Hay alguna parte que no funciona en **armonía**?
-   Permite diagnosticar problemas y salvar vidas.

:::

::::

::: {.notes}
Nuestro cuerpo es como una orquesta eléctrica. El corazón es el tambor, marcando un ritmo constante y poderoso. La señal que produce se llama **Electrocardiograma o ECG**. El cerebro es como la sección de cuerdas, con miles de neuronas 'hablando' a la vez en una conversación compleja. Esa señal es el **Electroencefalograma o EEG**. Escuchando estas 'melodías', los médicos pueden saber si todo funciona en armonía.
:::

---

## El Desafío: Encontrar la Señal en el Ruido

```{python}
#| echo: false
#| fig-cap: "Una señal de ECG real a menudo está contaminada con ruido."

# Añadir ruido a la señal limpia
np.random.seed(42)
ruido = 0.4 * np.random.normal(0, 1, len(ecg_limpio))
ecg_ruidoso = ecg_limpio + ruido

fig, ax = plt.subplots(figsize=(10, 5))
ax.plot(tiempo_limpio, ecg_ruidoso, color='purple', lw=1.5)
ax.set_title("ECG con Ruido: ¡Difícil de Leer!", fontsize=16)
ax.set_xlabel("Tiempo (s)", fontsize=12)
ax.set_ylabel("Amplitud (mV)", fontsize=12)
ax.grid(True, linestyle='--', alpha=0.6)
plt.show()
```

::: {.notes}
Pero en el mundo real, estas señales no son tan claras. Imaginen tratar de escuchar a un amigo en una fiesta muy ruidosa. El 'ruido' es todo lo que interfiere: otros aparatos eléctricos, el movimiento del paciente, etc. Este ruido puede ocultar información vital que el médico necesita ver. Como ven aquí, el patrón claro del latido casi ha desaparecido.
:::

---

## La Solución: Cancelación de Ruido Digital

:::: {.columns}

::: {.column width="45%"}
**Señal Ruidosa (Original)**
```{python}
#| echo: false
fig, ax = plt.subplots(figsize=(8, 4))
ax.plot(tiempo_limpio, ecg_ruidoso, color='purple', lw=1.5)
ax.set_title("Señal Original", fontsize=14)
ax.set_xlabel("Tiempo (s)", fontsize=10)
ax.set_ylabel("Amplitud (mV)", fontsize=10)
ax.grid(True, linestyle='--', alpha=0.6)
plt.tight_layout()
plt.show()
```
:::

::: {.column width="45%"}
**Señal Filtrada (Limpia)**
```{python}
#| echo: false
from scipy.signal import savgol_filter

# Aplicar un filtro (Savitzky-Golay es bueno para preservar la forma)
ecg_filtrado = savgol_filter(ecg_ruidoso, window_length=51, polyorder=3)

fig, ax = plt.subplots(figsize=(8, 4))
ax.plot(tiempo_limpio, ecg_filtrado, color='green', lw=2)
ax.set_title("Señal Recuperada", fontsize=14)
ax.set_xlabel("Tiempo (s)", fontsize=10)
ax.set_ylabel("Amplitud (mV)", fontsize=10)
ax.grid(True, linestyle='--', alpha=0.6)
plt.tight_layout()
plt.show()
```
:::

::::

::: {.notes}
Aquí es donde entra nuestra 'magia'. Usamos algoritmos de 'filtrado'. Es como ponerse unos audífonos con cancelación de ruido. La computadora mira cada punto de la señal y lo promedia con sus vecinos de una manera inteligente. El ruido, al ser aleatorio y rápido, se cancela, ¡pero el patrón real del latido, que es más lento y repetitivo, se mantiene! Así 'rescatamos' la información importante, como pueden ver en la gráfica de la derecha. Pasamos de algo ilegible a una señal clara y diagnóstica.
:::


# Parte II: Imágenes Biomédicas {background-image="../../recursos/imagenes/Talleres/laboratorio02.png" background-opacity="0.3"}



## ¿Qué es una Imagen? Una Pintura por Números

:::: {.columns}

::: {.column width="45%"}
**Los Números (Píxeles)**
```{python}
# | echo: false
# | fig-cap: "Matriz de números que representa una imagen simple."
np.random.seed(0)
pixel_data = np.random.randint(0, 256, size=(8, 8))

fig, ax = plt.subplots(figsize=(6, 6))
sns.heatmap(
    pixel_data,
    annot=True,
    fmt="d",
    cmap="gray",
    cbar=False,
    linewidths=0.5,
    linecolor="black",
    ax=ax,
    annot_kws={"size": 10},
)
ax.set_title("Los Valores de los Píxeles", fontsize=14)
# ax.set_xticks([])
# ax.set_yticks([])
plt.show()
```
:::

::: {.column width="45%"}
**La Imagen Resultante**
```{python}
# | echo: false
# | fig-cap: "La imagen en escala de grises generada por la matriz de números."
fig, ax = plt.subplots(figsize=(6, 6))
ax.imshow(pixel_data, cmap="gray", interpolation="nearest")
ax.set_title("La Imagen que Vemos", fontsize=14)
# ax[0].set_xticks([])
# ax[0].set_yticks([])
plt.show()
```
:::

::::

::: {.notes}
Ahora hablemos de imágenes. Para una computadora, una imagen no es una foto, es una cuadrícula gigante de números. ¡Como un lienzo para pintar por números! Cada número representa el brillo de un puntito llamado 'píxel'. Un número bajo como 0 puede ser negro, un número alto como 255 puede ser blanco, y los números intermedios son todos los tonos de gris. A la izquierda ven los números, y a la derecha, la imagen que la computadora crea a partir de ellos.
:::

---

## Una Ventana Hacia el Cuerpo

:::: {.columns}

::: {.column width="45%"}
**Radiografía (Rayos X)**
Ideal para ver estructuras densas como los huesos.

```{python}
#| echo: false
#| fig-cap: "Ejemplo de una radiografía de tórax."
from skimage import data
from skimage.transform import resize

# Usamos una imagen de ejemplo que se asemeje a una estructura ósea
image_xray = data.human_mitosis() 
image_xray = image_xray[0:256, 0:256] # Recortar para que parezca una radiografía

plt.figure(figsize=(6,6))
plt.imshow(image_xray, cmap='gray')
plt.title("Radiografía: Huesos y Tejidos Densos")
plt.axis('off')
plt.show()
```
:::

::: {.column width="45%"}
**Resonancia Magnética (MRI)**
Perfecta para ver tejidos blandos como el cerebro.

```{python}
#| echo: false
#| fig-cap: "Ejemplo de una resonancia magnética cerebral."
# Usamos una imagen de ejemplo de cerebro
image_mri = data.brain()
image_mri = image_mri[9,:,:] # Una rebanada del cerebro

plt.figure(figsize=(6,6))
plt.imshow(image_mri, cmap='gray')
plt.title("MRI: Cerebro y Tejidos Blandos")
plt.axis('off')
plt.show()
```
:::

::::

::: {.notes}
Con esta idea, podemos crear ventanas increíbles hacia el interior del cuerpo. Las **Radiografías (Rayos X)** son como la sombra del cuerpo; son excelentes para ver cosas densas como los huesos. Las **Resonancias Magnéticas (MRI)** son diferentes; crean un mapa detallado del agua en nuestro cuerpo, lo que las hace perfectas para ver tejidos blandos como el cerebro, los músculos o los órganos.
:::

---

## El Desafío: Hacer Visible lo Invisible

```{python}
#| echo: false
#| fig-cap: "Una imagen médica con bajo contraste donde los detalles son difíciles de ver."
from skimage import exposure

# Cargar una imagen y reducir su contraste artificialmente
image_original = data.camera()
image_low_contrast = exposure.rescale_intensity(image_original, in_range=(50, 150))

plt.figure(figsize=(8, 8))
plt.imshow(image_low_contrast, cmap='gray')
plt.title("Imagen con Bajo Contraste", fontsize=16)
plt.axis('off')
plt.show()
```

::: {.notes}
A veces, la información que buscamos en una imagen médica es muy sutil. Puede ser como tratar de encontrar a un amigo en una foto muy oscura o con mucha niebla. El contraste puede ser bajo, o los bordes entre un tejido sano y uno enfermo pueden ser borrosos. El ojo humano puede pasar por alto estos detalles cruciales.
:::

---

## La Solución: Resaltadores Digitales

:::: {.columns}

::: {.column width="45%"}
**Imagen Original**
```{python}
#| echo: false
plt.figure(figsize=(6, 6))
plt.imshow(image_low_contrast, cmap='gray')
plt.title("Original de Bajo Contraste")
plt.axis('off')
plt.show()
```
:::

::: {.column width="45%"}
**Imagen Mejorada**
```{python}
#| echo: false
# Aplicar ecualización de histograma para mejorar el contraste
image_enhanced = exposure.equalize_hist(image_low_contrast)

plt.figure(figsize=(6, 6))
plt.imshow(image_enhanced, cmap='gray')
plt.title("Contraste Mejorado")
plt.axis('off')
plt.show()
```
:::

::::

::: {.notes}
¡De nuevo, el procesamiento viene al rescate! Podemos darle 'superpoderes' a la imagen. Con el **ajuste de contraste**, le decimos a la computadora: 'haz que las partes oscuras sean más oscuras y las claras más claras', ¡como ajustar el brillo en Instagram! Fíjense cómo en la imagen de la derecha, los detalles que antes estaban ocultos ahora son perfectamente visibles. Otra técnica es la **detección de bordes**, que dibuja una línea donde hay un cambio brusco de brillo, ayudando a los médicos a ver la forma exacta de los órganos o tumores.
:::

# Parte III: Aplicaciones {background-image="../../recursos/imagenes/Talleres/laboratorio03.png" background-opacity="0.3"}

## Áreas de aplicación del procesamiento de señales e imágenes

:::: {.columns}

::: {.column width="45%"}
- **Diagnóstico automatizado**  
  Identificación de enfermedades en ECG, EEG o imágenes médicas.

- **Monitoreo en tiempo real**  
  Vigilancia en UCI con señales continuas de corazón, respiración y cerebro.

- **Telemedicina**  
  Transmisión y compresión de señales para consultas a distancia.

- **Rehabilitación y prótesis inteligentes**  
  Uso de señales EMG para controlar prótesis y exoesqueletos.
:::

::: {.column width="45%"}
- **Detección temprana de eventos críticos**  
  Anticipación de arritmias, crisis epilépticas o caídas.

- **Biometría y seguridad**  
  Reconocimiento de voz, rostro o iris.

- **Imagenología avanzada**  
  Segmentación de órganos o tumores en 3D para cirugía o radioterapia.

- **Entretenimiento y multimedia**  
  Filtros en fotos y videos, mejora de audio y realidad aumentada.
:::

::::

::: {.notes}
Guion: resaltar que la mitad de las aplicaciones impacta directamente en salud y la otra mitad en la vida cotidiana. Pedir a los estudiantes que piensen en qué columna usan más sin darse cuenta.
:::


## Plataforma para el monitoreo de salud de adultos mayores {background-image="../../recursos/imagenes/Talleres/aplicacion01.png" background-opacity="0.3"}

- Detección ambulatoria de actividades diarias.
- Detección ambulatoria de riesgo de caída.
- Detección ambulatoria de riesgo neuronal.
- Detección ambulatoria de riesgo psico-social.
- Detección ambulatoria de riesgo cardíaco
- Monitorización de terapias ambulatorias para la rehabilitación de adultos mayores

## Creación de ambientes de habitación saludables usando realimentación sensorial {background-image="../../recursos/imagenes/Talleres/aplicacion02.png" background-opacity="0.3"}

- Neurofeedback emocional usando música.
- Neurofeedback de memoria procedimental.
- Neurofeedback en automotores.
- Monitorización ambulatoria de estado emocional.
- Monitorización ambulatoria de terapias emocionales

## Apoyo tecnológico mediante IA a intervenciones clínicas{background-image="../../recursos/imagenes/Talleres/aplicacion03.png" background-opacity="0.3"}

- Detección de anomalías en imágenes mediante segmentación heurística.
- Planeación pre-operatoria mediante el uso de inteligencia artificial.
- Evaluación de espasticidad mediante el uso tecnología.

## Detección de información en terapias y proyectos de rehabilitación{background-image="../../recursos/imagenes/Talleres/aplicacion04.png" background-opacity="0.3"}

- Generación de interfaces cerebro-computador
- Generación de algoritmos de clasificación de intención de movimiento
- Monitorización de terapias de rehabilitación.

# Parte IV: ¡Tu Turno! Laboratorio Digital



## Nuestras Herramientas

Vamos a usar este mismo documento como nuestro **cuaderno de laboratorio digital**.

-   Verán bloques de código en **Python**.
-   **No necesitan ser expertos.** El código ya está escrito.
-   Su misión: **ejecutarlo** (con el botón de play ►), **observar** los resultados e incluso **experimentar** cambiando algunos valores.

¡Vamos a hacer ciencia de verdad!

::: {.notes}
¡Suficiente teoría! Es hora de que se pongan la bata de laboratorio. Vamos a usar este mismo documento como nuestro 'cuaderno de laboratorio digital'. Verán bloques de código en Python. No se asusten, no necesitan ser expertos. El código ya está escrito. Su misión es ejecutarlo, observar los resultados e incluso experimentar cambiando algunas cosas. ¡Vamos a hacer ciencia de verdad!
:::

---

## Misión 2: ¡De Números a Dibujos! 📝

**Objetivo:** Comprender que las señales e imágenes son, en el fondo, solo listas de números e instrucciones.

**Materiales:** Una hoja de papel cuadriculado y un lápiz.

**Instrucciones (Parte A - La Señal Misteriosa):**

1.  En tu hoja, dibuja un eje: el horizontal se llama "Tiempo" (de 1 a 10) y el vertical "Valor" (de 1 a 10).
2.  Te daré pares de números `(Tiempo, Valor)`. Dibuja un punto en cada coordenada.
3.  **Coordenadas:** (1, 2), (2, 4), (3, 6), (4, 8), (5, 6), (6, 4), (7, 2), (8, 4), (9, 6), (10, 8).
4.  Une los puntos en orden. ¿Qué letra o forma simple has dibujado?

**Instrucciones (Parte B - La Imagen Secreta):**

1.  En otra parte de tu hoja, dibuja una cuadrícula de 8x8.
2.  Te daré coordenadas `(fila, columna)` que debes rellenar o colorear. La fila 1 es la de arriba, la columna 1 es la de la izquierda.
3.  **Píxeles a colorear:**
    -   Fila 2: Columnas 3, 4, 5, 6
    -   Fila 3: Columnas 2, 7
    -   Fila 4: Columnas 2, 4, 5, 7
    -   Fila 5: Columnas 2, 7
    -   Fila 6: Columnas 3, 6
    -   Fila 7: Columnas 4, 5
4.  Aléjate un poco... ¿Qué imagen has creado?

## ¡Lo Lograron! {background-color="#006400"}

<br>
<br>


::: {.notes}
¡Felicidades! Tómense un momento para ver lo que han logrado. No solo vieron una presentación, sino que **hicieron** el trabajo de un ingeniero biomédico. Tomaron datos crudos e inutilizables —una señal ruidosa y una imagen sin detalles claros— y los transformaron en información clara y útil. ¡Acaban de dar el primer paso en un campo que salva vidas!
:::

---

## Misión 3: Rescatar un Latido

**El Reto:** Hemos recibido la señal de ECG de un paciente, pero está llena de ruido. Es imposible para un médico leerla así.

**Tu Tarea:** Ejecuta el código de abajo para aplicar un filtro digital y limpiar la señal. ¡El diagnóstico del paciente depende de ti!

```{python}
#| label: mision-1
#| eval: true

import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import savgol_filter
import seaborn as sns

sns.set_style("whitegrid")
plt.rcParams['font.family'] = 'Fira Code'

# --- PASO 1: Generar la señal de un paciente (ECG con ruido) ---
fs = 500
tiempo = np.arange(1500) / fs

# Señal limpia (la que queremos encontrar)
latido_limpio = np.sin(2 * np.pi * 1 * tiempo) * 10
latido_limpio[tiempo % 1 < 0.1] *= 5 # Simular pico QRS
latido_limpio[tiempo % 1 > 0.8] *= 0.5 # Simular onda T
ecg_limpio = np.tile(latido_limpio[:fs], 3)

# Añadir ruido para simular una mala medición
np.random.seed(101)
ruido = 2.5 * np.random.randn(len(ecg_limpio))
ecg_ruidoso = ecg_limpio + ruido

# --- PASO 2: Visualizar la señal ruidosa ---
print("Mostrando la señal original recibida del paciente...")
plt.figure(figsize=(12, 5))
plt.plot(tiempo, ecg_ruidoso, label='Señal Ruidosa Original', color='purple')
plt.title('Señal del Paciente (Sin Procesar)', fontsize=16)
plt.xlabel('Tiempo (s)')
plt.ylabel('Amplitud (mV)')
plt.legend()
plt.show()

# --- PASO 3: Aplicar el filtro para limpiar la señal ---
# <<< ¡LA LÍNEA MÁGICA! Este es el filtro.
# Prueba cambiar window_length a un número más pequeño (ej. 11) o más grande (ej. 101) y ve qué pasa.
ecg_filtrado = savgol_filter(ecg_ruidoso, window_length=51, polyorder=3)

# --- PASO 4: Visualizar la señal limpia ---
print("\n¡Filtro aplicado! Mostrando la señal recuperada...")
plt.figure(figsize=(12, 5))
plt.plot(tiempo, ecg_filtrado, label='Señal Filtrada y Limpia', color='green', linewidth=2.5)
plt.title('Señal del Paciente (Procesada)', fontsize=16)
plt.xlabel('Tiempo (s)')
plt.ylabel('Amplitud (mV)')
plt.legend()
plt.show()
```

---

## Misión 4: Mapear el Cerebro

**El Reto:** Tenemos una imagen de resonancia magnética. Para estudiarla, un neurólogo necesita ver claramente los contornos de las diferentes estructuras.

**Tu Tarea:** Ejecuta el código para aplicar un filtro de 'detección de bordes' y crear un mapa de los contornos del cerebro.

```{python}
# | label: mision-2
# | eval: true

import matplotlib.pyplot as plt
from skimage import data, filters, color
import seaborn as sns

sns.set_style("white")
plt.rcParams["font.family"] = "Fira Code"

# --- PASO 1: Cargar la imagen del cerebro ---
# Usamos una imagen de ejemplo de scikit-image
print("Cargando imagen de resonancia magnética...")
imagen_original = data.brain()[9, :, :]

# --- PASO 2: Aplicar el filtro de detección de bordes ---
# <<< ¡LA LÍNEA MÁGICA! Este es el filtro de Sobel.
# Detecta dónde hay cambios bruscos de brillo.
bordes = filters.sobel(imagen_original)

# --- PASO 3: Mostrar los resultados lado a lado ---
print("¡Filtro de bordes aplicado! Mostrando comparación...")
fig, axes = plt.subplots(1, 2, figsize=(12, 6))

# Imagen original
ax = axes
ax[0].imshow(imagen_original, cmap=plt.cm.gray)
ax[0].set_title("Imagen Original del Cerebro", fontsize=14)
ax[0].axis("off")

# Imagen con bordes detectados
ax[1].imshow(bordes, cmap=plt.cm.gray)
ax[1].set_title("Mapa de Contornos (Bordes)", fontsize=14)
ax[1].axis("off")

plt.tight_layout()
plt.show()
```

---


## ¿Por Qué Importa? El Futuro de la Medicina

Lo que hicieron hoy es la base para:

-   **Inteligencia Artificial** que diagnostica enfermedades.
-   **Robots cirujanos** de alta precisión.
-   **Medicamentos personalizados** para cada paciente.
-   **Monitores de salud** en nuestros relojes y celulares.

El futuro de la salud se está construyendo con código, y ustedes ya saben cómo empezar.

::: {.notes}
Lo que hicieron hoy a pequeña escala es la base de la medicina del futuro. Estos mismos principios de limpieza de señales y mejora de imágenes son el primer paso para todo: para que la Inteligencia Artificial pueda diagnosticar enfermedades, para guiar a los robots en cirugías de alta precisión y para crear medicamentos personalizados para cada paciente. El futuro de la salud se está construyendo con código, y ustedes ya saben cómo empezar.
:::

---

## ¿Preguntas?

### ¡Gracias!

::: {.notes}
Gracias por su atención y su excelente trabajo como ingenieros. Ahora, me encantaría responder a cualquier pregunta que tengan.
:::
