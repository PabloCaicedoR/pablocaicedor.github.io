---
title: "Procesamiento de Se√±ales e Imagenes"
description: "PSIM -- 101849"
subtitle: "Ingenier√≠a Biom√©dica"
lang: es
author: "Ph.D. Pablo Eduardo Caicedo-Rodr√≠guez"
date: last-modified
format:
    revealjs:
        code-tools: true
        code-overflow: wrap
        code-line-numbers: true
        code-copy: true
        fig-align: center
        self-contained: true
        theme:
        - simple
        - ../../recursos/estilos/metropolis.scss
        slide-number: true
        preview-links: auto
        logo: ../../recursos/imagenes/generales/Escuela_Rosario_logo.png
        css: ../../recursos/estilos/styles_pres.scss
        footer: <https://pablocaicedor.github.io/>
        transition: fade
        progress: true
        scrollable: true
        mainfont: "Fira Code"
---

# ¬°Bienvenidos! {background-image="https://images.unsplash.com/photo-1579154204601-01588f351e67?q=80&w=2070&auto=format&fit=crop" background-opacity="0.3"}

::: {.notes}
¬°Hola a todos y bienvenidos! Soy Pablo Caicedo, y hoy vamos a hacer algo incre√≠ble: vamos a aprender a ver lo invisible. Vamos a explorar c√≥mo le ense√±amos a las computadoras a entender el lenguaje secreto del cuerpo humano. Este campo se llama Procesamiento de Se√±ales e Im√°genes Biom√©dicas, y es una de las √°reas m√°s emocionantes de la ingenier√≠a y la medicina hoy en d√≠a.
:::

---

## La Gran Pregunta

::: {.callout-note}
> ¬øY si tu celular pudiera detectar una enfermedad card√≠aca con solo tocarlo?
>
> ¬øY si una computadora pudiera ver un tumor que el ojo humano m√°s experto a√∫n no distingue?
:::




::: {.notes}
Imaginen por un momento... ¬øY si su celular pudiera detectar una enfermedad card√≠aca con solo tocarlo? ¬øY si una computadora pudiera ver un tumor en una radiograf√≠a, incluso antes de que el ojo humano m√°s experto lo note? Esto no es ciencia ficci√≥n. Es lo que hacemos todos los d√≠as en este campo. La pregunta no es 'si' es posible, sino 'c√≥mo' lo hacemos posible.
:::

---

## Bienvenida

**Procesamiento de se√±ales e im√°genes**
*De los sonidos y las fotos a la salud y la tecnolog√≠a.*

::: {.notes}
Guion: Preguntar a los estudiantes: ¬øQu√© se√±ales usan sin darse cuenta? (Wi-Fi, m√∫sica, ritmo del coraz√≥n). Explicar que hoy aprender√°n a mirar c√≥mo las computadoras entienden esas se√±ales e im√°genes.
:::

## Nuestro Viaje de Hoy

1.  **Los Lenguajes Secretos del Cuerpo:** Descubriremos las se√±ales el√©ctricas que nos mantienen vivos.

2.  **Una Imagen Vale M√°s que Mil Pruebas:** Veremos c√≥mo convertimos el interior del cuerpo en im√°genes.

3.  **El Truco de Magia: 'Procesar':** Aprenderemos a limpiar y mejorar estos datos para encontrar pistas.

4.  **¬°Tu Turno! Convi√©rtete en Ingeniero/a Biom√©dico/a:** Realizar√°n an√°lisis reales en nuestro laboratorio digital.

::: {.notes}
Para entender c√≥mo funciona esta 'magia', nuestro viaje de hoy tendr√° cuatro paradas. Primero, descifraremos los lenguajes secretos del cuerpo, las se√±ales el√©ctricas. Luego, veremos c√≥mo creamos im√°genes del interior de nuestro cuerpo. Despu√©s, revelaremos el truco de magia que llamamos 'procesamiento' para limpiar y mejorar estos datos. Y finalmente, la parte m√°s emocionante: ustedes mismos se convertir√°n en ingenieros y realizar√°n an√°lisis en nuestro laboratorio digital.
:::

---

# Parte I: Se√±ales Biom√©dicas {background-image="../../recursos/imagenes/Talleres/laboratorio01.png" background-opacity="0.3"}

---

## ¬øQu√© es una Se√±al? Informaci√≥n en Movimiento

```{python}
#| echo: false
#| fig-cap: "Una se√±al es simplemente informaci√≥n que cambia con el tiempo."

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Estilo de la gr√°fica
sns.set_style("whitegrid")
plt.rcParams['font.family'] = 'Fira Code'

# Generar datos para una onda sinusoidal
tiempo = np.linspace(0, 10, 500)
amplitud = np.sin(tiempo)

# Crear la gr√°fica
fig, ax = plt.subplots(figsize=(10, 5))
ax.plot(tiempo, amplitud, lw=3, color='#007acc')
ax.set_title("Ejemplo de una Se√±al Simple", fontsize=16)
ax.set_xlabel("Tiempo (segundos)", fontsize=12)
ax.set_ylabel("Valor / Amplitud", fontsize=12)
ax.grid(True, which='both', linestyle='--', linewidth=0.5)
ax.set_ylim(-1.5, 1.5)
plt.show()
```

::: {.notes}
Empecemos por lo b√°sico. ¬øQu√© es una se√±al? Es simplemente informaci√≥n que cambia con el tiempo. Piensen en la m√∫sica: las notas suben y bajan, creando una melod√≠a. Eso es una se√±al. O la temperatura a lo largo de un d√≠a: sube al mediod√≠a y baja por la noche. En el cuerpo, en lugar de notas o grados, medimos cosas como la actividad el√©ctrica, que sube y baja de formas muy espec√≠ficas.
:::

---

## La Sinfon√≠a El√©ctrica del Cuerpo

:::: {.columns}

::: {.column width="45%"}
El **Electrocardiograma (ECG)** es el ritmo del coraz√≥n, nuestro tambor principal.
```{python}
#| echo: false
#| fig-cap: "Se√±al de ECG ideal, mostrando el patr√≥n r√≠tmico del coraz√≥n."

def generar_ecg_limpio(n_latidos=3, fs=500):
    """Genera una se√±al de ECG sint√©tica y limpia."""
    t_latido = np.linspace(-0.5, 0.5, fs // 2)

    # Ondas P, QRS, T (simplificadas)
    p = 0.1 * np.exp(- (t_latido - 0.2)**2 / 0.001)
    qrs = 1.0 * np.exp(-t_latido**2 / 0.0005) - 0.2 * np.exp(-(t_latido-0.02)**2 / 0.001)
    t = 0.2 * np.exp(- (t_latido + 0.2)**2 / 0.005)

    latido = p + qrs + t
    ecg = np.tile(latido, n_latidos)
    tiempo = np.arange(len(ecg)) / fs
    return tiempo, ecg

tiempo_limpio, ecg_limpio = generar_ecg_limpio(n_latidos=4, fs=500)

fig, ax = plt.subplots(figsize=(8, 4))
ax.plot(tiempo_limpio, ecg_limpio, color='red', lw=2)
ax.set_title("Se√±al de un Coraz√≥n Sano (ECG)", fontsize=14)
ax.set_xlabel("Tiempo (s)", fontsize=10)
ax.set_ylabel("Amplitud (mV)", fontsize=10)
ax.grid(True, linestyle='--', alpha=0.6)
plt.tight_layout()
plt.show()

```
:::

::: {.column width="45%"}
**¬øQu√© nos dice el ECG?**

-   ¬øCu√°l es el **ritmo card√≠aco**?
-   ¬øEl coraz√≥n late muy **r√°pido** o muy **lento**?
-   ¬øHay alguna parte que no funciona en **armon√≠a**?
-   Permite diagnosticar problemas y salvar vidas.

:::

::::

::: {.notes}
Nuestro cuerpo es como una orquesta el√©ctrica. El coraz√≥n es el tambor, marcando un ritmo constante y poderoso. La se√±al que produce se llama **Electrocardiograma o ECG**. El cerebro es como la secci√≥n de cuerdas, con miles de neuronas 'hablando' a la vez en una conversaci√≥n compleja. Esa se√±al es el **Electroencefalograma o EEG**. Escuchando estas 'melod√≠as', los m√©dicos pueden saber si todo funciona en armon√≠a.
:::

---

## El Desaf√≠o: Encontrar la Se√±al en el Ruido

```{python}
#| echo: false
#| fig-cap: "Una se√±al de ECG real a menudo est√° contaminada con ruido."

# A√±adir ruido a la se√±al limpia
np.random.seed(42)
ruido = 0.4 * np.random.normal(0, 1, len(ecg_limpio))
ecg_ruidoso = ecg_limpio + ruido

fig, ax = plt.subplots(figsize=(10, 5))
ax.plot(tiempo_limpio, ecg_ruidoso, color='purple', lw=1.5)
ax.set_title("ECG con Ruido: ¬°Dif√≠cil de Leer!", fontsize=16)
ax.set_xlabel("Tiempo (s)", fontsize=12)
ax.set_ylabel("Amplitud (mV)", fontsize=12)
ax.grid(True, linestyle='--', alpha=0.6)
plt.show()
```

::: {.notes}
Pero en el mundo real, estas se√±ales no son tan claras. Imaginen tratar de escuchar a un amigo en una fiesta muy ruidosa. El 'ruido' es todo lo que interfiere: otros aparatos el√©ctricos, el movimiento del paciente, etc. Este ruido puede ocultar informaci√≥n vital que el m√©dico necesita ver. Como ven aqu√≠, el patr√≥n claro del latido casi ha desaparecido.
:::

---

## La Soluci√≥n: Cancelaci√≥n de Ruido Digital

:::: {.columns}

::: {.column width="45%"}
**Se√±al Ruidosa (Original)**
```{python}
#| echo: false
fig, ax = plt.subplots(figsize=(8, 4))
ax.plot(tiempo_limpio, ecg_ruidoso, color='purple', lw=1.5)
ax.set_title("Se√±al Original", fontsize=14)
ax.set_xlabel("Tiempo (s)", fontsize=10)
ax.set_ylabel("Amplitud (mV)", fontsize=10)
ax.grid(True, linestyle='--', alpha=0.6)
plt.tight_layout()
plt.show()
```
:::

::: {.column width="45%"}
**Se√±al Filtrada (Limpia)**
```{python}
#| echo: false
from scipy.signal import savgol_filter

# Aplicar un filtro (Savitzky-Golay es bueno para preservar la forma)
ecg_filtrado = savgol_filter(ecg_ruidoso, window_length=51, polyorder=3)

fig, ax = plt.subplots(figsize=(8, 4))
ax.plot(tiempo_limpio, ecg_filtrado, color='green', lw=2)
ax.set_title("Se√±al Recuperada", fontsize=14)
ax.set_xlabel("Tiempo (s)", fontsize=10)
ax.set_ylabel("Amplitud (mV)", fontsize=10)
ax.grid(True, linestyle='--', alpha=0.6)
plt.tight_layout()
plt.show()
```
:::

::::

::: {.notes}
Aqu√≠ es donde entra nuestra 'magia'. Usamos algoritmos de 'filtrado'. Es como ponerse unos aud√≠fonos con cancelaci√≥n de ruido. La computadora mira cada punto de la se√±al y lo promedia con sus vecinos de una manera inteligente. El ruido, al ser aleatorio y r√°pido, se cancela, ¬°pero el patr√≥n real del latido, que es m√°s lento y repetitivo, se mantiene! As√≠ 'rescatamos' la informaci√≥n importante, como pueden ver en la gr√°fica de la derecha. Pasamos de algo ilegible a una se√±al clara y diagn√≥stica.
:::


# Parte II: Im√°genes Biom√©dicas {background-image="../../recursos/imagenes/Talleres/laboratorio02.png" background-opacity="0.3"}



## ¬øQu√© es una Imagen? Una Pintura por N√∫meros

:::: {.columns}

::: {.column width="45%"}
**Los N√∫meros (P√≠xeles)**
```{python}
# | echo: false
# | fig-cap: "Matriz de n√∫meros que representa una imagen simple."
np.random.seed(0)
pixel_data = np.random.randint(0, 256, size=(8, 8))

fig, ax = plt.subplots(figsize=(6, 6))
sns.heatmap(
    pixel_data,
    annot=True,
    fmt="d",
    cmap="gray",
    cbar=False,
    linewidths=0.5,
    linecolor="black",
    ax=ax,
    annot_kws={"size": 10},
)
ax.set_title("Los Valores de los P√≠xeles", fontsize=14)
# ax.set_xticks([])
# ax.set_yticks([])
plt.show()
```
:::

::: {.column width="45%"}
**La Imagen Resultante**
```{python}
# | echo: false
# | fig-cap: "La imagen en escala de grises generada por la matriz de n√∫meros."
fig, ax = plt.subplots(figsize=(6, 6))
ax.imshow(pixel_data, cmap="gray", interpolation="nearest")
ax.set_title("La Imagen que Vemos", fontsize=14)
# ax[0].set_xticks([])
# ax[0].set_yticks([])
plt.show()
```
:::

::::

::: {.notes}
Ahora hablemos de im√°genes. Para una computadora, una imagen no es una foto, es una cuadr√≠cula gigante de n√∫meros. ¬°Como un lienzo para pintar por n√∫meros! Cada n√∫mero representa el brillo de un puntito llamado 'p√≠xel'. Un n√∫mero bajo como 0 puede ser negro, un n√∫mero alto como 255 puede ser blanco, y los n√∫meros intermedios son todos los tonos de gris. A la izquierda ven los n√∫meros, y a la derecha, la imagen que la computadora crea a partir de ellos.
:::

---

## Una Ventana Hacia el Cuerpo

:::: {.columns}

::: {.column width="45%"}
**Radiograf√≠a (Rayos X)**
Ideal para ver estructuras densas como los huesos.

```{python}
#| echo: false
#| fig-cap: "Ejemplo de una radiograf√≠a de t√≥rax."
from skimage import data
from skimage.transform import resize

# Usamos una imagen de ejemplo que se asemeje a una estructura √≥sea
image_xray = data.human_mitosis()
image_xray = image_xray[0:256, 0:256] # Recortar para que parezca una radiograf√≠a

plt.figure(figsize=(6,6))
plt.imshow(image_xray, cmap='gray')
plt.title("Radiograf√≠a: Huesos y Tejidos Densos")
plt.axis('off')
plt.show()
```
:::

::: {.column width="45%"}
**Resonancia Magn√©tica (MRI)**
Perfecta para ver tejidos blandos como el cerebro.

```{python}
#| echo: false
#| fig-cap: "Ejemplo de una resonancia magn√©tica cerebral."
# Usamos una imagen de ejemplo de cerebro
image_mri = data.brain()
image_mri = image_mri[9,:,:] # Una rebanada del cerebro

plt.figure(figsize=(6,6))
plt.imshow(image_mri, cmap='gray')
plt.title("MRI: Cerebro y Tejidos Blandos")
plt.axis('off')
plt.show()
```
:::

::::

::: {.notes}
Con esta idea, podemos crear ventanas incre√≠bles hacia el interior del cuerpo. Las **Radiograf√≠as (Rayos X)** son como la sombra del cuerpo; son excelentes para ver cosas densas como los huesos. Las **Resonancias Magn√©ticas (MRI)** son diferentes; crean un mapa detallado del agua en nuestro cuerpo, lo que las hace perfectas para ver tejidos blandos como el cerebro, los m√∫sculos o los √≥rganos.
:::

---

## El Desaf√≠o: Hacer Visible lo Invisible

```{python}
#| echo: false
#| fig-cap: "Una imagen m√©dica con bajo contraste donde los detalles son dif√≠ciles de ver."
from skimage import exposure

# Cargar una imagen y reducir su contraste artificialmente
image_original = data.camera()
image_low_contrast = exposure.rescale_intensity(image_original, in_range=(50, 150))

plt.figure(figsize=(8, 8))
plt.imshow(image_low_contrast, cmap='gray')
plt.title("Imagen con Bajo Contraste", fontsize=16)
plt.axis('off')
plt.show()
```

::: {.notes}
A veces, la informaci√≥n que buscamos en una imagen m√©dica es muy sutil. Puede ser como tratar de encontrar a un amigo en una foto muy oscura o con mucha niebla. El contraste puede ser bajo, o los bordes entre un tejido sano y uno enfermo pueden ser borrosos. El ojo humano puede pasar por alto estos detalles cruciales.
:::

---

## La Soluci√≥n: Resaltadores Digitales

:::: {.columns}

::: {.column width="45%"}
**Imagen Original**
```{python}
#| echo: false
plt.figure(figsize=(6, 6))
plt.imshow(image_low_contrast, cmap='gray')
plt.title("Original de Bajo Contraste")
plt.axis('off')
plt.show()
```
:::

::: {.column width="45%"}
**Imagen Mejorada**
```{python}
#| echo: false
# Aplicar ecualizaci√≥n de histograma para mejorar el contraste
image_enhanced = exposure.equalize_hist(image_low_contrast)

plt.figure(figsize=(6, 6))
plt.imshow(image_enhanced, cmap='gray')
plt.title("Contraste Mejorado")
plt.axis('off')
plt.show()
```
:::

::::

::: {.notes}
¬°De nuevo, el procesamiento viene al rescate! Podemos darle 'superpoderes' a la imagen. Con el **ajuste de contraste**, le decimos a la computadora: 'haz que las partes oscuras sean m√°s oscuras y las claras m√°s claras', ¬°como ajustar el brillo en Instagram! F√≠jense c√≥mo en la imagen de la derecha, los detalles que antes estaban ocultos ahora son perfectamente visibles. Otra t√©cnica es la **detecci√≥n de bordes**, que dibuja una l√≠nea donde hay un cambio brusco de brillo, ayudando a los m√©dicos a ver la forma exacta de los √≥rganos o tumores.
:::

# Parte III: Aplicaciones {background-image="../../recursos/imagenes/Talleres/laboratorio03.png" background-opacity="0.3"}

## √Åreas de aplicaci√≥n del procesamiento de se√±ales e im√°genes

:::: {.columns}

::: {.column width="45%"}
- **Diagn√≥stico automatizado**
  Identificaci√≥n de enfermedades en ECG, EEG o im√°genes m√©dicas.

- **Monitoreo en tiempo real**
  Vigilancia en UCI con se√±ales continuas de coraz√≥n, respiraci√≥n y cerebro.

- **Telemedicina**
  Transmisi√≥n y compresi√≥n de se√±ales para consultas a distancia.

- **Rehabilitaci√≥n y pr√≥tesis inteligentes**
  Uso de se√±ales EMG para controlar pr√≥tesis y exoesqueletos.
:::

::: {.column width="45%"}
- **Detecci√≥n temprana de eventos cr√≠ticos**
  Anticipaci√≥n de arritmias, crisis epil√©pticas o ca√≠das.

- **Biometr√≠a y seguridad**
  Reconocimiento de voz, rostro o iris.

- **Imagenolog√≠a avanzada**
  Segmentaci√≥n de √≥rganos o tumores en 3D para cirug√≠a o radioterapia.

- **Entretenimiento y multimedia**
  Filtros en fotos y videos, mejora de audio y realidad aumentada.
:::

::::

::: {.notes}
Guion: resaltar que la mitad de las aplicaciones impacta directamente en salud y la otra mitad en la vida cotidiana. Pedir a los estudiantes que piensen en qu√© columna usan m√°s sin darse cuenta.
:::


## Plataforma para el monitoreo de salud de adultos mayores {background-image="../../recursos/imagenes/Talleres/aplicacion01.png" background-opacity="0.3"}

- Detecci√≥n ambulatoria de actividades diarias.
- Detecci√≥n ambulatoria de riesgo de ca√≠da.
- Detecci√≥n ambulatoria de riesgo neuronal.
- Detecci√≥n ambulatoria de riesgo psico-social.
- Detecci√≥n ambulatoria de riesgo card√≠aco
- Monitorizaci√≥n de terapias ambulatorias para la rehabilitaci√≥n de adultos mayores

## Creaci√≥n de ambientes de habitaci√≥n saludables usando realimentaci√≥n sensorial {background-image="../../recursos/imagenes/Talleres/aplicacion02.png" background-opacity="0.3"}

- Neurofeedback emocional usando m√∫sica.
- Neurofeedback de memoria procedimental.
- Neurofeedback en automotores.
- Monitorizaci√≥n ambulatoria de estado emocional.
- Monitorizaci√≥n ambulatoria de terapias emocionales

## Apoyo tecnol√≥gico mediante IA a intervenciones cl√≠nicas{background-image="../../recursos/imagenes/Talleres/aplicacion03.png" background-opacity="0.3"}

- Detecci√≥n de anomal√≠as en im√°genes mediante segmentaci√≥n heur√≠stica.
- Planeaci√≥n pre-operatoria mediante el uso de inteligencia artificial.
- Evaluaci√≥n de espasticidad mediante el uso tecnolog√≠a.

## Detecci√≥n de informaci√≥n en terapias y proyectos de rehabilitaci√≥n{background-image="../../recursos/imagenes/Talleres/aplicacion04.png" background-opacity="0.3"}

- Generaci√≥n de interfaces cerebro-computador
- Generaci√≥n de algoritmos de clasificaci√≥n de intenci√≥n de movimiento
- Monitorizaci√≥n de terapias de rehabilitaci√≥n.

## Invitaci√≥n

![Invitaci√≥n](../../recursos/imagenes/Talleres/cartel.png)

# Parte IV: ¬°Tu Turno! Laboratorio Digital



## Nuestras Herramientas

Vamos a usar este mismo documento como nuestro **cuaderno de laboratorio digital**.

-   Ver√°n bloques de c√≥digo en **Python**.
-   **No necesitan ser expertos.** El c√≥digo ya est√° escrito.
-   Su misi√≥n: **ejecutarlo** (con el bot√≥n de play ‚ñ∫), **observar** los resultados e incluso **experimentar** cambiando algunos valores.

¬°Vamos a hacer ciencia de verdad!

::: {.notes}
¬°Suficiente teor√≠a! Es hora de que se pongan la bata de laboratorio. Vamos a usar este mismo documento como nuestro 'cuaderno de laboratorio digital'. Ver√°n bloques de c√≥digo en Python. No se asusten, no necesitan ser expertos. El c√≥digo ya est√° escrito. Su misi√≥n es ejecutarlo, observar los resultados e incluso experimentar cambiando algunas cosas. ¬°Vamos a hacer ciencia de verdad!
:::

---

## Misi√≥n 1: ¬°De N√∫meros a Dibujos! üìù

**Objetivo:** Comprender que las im√°genes son, en el fondo, solo listas de n√∫meros e instrucciones.

**Materiales:** Una hoja de papel cuadriculado y un l√°piz.

**Instrucciones (Parte A - La Imagen Misteriosa):**

En una hoja resalta los n√∫meros pares y los primos permitiendo ver el mensaje secreto.

```{python}
# | echo: false
# | eval: true
# | output: true
# | label: matrix
# | fig-align: center

"""
Matrix 15x15 with two letters:
- "I" drawn using EVEN numbers.
- "B" drawn using PRIME numbers.
- Background filled with ODD COMPOSITE numbers to visually "hide" the letters.

Reproducible and self-contained.
"""

import numpy as np

rng = np.random.default_rng(42)


# --- helpers ---
def is_prime(n: int) -> bool:
    if n < 2:
        return False
    if n % 2 == 0:
        return n == 2
    d = 3
    while d * d <= n:
        if n % d == 0:
            return False
        d += 2
    return True


# pools
even_pool = np.array([n for n in range(2, 100) if n % 2 == 0])
prime_pool = np.array([n for n in range(2, 100) if is_prime(n)])
# odd composite numbers (not prime, not even, >1)
oddcomp_pool = np.array([n for n in range(3, 100, 2) if not is_prime(n)])

# --- canvas ---
H, W = 15, 15
M = rng.choice(oddcomp_pool, size=(H, W))  # background: odd composite


# Coordinate helper (row, col) with 0-based indexing
def put(vals, coords):
    """Place random values from `vals` at integer coordinates `coords`."""
    rr, cc = zip(*coords)
    M[tuple(rr), tuple(cc)] = rng.choice(vals, size=len(coords))


# --- draw "I" with even numbers (left side) ---
# Use a simple blocky "I": top bar, vertical stem, bottom bar
top_row, bottom_row = 2, 12  # keep margins
left_col, right_col = 1, 3
stem_col = 2

I_coords = []
# top bar
I_coords += [(top_row, c) for c in range(left_col, right_col + 1)]
# bottom bar
I_coords += [(bottom_row, c) for c in range(left_col, right_col + 1)]
# vertical stem
I_coords += [(r, stem_col) for r in range(top_row, bottom_row + 1)]

put(even_pool, I_coords)

# --- draw "B" with primes (right side) ---
# Spine + two bowls (top and bottom) approximated with block pixels
spine_col = 10
right_edge = 12
top, mid, bot = 2, 7, 12

B_coords = []
# vertical spine
B_coords += [(r, spine_col) for r in range(top, bot + 1)]
# top horizontal
B_coords += [(top, c) for c in range(spine_col, right_edge + 1)]
# mid horizontal (waist)
B_coords += [(mid, c) for c in range(spine_col, right_edge)]
# bottom horizontal
B_coords += [(bot, c) for c in range(spine_col, right_edge + 1)]
# right edges of bowls
B_coords += [(r, right_edge) for r in range(top + 1, mid)]
B_coords += [(r, right_edge) for r in range(mid + 1, bot)]

put(prime_pool, B_coords)


# --- sanity checks (optional) ---
def all_in_pool(vals, coords):
    rr, cc = zip(*coords)
    flat = M[tuple(rr), tuple(cc)].ravel().tolist()
    return all(v in vals for v in flat)


assert all_in_pool(set(even_pool.tolist()), I_coords), "I must be even numbers"
assert all_in_pool(set(prime_pool.tolist()), B_coords), "B must be primes"

# Background should be odd composite (not even, not prime)
for r in range(H):
    for c in range(W):
        if (r, c) in I_coords or (r, c) in B_coords:
            continue
        v = M[r, c]
        assert v % 2 == 1 and not is_prime(v), "Background must be odd composite"

# --- pretty print ---
np.set_printoptions(linewidth=200, formatter={"int": lambda x: f"{x:02d}"})
# print(M)


# --- Funci√≥n para identificar primos ---
def is_prime(n: int) -> bool:
    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    for i in range(3, int(n**0.5) + 1, 2):
        if n % i == 0:
            return False
    return True


# # Crear matriz aleatoria 15x15 con n√∫meros entre 1 y 100
# np.random.seed(42)
# M = np.random.randint(1, 100, (15, 5))

# M√°scaras l√≥gicas
mask_even = M % 2 == 0  # pares
mask_prime = np.vectorize(is_prime)(M)  # primos

# --- Visualizaci√≥n ---
fig, ax = plt.subplots(figsize=(10, 6.7))
ax.matshow(np.ones_like(M), cmap="gray_r")  # fondo gris claro

# Mostrar n√∫meros
for i in range(M.shape[0]):
    for j in range(M.shape[1]):
        val = M[i, j]
        color = "black"
        weight = "normal"
        if mask_even[i, j]:
            color = "black"
            weight = "normal"
        if mask_prime[i, j]:
            color = "black"
            weight = "normal"
        ax.text(
            j, i, f"{val:2d}", va="center", ha="center", color=color, fontweight=weight
        )

ax.set_xticks([])
ax.set_yticks([])
ax.set_title("Matriz 15x15", fontsize=36)
plt.show()

```


## Misi√≥n 2: ¬°De N√∫meros a Dibujos! üìù

**Objetivo:** Comprender que las se√±ales e im√°genes son, en el fondo, solo listas de n√∫meros e instrucciones.

**Materiales:** Una hoja de papel cuadriculado y un l√°piz.

**Instrucciones (Parte A - La Se√±al Misteriosa):**

1.  En tu hoja, dibuja un eje: el horizontal se llama "Tiempo" (de 1 a 10) y el vertical "Valor" (de 1 a 10).
2.  Te dar√© pares de n√∫meros `(Tiempo, Valor)`. Dibuja un punto en cada coordenada.
3.  **Coordenadas:** (1, 2), (2, 4), (3, 6), (4, 8), (5, 6), (6, 4), (7, 2), (8, 4), (9, 6), (10, 8).
4.  Une los puntos en orden. ¬øQu√© letra o forma simple has dibujado?

**Instrucciones (Parte B - La Imagen Secreta):**

1.  En otra parte de tu hoja, dibuja una cuadr√≠cula de 8x8.
2.  Te dar√© coordenadas `(fila, columna)` que debes rellenar o colorear. La fila 1 es la de arriba, la columna 1 es la de la izquierda.
3.  **P√≠xeles a colorear:**
    -   Fila 2: Columnas 3, 4, 5, 6
    -   Fila 3: Columnas 2, 7
    -   Fila 4: Columnas 2, 4, 5, 7
    -   Fila 5: Columnas 2, 7
    -   Fila 6: Columnas 3, 6
    -   Fila 7: Columnas 4, 5
4.  Al√©jate un poco... ¬øQu√© imagen has creado?

---

## Misi√≥n 3: Rescatar un Latido

**El Reto:** Hemos recibido la se√±al de ECG de un paciente, pero est√° llena de ruido. Es imposible para un m√©dico leerla as√≠.

**Tu Tarea:** Ejecuta el c√≥digo de abajo para aplicar un filtro digital y limpiar la se√±al. ¬°El diagn√≥stico del paciente depende de ti!

```{python}
#| label: mision-1
#| eval: true

import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import savgol_filter
import seaborn as sns

sns.set_style("whitegrid")
plt.rcParams['font.family'] = 'Fira Code'

# --- PASO 1: Generar la se√±al de un paciente (ECG con ruido) ---
fs = 500
tiempo = np.arange(1500) / fs

# Se√±al limpia (la que queremos encontrar)
latido_limpio = np.sin(2 * np.pi * 1 * tiempo) * 10
latido_limpio[tiempo % 1 < 0.1] *= 5 # Simular pico QRS
latido_limpio[tiempo % 1 > 0.8] *= 0.5 # Simular onda T
ecg_limpio = np.tile(latido_limpio[:fs], 3)

# A√±adir ruido para simular una mala medici√≥n
np.random.seed(101)
ruido = 2.5 * np.random.randn(len(ecg_limpio))
ecg_ruidoso = ecg_limpio + ruido

# --- PASO 2: Visualizar la se√±al ruidosa ---
print("Mostrando la se√±al original recibida del paciente...")
plt.figure(figsize=(12, 5))
plt.plot(tiempo, ecg_ruidoso, label='Se√±al Ruidosa Original', color='purple')
plt.title('Se√±al del Paciente (Sin Procesar)', fontsize=16)
plt.xlabel('Tiempo (s)')
plt.ylabel('Amplitud (mV)')
plt.legend()
plt.show()

# --- PASO 3: Aplicar el filtro para limpiar la se√±al ---
# <<< ¬°LA L√çNEA M√ÅGICA! Este es el filtro.
# Prueba cambiar window_length a un n√∫mero m√°s peque√±o (ej. 11) o m√°s grande (ej. 101) y ve qu√© pasa.
ecg_filtrado = savgol_filter(ecg_ruidoso, window_length=51, polyorder=3)

# --- PASO 4: Visualizar la se√±al limpia ---
print("\n¬°Filtro aplicado! Mostrando la se√±al recuperada...")
plt.figure(figsize=(12, 5))
plt.plot(tiempo, ecg_filtrado, label='Se√±al Filtrada y Limpia', color='green', linewidth=2.5)
plt.title('Se√±al del Paciente (Procesada)', fontsize=16)
plt.xlabel('Tiempo (s)')
plt.ylabel('Amplitud (mV)')
plt.legend()
plt.show()
```

---

## Misi√≥n 4: Mapear el Cerebro

**El Reto:** Tenemos una imagen de resonancia magn√©tica. Para estudiarla, un neur√≥logo necesita ver claramente los contornos de las diferentes estructuras.

**Tu Tarea:** Ejecuta el c√≥digo para aplicar un filtro de 'detecci√≥n de bordes' y crear un mapa de los contornos del cerebro.

```{python}
# | label: mision-2
# | eval: true

import matplotlib.pyplot as plt
from skimage import data, filters, color
import seaborn as sns

sns.set_style("white")
plt.rcParams["font.family"] = "Fira Code"

# --- PASO 1: Cargar la imagen del cerebro ---
# Usamos una imagen de ejemplo de scikit-image
print("Cargando imagen de resonancia magn√©tica...")
imagen_original = data.brain()[9, :, :]

# --- PASO 2: Aplicar el filtro de detecci√≥n de bordes ---
# <<< ¬°LA L√çNEA M√ÅGICA! Este es el filtro de Sobel.
# Detecta d√≥nde hay cambios bruscos de brillo.
bordes = filters.sobel(imagen_original)

# --- PASO 3: Mostrar los resultados lado a lado ---
print("¬°Filtro de bordes aplicado! Mostrando comparaci√≥n...")
fig, axes = plt.subplots(1, 2, figsize=(12, 6))

# Imagen original
ax = axes
ax[0].imshow(imagen_original, cmap=plt.cm.gray)
ax[0].set_title("Imagen Original del Cerebro", fontsize=14)
ax[0].axis("off")

# Imagen con bordes detectados
ax[1].imshow(bordes, cmap=plt.cm.gray)
ax[1].set_title("Mapa de Contornos (Bordes)", fontsize=14)
ax[1].axis("off")

plt.tight_layout()
plt.show()
```

---

# ¬°Lo Lograron! {background-color="#006400" title-block-banner-color blue}


::: {.notes}
¬°Felicidades! T√≥mense un momento para ver lo que han logrado. No solo vieron una presentaci√≥n, sino que **hicieron** el trabajo de un ingeniero biom√©dico. Tomaron datos crudos e inutilizables ‚Äîuna se√±al ruidosa y una imagen sin detalles claros‚Äî y los transformaron en informaci√≥n clara y √∫til. ¬°Acaban de dar el primer paso en un campo que salva vidas!
:::

---

## ¬øPreguntas?

### ¬°Gracias!

::: {.notes}
Gracias por su atenci√≥n y su excelente trabajo como ingenieros. Ahora, me encantar√≠a responder a cualquier pregunta que tengan.
:::
