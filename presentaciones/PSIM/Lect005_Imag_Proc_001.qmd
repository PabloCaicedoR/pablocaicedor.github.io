---
title: "Procesado de Señales e Imágenes Médicas"
description: "ASIM_M -- 104399"
subtitle: "Ingeniería Biomédica"
lang: es
author: "Ph.D. Pablo Eduardo Caicedo Rodríguez"
date: last-modified
format:
  revealjs:
    code-tools: true
    code-overflow: wrap
    code-line-numbers: true
    code-copy: true
    fig-align: center
    self-contained: true
    theme:
      - simple
      - ../../recursos/estilos/metropolis.scss
    slide-number: true
    preview-links: auto
    logo: ../../recursos/imagenes/generales/Escuela_Rosario_logo.png
    css: ../../recursos/estilos/styles_pres.scss
    footer: <https://pablocaicedor.github.io/>
    transition: fade
    progress: true
    scrollable: true
    mainfont: "Fira Code"
resources:
  - demo.pdf
---

```{r}
#| echo: false
#| eval: true
#| output: false
#| label: Loading R-Libraries

library("DiagrammeR")
library("reticulate")
library("kableExtra")
library("tidyverse")
library("knitr")
library("cowplot")
library("ggfx")

knitr::opts_chunk$set(echo = FALSE)

def.chunk.hook <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
    x <- def.chunk.hook(x, options)
    ifelse(options$size != "normalsize", paste0("\n \\", options$size, "\n\n", x, "\n\n \\normalsize"), x)
})


data_path<-"../../data/"

```

```{python}
# | echo: false
# | eval: true
# | output: false
# | label: Loading Python-Libraries

import numpy as np
import scipy.io as sio
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import cv2
from matplotlib.patches import Rectangle

plt.rcParams.update(
    {
        "text.usetex": True,  # usar LaTeX real
        "font.family": "Fira Code",  # familia general
        "mathtext.fontset": "custom",  # fuente personalizada para fórmulas
        "mathtext.rm": "Fira Code",  # texto “roman”
        "mathtext.it": "Fira Code:italic",  # texto itálico
        "mathtext.bf": "Fira Code:bold",  # texto en negrita
        "text.latex.preamble": r"\usepackage{amsmath}",
    }
)

data_path = "../../data/"


def adjust_gamma(image, gamma=1.0):
    invGamma = 1.0 / gamma
    table = np.array(
        [((i / 255.0) ** invGamma) * 255 for i in np.arange(0, 256)]
    ).astype("uint8")

    return cv2.LUT(image, table)


def mostrarHeatMap(mat, row_labels=None, col_labels=None, fmt=".2f", title=None):
    """
    Dibuja un heatmap con anotaciones por celda (mat[i,j]).
    - mat: array 2D (numpy) con valores (puede contener NaN).
    - row_labels / col_labels: listas opcionales de etiquetas.
    - fmt: formato de número (e.g., '.2f', '.0f').
    - title: título opcional.
    """
    mat = np.asarray(mat, dtype=float)
    fig, ax = plt.subplots(figsize=(12, 10))

    im = ax.imshow(mat, aspect="auto", interpolation="nearest", cmap="gray")
    cbar = plt.colorbar(im, ax=ax)
    cbar.set_label("Valor")

    nrows, ncols = mat.shape

    # Etiquetas si se proveen
    if row_labels is not None:
        ax.set_yticks(range(nrows), labels=row_labels)
    else:
        ax.set_yticks(range(nrows))
    if col_labels is not None:
        ax.set_xticks(range(ncols), labels=col_labels)
        plt.setp(ax.get_xticklabels(), rotation=45, ha="right")
    else:
        ax.set_xticks(range(ncols))

    # Anotar cada celda
    for i in range(nrows):
        for j in range(ncols):
            val = mat[i, j]
            if np.isnan(val):
                text = ""  # no anotar NaN
            else:
                text = format(val, fmt)
            ax.text(j, i, text, ha="center", va="center", fontsize=8)

    if title:
        ax.set_title(title)

    ax.set_xlabel("Columnas")
    ax.set_ylabel("Filas")
    plt.tight_layout()
    plt.show()

def _square_bounds_from_center(r, c, size, nrows, ncols):
    """
    Devuelve (r0, r1, c0, c1) para un cuadrado centrado en (r,c) de lado `size`.
    r1 y c1 son exclusivos (estilo slicing de Python).
    Lanza ValueError si se sale de límites.
    """
    if size <= 0:
        raise ValueError("size debe ser entero positivo.")
    if not (0 <= r < nrows and 0 <= c < ncols):
        raise ValueError("Centro fuera de rango.")
    # Para tamaños pares y nones:
    half_floor = size // 2
    r0 = r - half_floor
    c0 = c - half_floor
    r1 = r0 + size
    c1 = c0 + size
    if r0 < 0 or c0 < 0 or r1 > nrows or c1 > ncols:
        raise ValueError("El cuadrado centrado excede los límites de la matriz.")
    return r0, r1, c0, c1


def heatmap_resaltado_centro(
    mat, r, c, size, cmap_base="viridis", cmap_resalte="plasma"
):
    """
    Heatmap que recolorea una subregión cuadrada centrada en (r,c) con otro colormap.
    """
    mat = np.asarray(mat, dtype=float)
    nrows, ncols = mat.shape
    r0, r1, c0, c1 = _square_bounds_from_center(r, c, size, nrows, ncols)

    fig, ax = plt.subplots(figsize=(12, 10))
    im_base = ax.imshow(mat, cmap=cmap_base, aspect="auto", interpolation="nearest")
    cbar = plt.colorbar(im_base, ax=ax)
    cbar.set_label("Valor")

    # Máscara: True = oculto, False = visible. Solo mostramos la región resaltada con otro cmap.
    mask = np.ones_like(mat, dtype=bool)
    mask[r0:r1, c0:c1] = False
    region = np.ma.masked_array(mat, mask=mask)
    ax.imshow(
        region,
        cmap=cmap_resalte,
        aspect="auto",
        interpolation="nearest",
        norm=im_base.norm,
    )

    # Marco del cuadrado
    ax.add_patch(
        Rectangle(
            (c0 - 0.5, r0 - 0.5),
            width=size,
            height=size,
            fill=False,
            edgecolor="black",
            linewidth=1.5,
        )
    )

    ax.set_xlabel("Columnas")
    ax.set_ylabel("Filas")
    ax.set_title(f"Resaltado centrado en (r={r}, c={c}), size={size}")
    plt.tight_layout()
    plt.show()


def heatmap_rectangulo_centro(mat, r, c, size, alpha=0.25, cmap="viridis"):
    """
    Heatmap con un rectángulo semitransparente centrado en (r,c), sin recolorear datos.
    """
    mat = np.asarray(mat, dtype=float)
    nrows, ncols = mat.shape
    r0, r1, c0, c1 = _square_bounds_from_center(r, c, size, nrows, ncols)

    fig, ax = plt.subplots(figsize=(6, 4))
    im = ax.imshow(mat, cmap=cmap, aspect="auto", interpolation="nearest")
    plt.colorbar(im, ax=ax).set_label("Valor")

    ax.add_patch(
        Rectangle(
            (c0 - 0.5, r0 - 0.5),
            width=size,
            height=size,
            linewidth=1.5,
            edgecolor="black",
            facecolor="white",
            alpha=alpha,
        )
    )

    ax.set_xlabel("Columnas")
    ax.set_ylabel("Filas")
    ax.set_title(f"Rectángulo centrado en (r={r}, c={c}), size={size}")
    plt.tight_layout()
    plt.show()

```

# Procesamiento de imágenes

## Basic Mathematic - Element-Wise Operation

::: {.callout-tip title="Definition" collapsible="false"}

Operation involving one or more images is carried out on a pixel-bypixel basis

:::

$$
\begin{bmatrix}
a_{11} & a_{12} \\
a_{21} & a_{22}
\end{bmatrix} \oplus \begin{bmatrix} b_{11} & b_{12} \\  b_{21} & b_{22}\end{bmatrix} = \begin{bmatrix} a_{11}+b_{11} & a_{12}+b_{12} \\  a_{21}+b_{21} & a_{22}+b_{22}\end{bmatrix} $$

$$
\begin{bmatrix}
a_{11} & a_{12} \\
a_{21} & a_{22}
\end{bmatrix} \odot \begin{bmatrix} b_{11} & b_{12} \\  b_{21} & b_{22}\end{bmatrix} = \begin{bmatrix} a_{11}.b_{11} & a_{12}.b_{12} \\  a_{21}.b_{21} & a_{22}.b_{22}\end{bmatrix} $$

## Basic Mathematic - Linear Operations{.scrollable}

::: {.callout-tip title="Definition" collapsible="false"}

Given two arbitrary constants, $\alpha_1$ and $\alpha_2$, and two arbitrary images $f_1\left(x,y\right)$ and $f_2\left(x,y\right)$, $\varkappa$ is said to be a linear operator if:

$$ \begin{equation}\begin{split} \varkappa\left[\alpha_1 f_1\left(x,y\right) + \alpha_2 f_2\left(x,y\right)\right] & =  \alpha_1 \varkappa\left[ f_1\left(x,y\right)\right] + \alpha_2 \varkappa\left[f_2\left(x,y\right)\right] \\ & = \alpha_1 g_1\left(x,y\right) + \alpha_2 g_2\left(x,y\right) \end{split}\end{equation} $$

:::

Supose $\alpha_1 = 5$, $\alpha_2 = 2$, $\varkappa = max$ and consider:

$$f_1 = \begin{bmatrix}0 & -1 \\2 & 4\end{bmatrix}$$, $$f_2 = \begin{bmatrix}30 & 4 \\-2 & -3\end{bmatrix}$$

## Basic Mathematic - Adding


 ![](../../recursos/imagenes/Presentaciones/PSIM/female-chest-x-ray.jpg){fig-align="center" height=60%}

## Basic Mathematic - Adding {.scrollable}


::: {.panel-tabset}

## Images



```{python}
#| echo: false
#| eval: true
#| output: true
#| fig-align: "center"
#| layout: [[45,-10, 45], [100]]
#| label: xray-loading

x_ray_chest = cv2.imread("../../recursos/imagenes/Presentaciones/PSIM/female-chest-x-ray.jpg")
plt.imshow(x_ray_chest, cmap="gray")
plt.show()
image_synt1 = 100*np.abs(np.random.normal(0, 1, x_ray_chest.shape))
plt.imshow(image_synt1)
plt.show()
final_image = np.uint8(x_ray_chest+image_synt1)
plt.imshow(final_image)
plt.show()

```

## Code


```{python}
#| echo: true
#| eval: false
#| output: false
#| fig-align: "center"
#| label: xray-loading-text

x_ray_chest = cv2.imread("../../recursos/imagenes/Presentaciones/PSIM/female-chest-x-ray.jpg")
plt.imshow(x_ray_chest, cmap="gray")
plt.show()
image_synt1 = 100*np.abs(np.random.normal(0, 1, x_ray_chest.shape))
plt.imshow(image_synt1)
plt.show()
final_image = np.uint8(x_ray_chest+image_synt1)
plt.imshow(final_image)
plt.show()

```

:::

## Basic Mathematic - Multiplying {.scrollable}



::: {.panel-tabset}

## Images



```{python}
#| echo: false
#| eval: true
#| output: true
#| fig-align: "center"
#| layout: [[45,-10, 45], [100]]
#| label: xray-loading-mult

x_ray_chest = cv2.imread("../../recursos/imagenes/Presentaciones/PSIM/female-chest-x-ray.jpg")
mask = np.uint8(np.zeros(x_ray_chest.shape))
mask[400:700, 250:600, :]=1
plt.imshow(x_ray_chest)
plt.show()
plt.imshow(255*mask)
plt.show()
plt.imshow(np.multiply(x_ray_chest,mask))
plt.show()

```

## Code


```{python}
#| echo: true
#| eval: false
#| output: false
#| fig-align: "center"
#| label: xray-loading-text-mult

x_ray_chest = cv2.imread("../../recursos/imagenes/Presentaciones/PSIM/female-chest-x-ray.jpg")
mask = np.uint8(np.zeros(x_ray_chest.shape))
mask[400:700, 250:600, :]=1
plt.imshow(x_ray_chest)
plt.show()
plt.imshow(255*mask)
plt.show()
plt.imshow(np.multiply(x_ray_chest,mask))
plt.show()

```

:::


## Basic Mathematic - Basic transformation

:::: {.columns}

::: {.column width="45%"}

```{python}
# | echo: false
# | eval: true
# | output: true
# | label: normalization


def plot_range_mapping_with_guides(
    old_min, old_max, new_min=0, new_max=255, title=None
):
    # Crear figura y obtener ejes actuales
    fig = plt.figure()
    ax = plt.gca()

    # Línea de mapeo y puntos extremos
    ax.plot([old_min, old_max], [new_min, new_max], linewidth=2, label="Mapeo lineal")
    ax.scatter([old_min, old_max], [new_min, new_max], s=60, zorder=3)

    # Ticks: solo min, max y nmin, nmax
    ax.set_xticks(
        [old_min, old_max], labels=[f"min={old_min:.3g}", f"max={old_max:.3g}"]
    )
    ax.set_yticks([new_min, new_max], labels=[f"nmin={new_min}", f"nmax={new_max}"])

    # Guías punteadas
    ax.axvline(old_min, linestyle="--", linewidth=1)
    ax.axvline(old_max, linestyle="--", linewidth=1)
    ax.axhline(new_min, linestyle="--", linewidth=1)
    ax.axhline(new_max, linestyle="--", linewidth=1)

    # Etiquetas y estética
    ax.set_xlabel("Rango original [min, max]")
    ax.set_ylabel("Rango nuevo [nmin, nmax]")
    if title is None:
        title = "Mapeo de extremos con guías: [min, max] → [0, 255]"
    ax.set_title(title)
    ax.legend()
    ax.grid(True, linestyle=":")
    fig.tight_layout()
    plt.show()


# Ejemplo: reemplaza 12.5 y 73.8 por tus valores reales
plot_range_mapping_with_guides(12.5, 73.8)

```

:::

::: {.column width="45%"}

::: {.x_mall}
$$x_{\text{rescaled}} = n_{\min} + \frac{(x - \min)}{\max - \min} \, (n_{\max} - n_{\min})$$
:::

:::
::::

## Basic Mathematic - Pixel intensity {.scrollable}



::: {.panel-tabset}

## Images



```{python}
#| echo: false
#| eval: true
#| output: true
#| fig-align: "center"
#| layout-ncol: 3
#| label: xray-loading-pxinten
#| fig-subcap:
#|  - "Original"
#|  - "Exp=1.1"
#|  - "Exp=1.2"
#|  - "Exp=0.2"
#|  - "Exp=0.30"
#|  - "Exp=0.5"

x_ray_chest_gray = cv2.cvtColor(x_ray_chest, cv2.COLOR_BGR2GRAY)
plt.imshow(x_ray_chest_gray, cmap="gray")
plt.show()
plt.imshow(np.power(x_ray_chest_gray,1.1), cmap="gray")
plt.show()
plt.imshow(np.power(x_ray_chest_gray,1.2), cmap="gray")
plt.show()
plt.imshow(np.power(x_ray_chest_gray,0.2), cmap="gray")
plt.show()
plt.imshow(np.power(x_ray_chest_gray,0.3), cmap="gray")
plt.show()
plt.imshow(np.power(x_ray_chest_gray,0.5), cmap="gray")
plt.show()

```

## Code


```{python}
#| echo: true
#| eval: false
#| output: false
#| fig-align: "center"
#| label: xray-loading-text-pxinten

x_ray_chest_gray = cv2.cvtColor(x_ray_chest, cv2.COLOR_BGR2GRAY)
plt.imshow(x_ray_chest_gray, cmap="gray")
plt.show()
plt.imshow(np.power(x_ray_chest_gray,1.1), cmap="gray")
plt.show()
plt.imshow(np.power(x_ray_chest_gray,1.2), cmap="gray")
plt.show()
plt.imshow(np.power(x_ray_chest_gray,0.2), cmap="gray")
plt.show()
plt.imshow(np.power(x_ray_chest_gray,0.3), cmap="gray")
plt.show()
plt.imshow(np.power(x_ray_chest_gray,0.5), cmap="gray")
plt.show()

```

:::


## Basic Mathematic - Pixel intensity {.scrollable}

![Taken from: Gonzalez, Rafael C., y Richard E. Woods. Digital Image Processing. New York, NY: Pearson, 2018.](../../recursos/imagenes/Presentaciones/PSIM/intensity_light.png)

## Basic Mathematic - Pixel intensity {.scrollable}

![Taken from: Gonzalez, Rafael C., y Richard E. Woods. Digital Image Processing. New York, NY: Pearson, 2018.](../../recursos/imagenes/Presentaciones/PSIM/intensity_light2.png)

<!-- TODO: FALTAN MAS APLICACIONES DE LA MATEMATICA BASICA -->

## Neighborhood operations

![Taken from: Gonzalez, Rafael C., y Richard E. Woods. Digital Image Processing. New York, NY: Pearson, 2018.](../../recursos/imagenes/Presentaciones/PSIM/convolution.png)

## Neighborhood operations

```{python}
# | echo: false
# | eval: true
# | output: true
# | fig-align: center
# | label: Neighborhood Concept 1

prueba1 = np.random.randint(0, 20, size=(15,15))
mostrarHeatMap(prueba1)

```

## Neighborhood operations

```{python}
# | echo: false
# | eval: true
# | output: true
# | fig-align: center
# | label: Neighborhood Concept 2

prueba1 = np.random.randint(0, 20, size=(15, 15))
heatmap_resaltado_centro(
    prueba1, r=1, c=3, size=3, cmap_base="gray", cmap_resalte="plasma"
)

```

## Neighborhood operations
![](../../recursos/imagenes/GIFs/heatmap_moving_mask.gif)

## Neighborhood Operations

:::{.small_font}

  For example, suppose that the specified operation is to compute the average value of the pixels in a rectangular neighborhood of size mn × centered on $\left(x,y\right)$. The coordinates of pixels in this region are the elements of set $S_{xy}$.

:::




::: {.panel-tabset}

## Images

::: columns

:::{.column width="45%"}

```{python}
#| echo: false
#| eval: true
#| output: true
#| label: elderly_load_nf1
#| fig-cap: "Elderly woman image"

elderly = cv2.imread("../../recursos/imagenes/Presentaciones/PSIM/elderly.jpg")
plt.imshow(elderly)

```



:::

:::{.column width="45%"}


```{python}
#| echo: false
#| eval: true
#| output: true
#| label: elderly_load_nf4
#| fig-cap: "Gray-scale image"

elderly_gray = cv2.cvtColor(elderly, cv2.COLOR_BGR2GRAY)
plt.imshow(elderly_gray, cmap="gray")

```

:::

:::

## code


```{python}
#| echo: true
#| eval: false
#| output: false
#| label: elderly_load_nf3
#| fig-cap: "Elderly woman image"
#|

elderly = cv2.imread("../../recursos/imagenes/Presentaciones/PSIM/elderly.jpg")
plt.imshow(elderly)
elderly_gray = cv2.cvtColor(elderly, cv2.COLOR_BGR2GRAY)
plt.imshow(elderly_gray, cmap="gray")

```



:::

## Neighborhood operations


::: {.panel-tabset}

## Original


```{python}
#| echo: false
#| eval: true
#| output: true
#| label: mean_filter_elderly_gray_a

plt.imshow(elderly_gray, cmap="gray")

N = 10

kernel = np.ones((N,N),np.float32)/(N*N)
dst = cv2.filter2D(elderly_gray,-1,kernel)


```
## Averaging

```{python}
#| echo: false
#| eval: true
#| output: true
#| label: mean_filter_elderly_gray_b

plt.imshow(dst, cmap="gray")
```

## Code

```{python}
#| echo: true
#| eval: false
#| output: false
#| label: mean_filter_elderly_gray_c

N = 10
kernel = np.ones((N,N),np.float32)/(N*N)
dst = cv2.filter2D(elderly_gray,-1,kernel)
plt.imshow(dst, cmap="gray")
```
:::



## Neighborhood operations


::: {.panel-tabset}

## Original


```{python}
#| echo: false
#| eval: true
#| output: true
#| label: median_filter_elderly_gray_a

plt.imshow(elderly_gray, cmap="gray")

N=11

dst1 = cv2.medianBlur(elderly_gray, N)


```
## Median

```{python}
#| echo: false
#| eval: true
#| output: true
#| label: median_filter_elderly_gray_b

plt.imshow(dst1, cmap="gray")
```

## Code

```{python}
#| echo: true
#| eval: false
#| output: false
#| label: median_filter_elderly_gray_c

N=11

dst1 = cv2.medianBlur(elderly_gray, N)
plt.imshow(dst1, cmap="gray")

```
:::

## Neighborhood operations


::: {.panel-tabset}

## Mean


```{python}
#| echo: false
#| eval: true
#| output: true
#| label: compare_Blur_filter_A

plt.imshow(dst, cmap="gray")

```
## Median

```{python}
#| echo: false
#| eval: true
#| output: true
#| label: compare_Blur_filter_B

plt.imshow(dst1, cmap="gray")
```

:::

## Mean Filter (3×3)

::: columns
::: {.column width="40%"}
**Kernel**

$$
K_{\text{mean}}=\frac{1}{9}
\begin{bmatrix}
1&1&1\\
1&1&1\\
1&1&1
\end{bmatrix}
$$
:::
::: {.column width="58%"}
**Purpose:** Basic smoothing (box filter).
**Effect:** Reduces high-frequency noise and blurs edges.
**Notes:** Linear and separable if implemented as two 1D averages; normalize by kernel sum.
:::
:::

---

## Gaussian Filter (σ≈1, 3×3)

::: columns
::: {.column width="40%"}
**Kernel**

$$
K_{\text{gauss}}=\frac{1}{16}
\begin{bmatrix}
1&2&1\\
2&4&2\\
1&2&1
\end{bmatrix}
$$
:::
::: {.column width="58%"}
**Purpose:** Weighted smoothing around the center.
**Effect:** Attenuates noise while preserving edges better than the mean filter.
**Notes:** Approximates a discrete Gaussian; often used before edge detection.
:::
:::

---

## Sobel Operator (Gradient 3×3)

::: columns
::: {.column width="40%"}
**Kernels**

$$
K_{x}=
\begin{bmatrix}
-1&0&1\\
-2&0&2\\
-1&0&1
\end{bmatrix},\quad
K_{y}=
\begin{bmatrix}
-1&-2&-1\\
0&0&0\\
1&2&1
\end{bmatrix}
$$
:::
::: {.column width="58%"}
**Purpose:** Estimate gradient along \(x\) and \(y\).
**Effect:** Highlights horizontal and vertical edges; used for magnitude \(\sqrt{(I*K_x)^2+(I*K_y)^2}\).
**Notes:** Includes implicit smoothing; more robust to noise than Prewitt.
:::
:::

---

## Prewitt Operator (Gradient 3×3)

::: columns
::: {.column width="40%"}
**Kernels**

$$
K_{x}=
\begin{bmatrix}
-1&0&1\\
-1&0&1\\
-1&0&1
\end{bmatrix},\quad
K_{y}=
\begin{bmatrix}
-1&-1&-1\\
0&0&0\\
1&1&1
\end{bmatrix}
$$
:::
::: {.column width="58%"}
**Purpose:** Estimate gradient with a simple scheme.
**Effect:** Directional edge detection.
**Notes:** Less smoothing than Sobel; computationally cheaper.
:::
:::

---

## Laplacian (2nd Derivative)

::: columns
::: {.column width="40%"}
**Kernels**

4-neighbor version:
$$
\begin{bmatrix}
0&-1&0\\
-1&4&-1\\
0&-1&0
\end{bmatrix}
$$

8-neighbor version:
$$
\begin{bmatrix}
-1&-1&-1\\
-1&8&-1\\
-1&-1&-1
\end{bmatrix}
$$
:::
::: {.column width="58%"}
**Purpose:** Enhance abrupt transitions (zero-crossings).
**Effect:** Isotropic edge detection; very sensitive to noise.
**Notes:** Often preceded by smoothing (LoG/DoG). May introduce halos.
:::
:::

---

## Sharpen Filter (3×3)

::: columns
::: {.column width="40%"}
**Kernel**

$$
K_{\text{sharpen}}=
\begin{bmatrix}
0&-1&0\\
-1&5&-1\\
0&-1&0
\end{bmatrix}
$$
:::
::: {.column width="58%"}
**Purpose:** Reinforce high-frequency components (details).
**Effect:** Produces a crisper image; enhances edges and textures.
**Notes:** Equivalent to adding the original image with a high-pass component; watch for saturation and noise.
:::
:::

---

## Roberts Cross Operator (2×2, Diagonals)

::: columns
::: {.column width="40%"}
**Kernels**

$$
K_{x}=
\begin{bmatrix}
1&0\\
0&-1
\end{bmatrix},\quad
K_{y}=
\begin{bmatrix}
0&1\\
-1&0
\end{bmatrix}
$$
:::
::: {.column width="58%"}
**Purpose:** Diagonal gradient (45°/135°).
**Effect:** Detects diagonal edges quickly.
**Notes:** Very noise-sensitive; useful in real-time or hardware systems due to small size.
:::
:::

---

## Emboss (Directional Relief)

::: columns
::: {.column width="40%"}
**Kernel**

$$
K_{\text{emboss}}=
\begin{bmatrix}
-2&-1&0\\
-1&1&1\\
0&1&2
\end{bmatrix}
$$
:::
::: {.column width="58%"}
**Purpose:** Simulate relief under oblique lighting.
**Effect:** Produces shadows and highlights (3D appearance).
**Notes:** Requires recentering/normalization to avoid brightness shift.
:::
:::


## Neighborhood operations

![Taken from: Gonzalez, Rafael C., y Richard E. Woods. Digital Image Processing. New York, NY: Pearson, 2018.](../../recursos/imagenes/Presentaciones/PSIM/spatial_trasnformation.png)

## Neighborhood operations

![Taken from: http://datagenetics.com/blog/august32013/index.html](../../recursos/imagenes/Presentaciones/PSIM/spatial_aliasing.png)


## Edge dection{.scrollable}

```{python}
#| echo: false
#| eval: true
#| output: true
#| label: edge detector
dst = cv2.Canny(elderly_gray, 100, 200)
plt.imshow(dst, cmap="gray")

```

## Edge dection{.scrollable}


![](../../recursos/imagenes/Presentaciones/PSIM/Bordes.png){fig-align="center"}


## Edge dection{.scrollable}


::: {.panel-tabset}

## Images Grad Y

```{python}
#| echo: false
#| eval: true
#| output: true
#| label: sobel detector Y
dst = cv2.Sobel(elderly_gray, cv2.CV_16S, 0, 1,  ksize=3, scale=1, delta=0, borderType= cv2.BORDER_DEFAULT)
dst1 = np.uint8(255*dst/np.max(dst))
plt.imshow(dst, cmap="gray")

```

## Images Grad X

```{python}
#| echo: false
#| eval: true
#| output: true
#| label: sobel detector X
dst = cv2.Sobel(elderly_gray, cv2.CV_16S, 1, 0,  ksize=3, scale=1, delta=0, borderType= cv2.BORDER_DEFAULT)
dst1 = np.uint8(255*dst/np.max(dst))
plt.imshow(dst, cmap="gray")

```

## Images Grad Trunc Y

```{python}
#| echo: false
#| eval: true
#| output: true
#| label: sobel detector Y Trunc
dst = cv2.Sobel(elderly_gray, cv2.CV_16S, 0, 1,  ksize=3, scale=1, delta=0, borderType= cv2.BORDER_DEFAULT)
dst1 = np.uint8(255*dst/np.max(dst))
plt.imshow(dst1, cmap="gray")

```

## Images Trunc Grad X

```{python}
#| echo: false
#| eval: true
#| output: true
#| label: sobel detector X Trunc
dst = cv2.Sobel(elderly_gray, cv2.CV_16S, 1, 0,  ksize=3, scale=1, delta=0, borderType= cv2.BORDER_DEFAULT)
dst1 = np.uint8(255*dst/np.max(dst))
plt.imshow(dst1, cmap="gray")

```

## Code

```{python}
#| echo: true
#| eval: false
#| output: false
#| label: sobel detector code
dst = cv2.Sobel(elderly_gray, cv2.CV_16S, 1, 0,  ksize=3, scale=1, delta=0, borderType= cv2.BORDER_DEFAULT)
dst1 = np.uint8(255*dst/np.max(dst))
plt.imshow(dst1, cmap="gray")

```


:::

## Histogram


::: {.panel-tabset}

## Histogram

```{python}
#| echo: false
#| eval: true
#| output: true
#| label: Histogram

elderly_hist = cv2.calcHist(elderly_gray, [0], None, [256], [0,256])
plt.plot(elderly_hist, color="gray")

```

## Code

```{python}
#| echo: true
#| eval: false
#| output: false
#| label: Histogram Code

elderly_hist = cv2.calcHist(elderly_gray, [0], None, [256], [0,256])
plt.plot(elderly_hist, color="gray")

```



:::

## Histogram


::: {.panel-tabset}

## First thing to do

+---+---+---+---+---+---+---+---+---+---+
| 3 | 3 | 2 | 2 | 1 | 1 | 0 | 3 | 0 | 1 |
+---+---+---+---+---+---+---+---+---+---+
| 2 | 2 | 2 | 3 | 2 | 2 | 0 | 2 | 2 | 1 |
+---+---+---+---+---+---+---+---+---+---+
| 0 | 3 | 2 | 0 | 1 | 1 | 3 | 1 | 1 | 1 |
+---+---+---+---+---+---+---+---+---+---+
| 3 | 0 | 2 | 0 | 2 | 3 | 1 | 0 | 2 | 1 |
+---+---+---+---+---+---+---+---+---+---+
| 2 | 2 | 0 | 0 | 3 | 1 | 3 | 1 | 3 | 1 |
+---+---+---+---+---+---+---+---+---+---+
| 3 | 3 | 2 | 0 | 3 | 0 | 3 | 2 | 0 | 3 |
+---+---+---+---+---+---+---+---+---+---+
| 3 | 3 | 1 | 1 | 2 | 3 | 0 | 3 | 1 | 3 |
+---+---+---+---+---+---+---+---+---+---+
| 3 | 1 | 3 | 3 | 2 | 0 | 3 | 0 | 2 | 1 |
+---+---+---+---+---+---+---+---+---+---+
| 2 | 1 | 1 | 3 | 3 | 1 | 3 | 2 | 2 | 1 |
+---+---+---+---+---+---+---+---+---+---+
| 0 | 3 | 2 | 2 | 1 | 1 | 0 | 0 | 0 | 0 |
+---+---+---+---+---+---+---+---+---+---+




## Image


```{python}
#| echo: false
#| eval: true
#| output: true
#| label: histogram-base
#| layout-ncol: 2

elderly = cv2.imread("../../recursos/imagenes/Presentaciones/PSIM/elderly.jpg")
elderly_gray = cv2.cvtColor(elderly, cv2.COLOR_BGR2GRAY)
plt.imshow(elderly_gray, cmap="gray", vmin=0, vmax=255)
plt.show()


elderly_hist = cv2.calcHist(elderly_gray, [0], None, [256], [0,256])
plt.plot(elderly_hist, color="red")
plt.show()

```

## Code


```{python}
#| echo: true
#| eval: false
#| output: false
#| label: histogram-base-code

elderly = cv2.imread("../../recursos/imagenes/Presentaciones/PSIM/elderly.jpg")
elderly_gray = cv2.cvtColor(elderly, cv2.COLOR_BGR2GRAY)
plt.imshow(elderly_gray, cmap="gray", vmin=0, vmax=255)
plt.show()


elderly_hist = cv2.calcHist(elderly_gray, [0], None, [256], [0,256])
plt.plot(elderly_hist, color="red")
plt.show()

```

## Recommended Reading

cv2.calcHist(images, channels, mask, histSize, ranges)

[Help Docs Opencv](https://docs.opencv.org/3.4/d6/dc7/group__imgproc__hist.html#ga4b2b5fd75503ff9e6844cc4dcdaed35d)

:::

## Histogram{.scrollable}


::: {.panel-tabset}

## Images

```{python}
#| echo: false
#| eval: true
#| output: true
#| label: histogram
#| layout-ncol: 2

elderly = cv2.imread("../../recursos/imagenes/Presentaciones/PSIM/elderly.jpg")
elderly_gray = cv2.cvtColor(elderly, cv2.COLOR_BGR2GRAY)
plt.imshow(elderly_gray, cmap="gray", vmin=0, vmax=255)
plt.show()
elderly_hist = cv2.calcHist(elderly_gray, [0], None, [256], [0,256])
plt.plot(elderly_hist, color="red")
plt.show()
elderly_gray_light = adjust_gamma(image=elderly_gray, gamma=2)
plt.imshow(elderly_gray_light, cmap="gray", vmin=0, vmax=255)
plt.show()
elderly_hist_light = cv2.calcHist(elderly_gray_light, [0], None, [256], [0,256])
plt.plot(elderly_hist_light, color="red")
plt.show()
elderly_gray_dark = adjust_gamma(image=elderly_gray, gamma=0.3)
plt.imshow(elderly_gray_dark, cmap="gray", vmin=0, vmax=255)
plt.show()
elderly_hist_dark = cv2.calcHist(elderly_gray_dark, [0], None, [256], [0,256])
plt.plot(elderly_hist_dark, color="red")
plt.show()
elderly_gray_lowcontrast=np.uint8(0.1*elderly_gray)+172
plt.imshow(elderly_gray_lowcontrast, cmap="gray", vmin=0, vmax=255)
plt.show()
elderly_hist_lowcontrast = cv2.calcHist(elderly_gray_lowcontrast, [0], None, [256], [0,256])
plt.plot(elderly_hist_lowcontrast, color="red")
plt.show()
```

## Code
```{python}
#| echo: true
#| eval: false
#| output: false
#| label: histogram-code

def adjust_gamma(image, gamma=1.0):
   invGamma = 1.0 / gamma
   table = np.array([((i / 255.0) ** invGamma) * 255
      for i in np.arange(0, 256)]).astype("uint8")

   return cv2.LUT(image, table)

elderly = cv2.imread("../../recursos/imagenes/Presentaciones/PSIM/elderly.jpg")
elderly_gray = cv2.cvtColor(elderly, cv2.COLOR_BGR2GRAY)
plt.imshow(elderly_gray, cmap="gray", vmin=0, vmax=255)
plt.show()
elderly_hist = cv2.calcHist(elderly_gray, [0], None, [256], [0,256])
plt.plot(elderly_hist, color="red")
plt.show()
elderly_gray_light = adjust_gamma(image=elderly_gray, gamma=2)
plt.imshow(elderly_gray_light, cmap="gray", vmin=0, vmax=255)
plt.show()
elderly_hist_light = cv2.calcHist(elderly_gray_light, [0], None, [256], [0,256])
plt.plot(elderly_hist_light, color="red")
plt.show()
elderly_gray_dark = adjust_gamma(image=elderly_gray, gamma=0.3)
plt.imshow(elderly_gray_dark, cmap="gray", vmin=0, vmax=255)
plt.show()
elderly_hist_dark = cv2.calcHist(elderly_gray_dark, [0], None, [256], [0,256])
plt.plot(elderly_hist_dark, color="red")
plt.show()
elderly_gray_lowcontrast=np.uint8(0.1*elderly_gray)+172
plt.imshow(elderly_gray_lowcontrast, cmap="gray", vmin=0, vmax=255)
plt.show()
elderly_hist_lowcontrast = cv2.calcHist(elderly_gray_lowcontrast, [0], None, [256], [0,256])
plt.plot(elderly_hist_lowcontrast, color="red")
plt.show()
```

:::

## Histogram Equalization

::: {.callout-note title="Algorithm"}

1. Calculate Histogram: Calculate the histogram of the original image, showing the frequency distribution of each intensity level.
2. Calculate Cumulative Distribution Function (CDF): Calculate the cumulative distribution function (CDF) of the histogram. The CDF represents the cumulative sum of frequencies for each intensity level.
3. Equalization: For each pixel in the original image, calculate the new intensity value using the formula:
$$New_value = (CDF(old value) * (L-1))$$
where L is the number of intensity levels (e.g., 256 for an 8-bit image).
4. Assign New Values: Assign the new intensity values calculated in step 3 to the equalized image.

:::


## Histogram Equalization


::: {.panel-tabset}

## Images

```{python}
#| echo: false
#| eval: true
#| output: true
#| label: histogram-equalization
#| layout-ncol: 2

plt.imshow(elderly_gray_lowcontrast, cmap="gray", vmin=0, vmax=255)
plt.show()

plt.plot(elderly_hist_lowcontrast, color="red")
plt.show()

elderly_hist_equ = cv2.equalizeHist(elderly_gray_lowcontrast)
plt.imshow(elderly_hist_equ, cmap="gray", vmin=0, vmax=255)
plt.show()

elderly_hist_equ = cv2.calcHist(elderly_hist_equ, [0], None, [256], [0,256])
plt.plot(elderly_hist_equ, color="red")
plt.show()

```

## Code

```{python}
#| echo: true
#| eval: false
#| output: false
#| label: histogram-equalization-code

plt.imshow(elderly_gray_lowcontrast, cmap="gray", vmin=0, vmax=255)
plt.show()

plt.plot(elderly_hist_lowcontrast, color="red")
plt.show()

elderly_hist_equ = cv2.equalizeHist(elderly_gray_lowcontrast)
plt.imshow(elderly_hist_equ, cmap="gray", vmin=0, vmax=255)
plt.show()

elderly_hist_equ = cv2.calcHist(elderly_hist_equ, [0], None, [256], [0,256])
plt.plot(elderly_hist_equ, color="red")
plt.show()

```

## Recommended Reading

[Histogram Equalization OPENCV tutorial](https://docs.opencv.org/4.x/d5/daf/tutorial_py_histogram_equalization.html)

:::

## Histogram Matching


:::{.panel-tabset}

## Explain

![Taken from [PyImageSearch](https://pyimagesearch.com/2021/02/08/histogram-matching-with-opencv-scikit-image-and-python/)](../../recursos/imagenes/Presentaciones/PSIM/opencv_histogram_matching_cdf.png)

## Algorithm

**Step 1: Calculate Histogram**s
Compute the histograms of the source image (Hs) and target image (Ht) for intensity values (r).

**Step 2: Calculate CDF**s
Compute the cumulative distribution functions (CDFs) for the source image (CDFs) and target image (CDFt).

**Step 3: Establish Correspondenc**e
Find the corresponding intensity values between the source and target images using the inverse CDF of the target image.

**Step 4: Apply Transformatio**n
Apply the intensity transformation to the source image using the established correspondence.

**Step 5: Verify Similarity**
Calculate the mean absolute difference between the transformed source image and the target image to verify their similarity.

## Result

```{python}
#| echo: false
#| eval: true
#| output: true
#| label: Histogram Matching

# Cargar la imagen fuente y objetivo
plt.imshow(np.concatenate((elderly_gray, elderly_gray_lowcontrast), axis=1))
plt.show()

# Calcula los histogramas
hist_s = cv2.calcHist([elderly_gray_lowcontrast], [0], None, [256], [0, 256])
hist_t = cv2.calcHist([elderly_gray], [0], None, [256], [0, 256])

# Calcula las CDF
cdf_s = np.cumsum(hist_s)
cdf_t = np.cumsum(hist_t)

# Establece la correspondencia
r_t = np.interp(cdf_s, cdf_t, np.arange(256))

# Aplica la transformación
img_t_match = cv2.LUT(elderly_gray_lowcontrast, r_t)
plt.imshow(img_t_match)
plt.axis("off")
plt.show()

# Verifica la similitud
diff = np.mean(np.abs(img_t_match - elderly_gray))

print(f'Diferencia media absoluta: {diff}')

```

## Code

```{python}
#| echo: true
#| eval: false
#| output: false
#| label: Histogram Matching Code

# Cargar la imagen fuente y objetivo
img_s = cv2.imread('imagen_fuente.jpg')
img_t = cv2.imread('imagen_objetivo.jpg')

# Calcula los histogramas
hist_s = cv2.calcHist([img_s], [0], None, [256], [0, 256])
hist_t = cv2.calcHist([img_t], [0], None, [256], [0, 256])

# Calcula las CDF
cdf_s = np.cumsum(hist_s)
cdf_t = np.cumsum(hist_t)

# Establece la correspondencia
r_t = np.interp(cdf_s, cdf_t, np.arange(256))

# Aplica la transformación
img_t_match = cv2.LUT(img_s, r_t)

# Verifica la similitud
diff = np.mean(np.abs(img_t_match - img_t))

print(f'Diferencia media absoluta: {diff}')

```

:::

