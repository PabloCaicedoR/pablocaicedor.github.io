---
title: "Procesado de Señales e Imágenes Médicas"
description: "ASIM_M -- 104399"
subtitle: "Ingeniería Biomédica"
lang: es
author: "Ph.D. Pablo Eduardo Caicedo Rodríguez"
date: "2024-08-12"
format:
  revealjs: 
    code-tools: true
    code-overflow: wrap
    code-line-numbers: true
    code-copy: true
    fig-align: center
    self-contained: true
    theme: 
      - simple
      - ../../recursos/estilos/metropolis.scss
    slide-number: true
    preview-links: auto
    logo: ../../recursos/imagenes/generales/Escuela_Rosario_logo.png
    css: ../../recursos/estilos/styles_pres.scss
    footer: <https://pablocaicedor.github.io/>
    transition: fade
    progress: true
    scrollable: true
resources:
  - demo.pdf
---

```{r}
#| echo: false
#| eval: true
#| output: false
#| label: Loading R-Libraries

library("DiagrammeR")
library("reticulate")
library("kableExtra")
library("tidyverse")
library("knitr")
library("cowplot")
library("ggfx")

use_python("/usr/bin/python3.12")

knitr::opts_chunk$set(echo = FALSE)

def.chunk.hook <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
    x <- def.chunk.hook(x, options)
    ifelse(options$size != "normalsize", paste0("\n \\", options$size, "\n\n", x, "\n\n \\normalsize"), x)
})


data_path<-"../../data/"

```

```{python}
#| echo: false
#| eval: true
#| output: false
#| label: Loading Python-Libraries

import numpy as np
import scipy.io as sio
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import cv2
import pywt

data_path="../../data/"

import numpy as np
import cv2
import matplotlib.pyplot as plt

def adjust_gamma(image, gamma=1.0):
   invGamma = 1.0 / gamma
   table = np.array([((i / 255.0) ** invGamma) * 255
      for i in np.arange(0, 256)]).astype("uint8")

   return cv2.LUT(image, table)


# Dibujar un círculo blanco en el centro
image_circle = np.zeros((200, 200), dtype=np.uint8)
cv2.circle(image_circle, (100, 100), 50, (255), -1)


image_gradient = np.linspace(0, 255, 200, dtype=np.uint8)
image_gradient = np.tile(image_gradient, (200, 1))
cv2.circle(image_gradient, (100, 100), 50, (255), -1)

noise = np.random.randint(0, 256, (200, 200), dtype=np.uint8)
noisy_circle = cv2.addWeighted(image_circle, 0.5, noise, 0.5, 0)

```

# Introduction to Wavelet Transform

## Introduction

- It's a mathematical tool for signal decomposition, like Fourier's Transform.
- Just as the Fourier transform decomposes a signal into a series of sine and cosine functions, the wavelet transform does so using a set of functions known as wavelets.
- Wavelets are functions generated by scaling and shifting a base function known as the mother wavelet.

## Introduction

```{python}
#| echo: false
#| eval: true
#| output: true
#| label: wavelet basis 01

# Definir la wavelet madre Morlet
def morlet_wavelet(t, f=1.0):
    """
    Genera una wavelet madre Morlet.
    t: Tiempo.
    f: Frecuencia de la wavelet.
    """
    return np.cos(2 * np.pi * f * t) * np.exp(-t**2 / 2)

# Generar una serie temporal
t = np.linspace(-2, 2, 1000)

# Wavelet madre
wavelet_madre = morlet_wavelet(t)

# Escalamiento (cambiamos la frecuencia para modificar la escala)
wavelet_escalada = morlet_wavelet(t, f=0.5)  # Escala más ancha (frecuencia más baja)

# Desplazamiento (movemos la wavelet en el tiempo)
desplazamiento = 1.0  # Tiempo de desplazamiento
wavelet_desplazada = morlet_wavelet(t - desplazamiento)

# Graficar
plt.figure(figsize=(12, 8))

# Subplot para la wavelet madre
plt.subplot(3, 1, 1)
plt.plot(t, wavelet_madre)
plt.title('Mother Wavelet')
plt.xlabel('Time')
plt.ylabel('Amplitude')

# Subplot para la wavelet escalada
plt.subplot(3, 1, 2)
plt.plot(t, wavelet_escalada, color='orange')
plt.title('Scaled Wavelet')
plt.xlabel('Time')
plt.ylabel('Amplitude')

# Subplot para la wavelet desplazada
plt.subplot(3, 1, 3)
plt.plot(t, wavelet_desplazada, color='green')
plt.title('Shift Wavelet')
plt.xlabel('Time')
plt.ylabel('Amplitude')

plt.tight_layout()
plt.show()

```

## Introduction

- **Morlet:** Popular for time-frequency analysis in EEG and ECG.
- **Mexican Hat (Ricker):** Often used in spike detection in neural signals.
- **Haar**: Useful in quick decomposition of signals and feature extraction.
- **Daubechies**: Frequently used in ECG signal denoising and compression.
- **Symlet:** Another option for signal processing and feature extraction in EEG.
- **Coiflet:** Useful for denoising and baseline correction in biomedical signals.

## Introduction

::: {.panel-tabset}

## Conditions

- Have a mean of zero (to capture details in the signal).
- Be square integrable (finite energy).
- Satisfy the admissibility condition on its Fourier transform.
- Be oscillatory to capture frequency information.
- (Optionally) have compact support for efficient computation and localization.

## Zero Mean (Admissibility Condition)

The function must have an average value of zero. Mathematically, this is expressed as:

$$\int_{-\infty}^{\infty} \psi(t) \, dt = 0$$

This condition ensures that the wavelet can detect changes or "details" in the signal rather than its average or constant components.

## Square Integrability

The function $\psi(t)$  must be square integrable, meaning it has finite energy:

$$\int_{-\infty}^{\infty} |\psi(t)|^2 \, dt < \infty$$

:::