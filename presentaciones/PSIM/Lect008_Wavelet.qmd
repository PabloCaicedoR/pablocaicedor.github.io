---
title: "Procesado de Señales e Imágenes Médicas"
description: "ASIM_M -- 104399"
subtitle: "Ingeniería Biomédica"
lang: es
author: "Ph.D. Pablo Eduardo Caicedo Rodríguez"
date: "2024-08-12"
format:
  revealjs: 
    code-tools: true
    code-overflow: wrap
    code-line-numbers: true
    code-copy: true
    fig-align: center
    self-contained: true
    theme: 
      - simple
      - ../../recursos/estilos/metropolis.scss
    slide-number: true
    preview-links: auto
    logo: ../../recursos/imagenes/generales/Escuela_Rosario_logo.png
    css: ../../recursos/estilos/styles_pres.scss
    footer: <https://pablocaicedor.github.io/>
    transition: fade
    progress: true
    scrollable: true
resources:
  - demo.pdf
---

```{r}
#| echo: false
#| eval: true
#| output: false
#| label: Loading R-Libraries

library("DiagrammeR")
library("reticulate")
library("kableExtra")
library("tidyverse")
library("knitr")
library("cowplot")
library("ggfx")

use_python("/usr/bin/python3.12")

knitr::opts_chunk$set(echo = FALSE)

def.chunk.hook <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
    x <- def.chunk.hook(x, options)
    ifelse(options$size != "normalsize", paste0("\n \\", options$size, "\n\n", x, "\n\n \\normalsize"), x)
})


data_path<-"../../data/"

```

```{python}
#| echo: false
#| eval: true
#| output: false
#| label: Loading Python-Libraries

import numpy as np
import scipy.io as sio
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import cv2
import pywt

data_path="../../data/"

import numpy as np
import cv2
import matplotlib.pyplot as plt

def adjust_gamma(image, gamma=1.0):
   invGamma = 1.0 / gamma
   table = np.array([((i / 255.0) ** invGamma) * 255
      for i in np.arange(0, 256)]).astype("uint8")

   return cv2.LUT(image, table)


# Dibujar un círculo blanco en el centro
image_circle = np.zeros((200, 200), dtype=np.uint8)
cv2.circle(image_circle, (100, 100), 50, (255), -1)


image_gradient = np.linspace(0, 255, 200, dtype=np.uint8)
image_gradient = np.tile(image_gradient, (200, 1))
cv2.circle(image_gradient, (100, 100), 50, (255), -1)

noise = np.random.randint(0, 256, (200, 200), dtype=np.uint8)
noisy_circle = cv2.addWeighted(image_circle, 0.5, noise, 0.5, 0)

```

# Introduction to Wavelet Transform

## Introduction
```{python}
#| echo: false
#| eval: true
#| output: true
#| label: Entry Concepts

# Configuración del vector
vx, vy = 4, 3  # Componentes del vector

# Crear la figura y los ejes
fig, ax = plt.subplots()

# Dibujar los ejes
ax.axhline(0, color="black", linewidth=0.5)
ax.axvline(0, color="black", linewidth=0.5)

# Dibujar el vector
ax.quiver(
    0,
    0,
    vx,
    vy,
    angles="xy",
    scale_units="xy",
    scale=1,
    color="blue",
)

# Dibujar el vector con estilo de línea punteada
ax.plot([0, vx], [0, 0], "k--")  # Línea punteada para el vector
ax.plot(vx, 0, "ko")  # Punto en el extremo del vector
ax.plot([0, 0], [0, vy], "k--")  # Línea punteada para el vector
ax.plot(0, vy, "ko")  # Punto en el extremo del vector

# Dibujar las proyecciones en los ejes
ax.plot([vx, vx], [0, vy], "r:")
ax.plot([0, vx], [vy, vy], "g:")

# Etiquetas para las proyecciones
ax.text(vx, -0.1, r"$X_1$", ha="center", va="top")
ax.text(-0.1, vy, r"$Y_1$", ha="right", va="center")
ax.text(vx, vy, r"$(X_1, Y_1)$", ha="left", va="bottom")
ax.text(-0.3, -0.3, "O", ha="center", va="center")

# Configurar los límites de la gráfica
ax.set_xlim(-1, vx + 2)
ax.set_ylim(-1, vy + 2)

# Añadir etiquetas y leyendas
ax.set_xlabel("x")
ax.set_ylabel("y")
ax.legend()

# Configurar la cuadrícula
ax.grid(True)
ax.set_aspect("equal")

```

## Introduction

- It's a mathematical tool for signal decomposition, like Fourier's Transform.
- Just as the Fourier transform decomposes a signal into a series of sine and cosine functions, the wavelet transform does so using a set of functions known as wavelets.
- Wavelets are functions generated by scaling and shifting a base function known as the mother wavelet.

## Introduction

```{python}
#| echo: false
#| eval: true
#| output: true
#| label: wavelet basis 01

# Definir la wavelet madre Morlet
def morlet_wavelet(t, f=1.0):
    """
    Genera una wavelet madre Morlet.
    t: Tiempo.
    f: Frecuencia de la wavelet.
    """
    return np.cos(2 * np.pi * f * t) * np.exp(-t**2 / 2)

# Generar una serie temporal
t = np.linspace(-2, 2, 1000)

# Wavelet madre
wavelet_madre = morlet_wavelet(t)

# Escalamiento (cambiamos la frecuencia para modificar la escala)
wavelet_escalada = morlet_wavelet(t, f=0.5)  # Escala más ancha (frecuencia más baja)

# Desplazamiento (movemos la wavelet en el tiempo)
desplazamiento = 1.0  # Tiempo de desplazamiento
wavelet_desplazada = morlet_wavelet(t - desplazamiento)

# Graficar
plt.figure(figsize=(12, 8))

# Subplot para la wavelet madre
plt.subplot(3, 1, 1)
plt.plot(t, wavelet_madre)
plt.title('Mother Wavelet')
plt.xlabel('Time')
plt.ylabel('Amplitude')

# Subplot para la wavelet escalada
plt.subplot(3, 1, 2)
plt.plot(t, wavelet_escalada, color='orange')
plt.title('Scaled Wavelet')
plt.xlabel('Time')
plt.ylabel('Amplitude')

# Subplot para la wavelet desplazada
plt.subplot(3, 1, 3)
plt.plot(t, wavelet_desplazada, color='green')
plt.title('Shift Wavelet')
plt.xlabel('Time')
plt.ylabel('Amplitude')

plt.tight_layout()
plt.show()

```

## Introduction

- **Morlet:** Popular for time-frequency analysis in EEG and ECG.
- **Mexican Hat (Ricker):** Often used in spike detection in neural signals.
- **Haar**: Useful in quick decomposition of signals and feature extraction.
- **Daubechies**: Frequently used in ECG signal denoising and compression.
- **Symlet:** Another option for signal processing and feature extraction in EEG.
- **Coiflet:** Useful for denoising and baseline correction in biomedical signals.

## Introduction

::: {.panel-tabset}

## Conditions

- Have a mean of zero (to capture details in the signal).
- Be square integrable (finite energy).
- Satisfy the admissibility condition on its Fourier transform.
- Be oscillatory to capture frequency information.
- (Optionally) have compact support for efficient computation and localization.

## I 
::: {.callout-important title="Zero Mean (Admissibility Condition)"}
The function must have an average value of zero. Mathematically, this is expressed as:

$$\int_{-\infty}^{\infty} \psi(t) \, dt = 0$$

This condition ensures that the wavelet can detect changes or "details" in the signal rather than its average or constant components.
:::

## II

::: {.callout-important title="Square Integrability"}
The function $\psi(t)$  must be square integrable, meaning it has finite energy:

$$\int_{-\infty}^{\infty} |\psi(t)|^2 \, dt < \infty$$

This requirement ensures that the wavelet’s energy is finite, making it possible to localize the function in both time and frequency domains. Functions that satisfy this belong to the $L^2(\rm I\!R)$ space, which is the space of all functions with finite energy.
:::

## III

::: {.callout-important title="Admissibility Constant"}
The wavelet's Fourier transform, $\hat{\psi}(\omega)$, should satisfy the admissibility condition:

$$C_\psi = \int_{-\infty}^{\infty} \frac{|\hat{\psi}(\omega)|^2}{|\omega|} \, d\omega < \infty$$

where $\hat{\psi}(\omega)$ is the Fourier transform of $\psi(t)$, and $\omega$ represents angular frequency. This condition implies that $\hat{\psi}(\omega)$ must approach zero as $\omega \rightarrow 0$ meaning the wavelet has no component at zero frequency (or DC component). This condition is crucial for ensuring that the wavelet transform is invertible.
:::

## IV

::: {.callout-important title="Oscillatory Nature"}
A mother wavelet should generally be oscillatory or "wavelike" (hence the term "wavelet"). This oscillatory behavior allows the wavelet to capture variations in the signal. For example, wavelets like the Morlet wavelet resemble decaying sinusoids. This oscillatory nature helps the wavelet capture both high-frequency and low-frequency components effectively.
:::

## V
::: {.callout-important title="Compact Support"}
Although not strictly necessary, compact support is often a desirable property. Compact support means that the function is non-zero only over a finite interval, making it well-localized in time. This allows for efficient computation and good localization in the time domain. For example, the Haar wavelet has compact support, while others, like the Morlet wavelet, do not have strict compact support but still decay rapidly.
:::


:::

## A wavelet transformation

```{python}
#| echo: false
#| eval: true
#| output: true
#| fig-align: center
#| label: Time Feature Detection

import numpy as np
import pywt
import matplotlib.pyplot as plt

# Generate a synthetic signal with features
np.random.seed(0)
t = np.linspace(0, 1, 500)
signal = np.sin(2 * np.pi * 5 * t)  # Base signal (5 Hz)
signal[100:120] += 2  # Add a spike (feature at t=0.2)
signal[300:320] -= 1.5  # Add another feature (t=0.6)

# Perform wavelet decomposition (using Daubechies 4 wavelet)
wavelet = "db4"
max_level = 5  # Maximum decomposition level
coeffs = pywt.wavedec(signal, wavelet, level=max_level)

# Plot the original signal with features
plt.figure(figsize=(10, 6))
plt.subplot(3, 1, 1)
plt.plot(t, signal, label="Original Signal with Features", color="black")
plt.title("Original Signal")
plt.xlim(0, 1)
plt.xlabel("Time")
plt.ylabel("Amplitude")
plt.legend()

# Plot the wavelet transform coefficients at different levels
for i in range(1, max_level + 1):
    plt.subplot(3, 2, i + 1)
    # Plot detail coefficients for the current level
    # Zero out other levels to highlight the current level's detail coefficients
    coeffs_temp = [
        coeffs[0] if j == 0 else np.zeros_like(coeff) for j, coeff in enumerate(coeffs)
    ]
    coeffs_temp[i] = coeffs[i]  # Keep the detail coefficients for level i

    # Reconstruct the signal using only the current level's details
    feature_detection = pywt.waverec(coeffs_temp, wavelet)
    plt.plot(
        t,
        feature_detection[: len(signal)],
        label=f"Level {i} Feature Detection",
        color="red",
    )
    plt.title(f"Detected Features - Level {i}")
    plt.xlim(0, 1)
    plt.xlabel("Time")
    plt.ylabel("Amplitude")
    plt.legend()

plt.tight_layout()
plt.show()

```

## A wavelet transformation

![](../../recursos/videos/wavelet_transform01t.gif)

## Mathematical Expressions

The continuous wavelet transform of a signal $f(t)$ is defined as:

$$W_f(a, b) = \int_{-\infty}^{\infty} f(t) \, \psi^*\left(\frac{t - b}{a}\right) \, dt$$

where:

- $f(t)$ is the input signal,
- $\psi$ is the mother wavelet,
- $a$ is the scale parameter (controls the width of the wavelet),
- $b$ is the translation parameter (controls the position of the wavelet),
- $\psi^*$  denotes the complex conjugate of the mother wavelet.
## Mathematical Expressions

The continuous wavelet transform of a signal $f(t)$ is defined as:

$$W_f(a, b) = \int_{-\infty}^{\infty} f(t) \, \psi^*\left(\frac{t - b}{a}\right) \, dt$$

where:

- $f(t)$ is the input signal,
- $\psi$ is the mother wavelet,
- $a$ is the scale parameter (controls the width of the wavelet),
- $b$ is the translation parameter (controls the position of the wavelet),
- $\psi^*$  denotes the complex conjugate of the mother wavelet.

## Mathematical Expressions

The inverse continuous wavelet transform is given by:

$$f(t) = \frac{1}{C_{\psi}} \int_{0}^{\infty} \int_{-\infty}^{\infty} W_f(a, b) \, \psi\left(\frac{t - b}{a}\right) \frac{db \, da}{a^2}$$

where:

where $C_{\psi}$ is a normalization constant, defined as:

$$C_{\psi} = \int_{0}^{\infty} \frac{|\hat{\psi}(\omega)|^2}{\omega} \, d\omega$$

and $\hat{\psi}(\omega)$  is the Fourier transform of the wavelet $\psi(t)$.

## Mathematical Expressions

The discrete wavelet transform decomposes the signal at discrete levels of scale. For a signal $x[n]$, the wavelet decomposition is defined as:

$$c_{j, k} = \sum_{n} x[n] \, \psi_{j, k}(n)$$

where:

- $\psi_{j, k}(n)= \frac{1}{\sqrt{2}}\psi\left(\frac{n-2^{j}k}{2^{j}}\right)$ represents the scaled and translated versions of the mother wavelet $\psi$ 
- $j$ is the scale index, and $k$ is the translation index.

The decomposition typically consists of approximation and detail coefficients at each scale:

Approximation coefficients $a_j$: capture the low-frequency components.
Detail coefficients $d_j$ capture the high-frequency components.

## Mathematical Expressions

The inverse discrete wavelet transform reconstructs the original signal from its approximation and detail coefficients:
$$x[n] = \sum_{j} \sum_{k} c_{j, k} \, \psi_{j, k}(n)$$

This reconstruction process involves upsampling and filtering of the approximation and detail coefficients at each scale.

## Using CWT

- **Purpose:** The CWT is used when you need a highly detailed, continuous analysis of a signal over all possible scales and positions.
- **Output:** CWT gives you a "heatmap" of wavelet coefficients, showing which frequencies (or scales) are present in the signal at each point in time. This allows for a continuous representation.
- **Applications:** CWT is useful for analyzing signals where you want to see the evolution of frequencies over time, such as:
  - Detecting subtle changes in frequencies over time (like brainwave analysis in EEG).
  - Signals with non-repeating, transient features (like spikes in biomedical signals, e.g., ECG).
- **Trade-Off:** CWT is more computationally expensive because it analyzes all scales and translations continuously. It gives lots of data but is slower and requires more memory.

::: {.callout-important title="Use CWT when:"}
- You need a detailed, continuous representation.
- You want to detect subtle or fast-changing features across time.
- You’re okay with higher computational costs to get very fine-grained analysis.
:::

## Using DWT

- **Purpose:** The DWT is used when you want a compact, efficient representation of a signal, usually for compression or feature extraction. It analyzes only specific scales (powers of two), not continuously.
- **Output:** DWT gives you a set of coefficients at each level (or scale), capturing information at that specific scale. It’s efficient and uses fewer data points.
- **Applications:** DWT is ideal when you want to reduce the size of data or focus on a smaller set of frequencies, such as:
  - Image and audio compression (like JPEG 2000 or MP3 formats).
  - Feature extraction for machine learning (e.g., identifying specific patterns).
  - De-noising signals by discarding certain scales that contain noise.
- **Trade-Off:** DWT is computationally cheaper but less detailed than CWT. It doesn’t give a continuous heatmap but rather a discrete set of scales.

::: {.callout-important title="Use DWT when:"}
- You need a compact and efficient representation.
- You’re focused on data compression, de-noising, or feature extraction.
- You want faster computations with less data storage requirements.
:::