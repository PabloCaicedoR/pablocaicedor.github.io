---
title: "Procesamiento Avanzado de Imágenes Médicas"
description: "PAIM"
subtitle: "Ingeniería Biomédica"
lang: es
author: "Ph.D. Pablo Eduardo Caicedo Rodríguez"
date: last-modified
format:
  revealjs:
    code-tools: true
    code-overflow: wrap
    code-line-numbers: true
    code-copy: true
    fig-align: center
    self-contained: true
    theme:
      - simple
      - ../../recursos/estilos/metropolis.scss
    slide-number: true
    preview-links: auto
    logo: ../../recursos/imagenes/generales/Escuela_Rosario_logo.png
    css: ../../recursos/estilos/styles_pres.scss
    footer: <https://pablocaicedor.github.io/>
    transition: fade
    progress: true
    scrollable: true
    mainfont: "Fira Code"
resources:
  - demo.pdf
---

# Procesado Avanzado de Imágenes Médicas - PAIM

# Fundamentos Matemáticos


## Introducción al Procesamiento Biomédico

* La imagen médica es un proceso de **extracción de información biológica fidedigna**.
* Impacto directo en la **interpretabilidad diagnóstica**.
* Base fundamental para el desarrollo de sistemas de **IA Confiable**.



## 1. Representación Digital

### Modelado de la Digitalización
Una imagen continua $f(x,y)$ se discretiza en $I[m,n]$ mediante:

1.  **Muestreo Espacial:** Determina el tamaño del píxel ($\sim 100-200 \mu m$ en radiografía).
2.  **Cuantización:** Resolución de contraste.
    * Estándar Clínico: **12-16 bits** (Escala Hounsfield).
    * Falso contorneo: Artefacto por baja profundidad de bits.



## 1. Representación Digital

:::{.panel-tabset}

## Cuantizacion

```{python}

import numpy as np
import matplotlib.pyplot as plt
from skimage import data, img_as_float, color


def simulate_quantization(image, bits):
    """
    Simula el efecto de reducir la profundidad de bits.
    """
    levels = 2**bits
    return np.round(image * (levels - 1)) / (levels - 1)


# Cargamos una imagen de prueba y la normalizamos
image = img_as_float(data.camera())
# Simulamos diferentes profundidades
q_8bit = simulate_quantization(image, 8)
q_4bit = simulate_quantization(image, 4)
q_2bit = simulate_quantization(image, 2)

fig, axes = plt.subplots(1, 3, figsize=(18, 6))
axes[0].imshow(q_8bit, cmap="gray")
axes[0].set_title("Resolución Estándar (8-bit)")
axes[1].imshow(q_4bit, cmap="gray")
axes[1].set_title("Cuantización 4-bit (16 niveles)")
axes[2].imshow(q_2bit, cmap="gray")
axes[2].set_title("Cuantización 2-bit (4 niveles)")
for ax in axes:
    ax.axis("off")
plt.tight_layout()
plt.show()

```

## Código

```{python}
# | eval: false

import numpy as np
import matplotlib.pyplot as plt
from skimage import data, img_as_float, color


def simulate_quantization(image, bits):
    """
    Simula el efecto de reducir la profundidad de bits.
    """
    levels = 2**bits
    return np.round(image * (levels - 1)) / (levels - 1)


# Cargamos una imagen de prueba y la normalizamos
image = img_as_float(data.camera())
# Simulamos diferentes profundidades
q_8bit = simulate_quantization(image, 8)
q_4bit = simulate_quantization(image, 4)
q_2bit = simulate_quantization(image, 2)

fig, axes = plt.subplots(1, 3, figsize=(18, 6))
axes[0].imshow(q_8bit, cmap="gray")
axes[0].set_title("Resolución Estándar (8-bit)")
axes[1].imshow(q_4bit, cmap="gray")
axes[1].set_title("Cuantización 4-bit (16 niveles)")
axes[2].imshow(q_2bit, cmap="gray")
axes[2].set_title("Cuantización 2-bit (4 niveles)")
for ax in axes:
    ax.axis("off")
plt.tight_layout()
plt.show()

```

:::

## 1. Representación Digital
![](../../recursos/imagenes/Presentaciones/PAIM/paim001.png)

## 2. Percepción Visual y Color

* **Limitación de RGB:** Falta de uniformidad perceptual para análisis cuantitativo.
* **Espacio CIELAB:**
    * $L^*$: Luminosidad (información estructural).
    * $a^*, b^*$: Componentes cromáticos.
* **Aplicación:** Crítico en patología digital y endoscopia.



## 3. Caracterización del Ruido Clínico

El ruido es un proceso estocástico dependiente de la física de adquisición:

* **Ruido de Poisson (Cuántico):**
    * Dominante en Rayos X y TC.
    * $\sigma^2 \propto \text{Intensidad de la señal}$.
* **Ruido Gaussiano (Electrónico):**
    * Originado por la instrumentación y digitalización.

## 3. Caracterización del Ruido Clínico

```{python}
# | echo: false
# | eval: true
# | output: true
# | label: Poisson Noise

import numpy as np
import matplotlib.pyplot as plt
from skimage import data


def add_poisson_noise(image, peak=50):
    """
    Simula el ruido cuántico (shot noise) típico de adquisiciones de Rayos X
    utilizando una distribución de Poisson.
    """
    # Escalamiento para simular el flujo de fotones (λ = image * peak)
    # La variable 'noisy' es una realización de la variable aleatoria de Poisson
    noisy = np.random.poisson(image * peak) / peak
    return np.clip(noisy, 0, 1)


# Generación del fantoma de Shepp-Logan
phantom = data.shepp_logan_phantom()
noisy_phantom = add_poisson_noise(phantom, peak=50)

# Visualización comparativa
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.imshow(phantom, cmap="gray")
plt.title("Fantoma Ideal (Sin Ruido)")
plt.axis("off")

plt.subplot(1, 2, 2)
plt.imshow(noisy_phantom, cmap="gray")
plt.title(r"Fantoma con Ruido de Poisson ($\lambda \propto I$)")
plt.axis("off")

plt.tight_layout()
plt.show()

```

## 4. Métricas de Desempeño

$$SNR = \frac{\mu_{signal}}{\sigma_{signal}}$$

$$CNR = \frac{\mu_{signal} - \mu_{background}}{\sqrt{\sigma_{signal}^2 + \sigma_{background}^2}}$$

Para que una patología sea detectable, debe superar el umbral de ruido:

**Contrast-to-Noise Ratio (CNR):**
$$CNR = \frac{|\mu_{tumor} - \mu_{sano}|}{\sqrt{\sigma_{tumor}^2 + \sigma_{sano}^2}}$$

* Evalúa la diferencia de intensidad entre tejidos normalizada por el ruido ambiental.

## 4. Métricas de Desempeño

```{python}
# | echo: false
# | eval: true
# | output: true
# | label: CNR


def get_metrics(
    img: np.ndarray, roi_sig: list[int], roi_bg: list[int]
) -> tuple[float, float]:
    """
    Calcula SNR y CNR con validación de dimensiones y robustez estadística.

    Args:
        img: Matriz de la imagen (2D).
        roi_sig: Coordenadas [y1, y2, x1, x2] de la señal.
        roi_bg: Coordenadas [y1, y2, x1, x2] del fondo.
    """
    try:
        # Extracción con slicing
        signal = img[roi_sig[0] : roi_sig[1], roi_sig[2] : roi_sig[3]]
        background = img[roi_bg[0] : roi_bg[1], roi_bg[2] : roi_bg[3]]

        if signal.size == 0 or background.size == 0:
            raise ValueError(
                "Las ROIs no deben estar vacías. Verifique las coordenadas."
            )

        mu_s, sigma_s = np.mean(signal), np.std(signal)
        mu_b, sigma_b = np.mean(background), np.std(background)

        # SNR basada en la variabilidad local de la señal (IA Confiable)
        snr = mu_s / sigma_s if sigma_s != 0 else 0.0

        # CNR normalizada para mejor comparativa entre equipos
        cnr = np.abs(mu_s - mu_b) / np.sqrt(sigma_s**2 + sigma_b**2)

        return float(snr), float(cnr)

    except Exception as e:
        print(f"Error en el cálculo de métricas: {e}")
        return 0.0, 0.0


#
#  Definición de ROIs sobre el fantoma (ejemplo ilustrativo)
# ROI señal: elipse central; ROI fondo: área negra superior
snr, cnr = get_metrics(noisy_phantom, [180, 220, 180, 220], [10, 40, 10, 40])
print(f"Métricas de Calidad:\nSNR: {snr:.4f}\nCNR: {cnr:.4f}")

import matplotlib.pyplot as plt
import matplotlib.patches as patches
import numpy as np


def plot_roi_validation(
    img: np.ndarray, roi_sig: list, roi_bg: list, snr: float, cnr: float
):
    """
    Genera una visualización académica de las ROIs y las métricas obtenidas.
    """
    fig, ax = plt.subplots(1, 1, figsize=(8, 8))

    # Mostrar imagen en escala de grises
    ax.imshow(img, cmap="gray", origin="upper")

    # Definir rectángulos [y1, y2, x1, x2] -> Rectangle((x, y), width, height)
    rect_sig = patches.Rectangle(
        (roi_sig[2], roi_sig[0]),
        roi_sig[3] - roi_sig[2],
        roi_sig[1] - roi_sig[0],
        linewidth=2,
        edgecolor="r",
        facecolor="none",
        label="Señal",
    )

    rect_bg = patches.Rectangle(
        (roi_bg[2], roi_bg[0]),
        roi_bg[3] - roi_bg[2],
        roi_bg[1] - roi_bg[0],
        linewidth=2,
        edgecolor="b",
        facecolor="none",
        label="Fondo",
    )

    # Agregar parches a los ejes
    ax.add_patch(rect_sig)
    ax.add_patch(rect_bg)

    # Estética y anotaciones
    ax.set_title(f"Validación de ROIs\nSNR: {snr:.2f} | CNR: {cnr:.2f}", fontsize=14)
    ax.legend(loc="upper right")
    ax.axis("off")

    plt.tight_layout()
    plt.show()


# Ejemplo de uso:
plot_roi_validation(noisy_phantom, [180, 220, 180, 220], [10, 40, 10, 40], snr, cnr)

```

## 5. Resolución Espacial y la MTF

La resolución no es solo el tamaño de la matriz, es una **propiedad dinámica**.

* **PSF (Point Spread Function):** Respuesta del sistema a un punto infinitesimal $\delta(x,y)$.
* **MTF (Modulation Transfer Function):**
    $$MTF(u,v) = \frac{|\mathcal{F}\{PSF\}|}{|\mathcal{F}\{PSF\}_{(0,0)}|}$$
* Cuantifica la pérdida de contraste en función de la frecuencia espacial ($lp/mm$).



## 6. Determinación Práctica: Método del Borde

Dado que no existen "puntos perfectos", se utiliza el borde de una placa de plomo:

1.  **ERF (Edge Response Function):** Perfil perpendicular al borde.
2.  **LSF (Line Spread Function):** Derivada de la ERF ($LSF(x) = \frac{d}{dx}ERF(x)$).
3.  **MTF:** Transformada de Fourier de la LSF.



## 7. Interpretación Clínica de la MTF


* **$f_{50}$:** Frecuencia donde se pierde el 50% del contraste (nitidez percibida).
* **$f_{10}$:** Límite de resolución detectable por el ojo humano.
* **Mamografía:** Requiere MTF alta en frecuencias elevadas ($10-15 lp/mm$).
* **TC Corporal:** Centrado en frecuencias bajas para contraste de tejidos blandos.



## Conclusiones

* La **cuantización** limita la sensibilidad del contraste.
* El **ruido cuántico** impone el límite fundamental de detectabilidad.
* La **MTF** es la métrica definitiva para validar la cadena de adquisición.
* Sin métricas objetivas (CNR, MTF), la validación de IA carece de sustento físico.
