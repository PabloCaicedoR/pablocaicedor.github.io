---
title: "Sistemas y Señales Biomédicos"
description: "SYSB"
subtitle: "Ingeniería Biomédica"
lang: es
author: "Ph.D. Pablo Eduardo Caicedo Rodríguez"
date: last-modified
format:
  revealjs: 
    code-tools: true
    code-overflow: wrap
    code-line-numbers: true
    code-copy: true
    fig-align: center
    self-contained: true
    theme: 
      - simple
      - ../../recursos/estilos/metropolis.scss
    slide-number: true
    preview-links: auto
    logo: ../../recursos/imagenes/generales/Escuela_Rosario_logo.png
    css: ../../recursos/estilos/styles_pres.scss
    footer: <https://pablocaicedor.github.io/>
    transition: fade
    progress: true
    scrollable: true
    mainfont: "Fira Code"

resources:
  - demo.pdf
---

```{r}
#| echo: false
#| eval: true
#| output: false
#| label: Loading R-Libraries
# install.packages(c("DiagrammeR", "reticulate", "kableExtra", "tidyverse", "knitr", "cowplot", "ggfx"))
library("DiagrammeR")
library("reticulate")
library("kableExtra")
library("tidyverse")
library("knitr")
library("cowplot")
library("ggfx")
knitr::opts_chunk$set(echo = FALSE)

def.chunk.hook <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
    x <- def.chunk.hook(x, options)
    ifelse(options$size != "normalsize", paste0("\n \\", options$size, "\n\n", x, "\n\n \\normalsize"), x)
})
```

```{python}
# | echo: false
# | eval: true
# | output: false
# | label: Loading Python-Libraries

import numpy as np
import matplotlib.pyplot as plt

plt.rcParams.update(
    {
        "text.usetex": True,  # usar LaTeX real
        "font.family": "Fira Code",  # familia general
        "mathtext.fontset": "custom",  # fuente personalizada para fórmulas
        "mathtext.rm": "Fira Code",  # texto “roman”
        "mathtext.it": "Fira Code:italic",  # texto itálico
        "mathtext.bf": "Fira Code:bold",  # texto en negrita
        "text.latex.preamble": r"\usepackage{amsmath}",
    }
)

path_ecg = "../../data"

```

# Sistemas y Señales Biomedicos - SYSB

## Introduction to data adquisition{.smaller}

:::: {.columns}

::: {.column width="45%"}

- There are two main roles in data: capture the information and encode the data in a form tha machine can process.
- Data adquisition has three stages: 
  - Transduction
  - Signal conditioning
  - Analog-to-digital conversion

:::

::: {.column width="45%"}

![](../../recursos/imagenes/Presentaciones/SYSB/dataAduisition01.png)

:::
::::

## Introduction to data adquisition - Transduction{.smaller}

:::: {.columns}

::: {.column width="45%"}

- Transduction is the conversion from one form of energy to another.
- The only energy suitable for computer processing is the electrical
- Therefore signals need to be converted to analog voltages whose waveforms are ideally the same as those of the original signals.
- Exist two components a captured signal: one component carries the information (signal), the other one is a probabilistic distorsion of the information(noise)

:::

::: {.column width="45%"}

![](../../recursos/imagenes/Presentaciones/SYSB/dataAduisition02.png)

:::
::::

## Introduction to data adquisition - Noise{.smaller}

:::: {.columns}

::: {.column width="45%"}

::: {.callout-important title="Definition"}

Noise refers to any unwanted or random variations in a signal that interfere with the desired information. It is an unpredictable disturbance that can distort or obscure the actual data, making it harder to interpret or analyze.

:::

### Types of noise

- Thermal Noise (Random Noise)
- Electromagnetic Interference (EMI)
- Motion Artifacts
- Physiological Noise
- Quantization Noise

:::

::: {.column width="45%"}

![](../../recursos/imagenes/Presentaciones/SYSB/dataAduisition03.png)

:::
::::

## Introduction to data adquisition - Noise{.smaller}

:::: {.columns}

::: {.column width="45%"}

### Modelling the noise

- Additive White Gaussian Noise (AWGN): Modeled as a random process with a normal distribution.
- Band-limited Noise: Affects only specific frequency ranges and can be removed with filters.
- Additive Noise: Adds directly to the original signal.
- Multiplicative Noise: Multiplies the original signal.

:::

::: {.column width="45%"}

![](../../recursos/imagenes/Presentaciones/SYSB/dataAduisition03.png)

:::
::::

## Introduction to data adquisition - Noise{.smaller}

::: {.panel-tabset}

## Graphs

```{python}
#| echo: false
#| eval: true
#| output: true
#| label: noise 01
#| fig-align: "center"
# Parámetros de la señal

duration = 2  # Duración en segundos
fs = 1000  # Frecuencia de muestreo en Hz
t = np.linspace(0, duration, duration * fs, endpoint=False)  # Vector de tiempo

# Señal senoidal de 10 Hz
freq = 10
sine_wave = np.sin(2 * np.pi * freq * t)

# Señal de ruido aleatorio con distribución normal
noise_normal = np.random.normal(0, 1, len(t))

# Señal con ruido aleatorio de 2 a 5 Hz
low_freq_noise = np.sin(2 * np.pi * np.random.uniform(2, 5) * t)
signal_with_low_freq_noise = sine_wave + low_freq_noise

# Señal con ruido aleatorio uniforme sumado
uniform_noise = np.random.uniform(-0.5, 0.5, len(t))
signal_with_uniform_noise = sine_wave + uniform_noise

# Señal con ruido aleatorio uniforme multiplicado
multiplicative_noise = np.random.uniform(0.5, 1.5, len(t))
signal_with_mult_noise = sine_wave * multiplicative_noise

# Graficamos las señales
fig, axes = plt.subplots(5, 1, figsize=(10, 10), sharex=True)

axes[0].plot(t, sine_wave, label="Sine wave (10 Hz)")
axes[0].set_title("Sine Wave (10 Hz)")
axes[0].legend()

axes[1].plot(
    t, noise_normal, label="Random Noise (Normal Distribution)", color="orange"
)
axes[1].set_title("Random Noise (Normal Distribution)")
axes[1].legend()

axes[2].plot(
    t, signal_with_low_freq_noise, label="Sine + Low Freq Noise (2-5 Hz)", color="green"
)
axes[2].set_title("Sine + Low Freq Noise (2-5 Hz)")
axes[2].legend()

axes[3].plot(t, signal_with_uniform_noise, label="Sine + Uniform Noise", color="red")
axes[3].set_title("Sine + Uniform Noise")
axes[3].legend()

axes[4].plot(t, signal_with_mult_noise, label="Sine * Uniform Noise", color="purple")
axes[4].set_title("Sine * Uniform Noise")
axes[4].legend()

plt.xlabel("Time [s]")
plt.tight_layout()
plt.show()
```

## Code

```{python}
#| echo: true
#| eval: false
#| output: false
#| label: Noise 02

import numpy as np
import matplotlib.pyplot as plt

# Parámetros de la señal
duration = 2  # Duración en segundos
fs = 1000  # Frecuencia de muestreo en Hz
t = np.linspace(0, duration, duration * fs, endpoint=False)  # Vector de tiempo

# Señal senoidal de 10 Hz
freq = 10
sine_wave = np.sin(2 * np.pi * freq * t)

# Señal de ruido aleatorio con distribución normal
noise_normal = np.random.normal(0, 1, len(t))

# Señal con ruido aleatorio de 2 a 5 Hz
low_freq_noise = np.sin(2 * np.pi * np.random.uniform(2, 5) * t)
signal_with_low_freq_noise = sine_wave + low_freq_noise

# Señal con ruido aleatorio uniforme sumado
uniform_noise = np.random.uniform(-0.5, 0.5, len(t))
signal_with_uniform_noise = sine_wave + uniform_noise

# Señal con ruido aleatorio uniforme multiplicado
multiplicative_noise = np.random.uniform(0.5, 1.5, len(t))
signal_with_mult_noise = sine_wave * multiplicative_noise

# Graficamos las señales
fig, axes = plt.subplots(5, 1, figsize=(10, 10), sharex=True)

axes[0].plot(t, sine_wave, label="Sine wave (10 Hz)")
axes[0].set_title("Sine Wave (10 Hz)")
axes[0].legend()

axes[1].plot(
    t, noise_normal, label="Random Noise (Normal Distribution)", color="orange"
)
axes[1].set_title("Random Noise (Normal Distribution)")
axes[1].legend()

axes[2].plot(
    t, signal_with_low_freq_noise, label="Sine + Low Freq Noise (2-5 Hz)", color="green"
)
axes[2].set_title("Sine + Low Freq Noise (2-5 Hz)")
axes[2].legend()

axes[3].plot(t, signal_with_uniform_noise, label="Sine + Uniform Noise", color="red")
axes[3].set_title("Sine + Uniform Noise")
axes[3].legend()

axes[4].plot(t, signal_with_mult_noise, label="Sine * Uniform Noise", color="purple")
axes[4].set_title("Sine * Uniform Noise")
axes[4].legend()

plt.xlabel("Time [s]")
plt.tight_layout()
plt.show()

```

:::

## Introduction to data adquisition - ASP{.smaller}

:::: {.columns}

::: {.column width="45%"}

::: {.callout-tip title="Definition"}
Analog signal processing (ASP) refers to the manipulation of continuous-time signals after they have been acquired from a transducer but before digital conversion. This type of processing is performed using electronic circuits that modify the signal in the analog domain to enhance its quality, extract useful information, or prepare it for further processing.
:::

::: {.callout-tip title="Common tasks"}
- **Amplification:** Increases the signal strength to match the required voltage levels. *Example*: ECG signals are weak (~1 mV) and need to be amplified before analysis.
- **Filtering:** Removes unwanted frequency components such as noise or interference.
- **Modulation/Demodulation:** Used for communication systems where signals are modulated onto a higher-frequency carrier wave. *Example*: Biomedical telemetry systems use amplitude modulation (AM) or frequency modulation (FM) to transmit patient data wirelessly.
- **Differentiation & Integration:** Differentiation: Highlights rapid changes in the signal. *Example*: Used in QRS detection for ECG signal analysis. Integration: Smooths out signals and accumulates values over time.
*Example*: Used in electromyography (EMG) processing to estimate muscle activation.
- **Signal Conditioning:** Includes impedance matching, offset correction, and dynamic range adjustments. *Example*: Removing DC offsets in biosignals before digitization.
:::

:::

::: {.column width="45%"}

![](../../recursos/imagenes/Presentaciones/SYSB/dataAduisition03.png)

:::
::::

## Introduction to data adquisition - analog-to-digital convertion{.smaller}

::: {.callout-important title="Definition"}
An analog-to-digital converter (ADC) is a device that converts a continuous-time signal, obtained through a transducer, into a digital signal that can be processed by a computer. This process consists of two fundamental operations, which occur simultaneously in practical implementations: sampling and quantization.
:::

### Operations
-  **Sampling** involves converting the continuous-time analog signal into a discrete-time signal, where the amplitude remains unrestricted.
-  **Quantization** then maps this continuous-amplitude signal to a finite set of discrete values, making it fully digital.
  

## Analog to digital convertion

To explain the analog-to-digital conversion process, we will assume that the input signal is a cosine wave with frequency $F$, angular frequency $\Omega$ and amplitude $a$.

$$x\left(t\right) = a \cos\left(\Omega t + \phi\right) = a \cos\left(2\pi F t + \phi\right)$$

Obtaining

$$x\left[n\right] = a \cos\left(\omega n + \phi\right) = a \cos\left(2\pi f n + \phi\right)$$

## Analog to digital convertion
```{python}
#| echo: false
#| eval: true
#| output: true
#| label: Sampling Process 01
#| fig-align: "center"

# Parámetros
Fs = 10  # Frecuencia de muestreo (Hz)
F1 = 3  # Frecuencia de la primera señal (Hz)
F2 = F1 + Fs  # Frecuencia de la segunda señal (F1 + Fs) - Produce aliasing

T = 1  # Duración en segundos
t_continuo = np.linspace(0, T, 1000)  # Tiempo continuo para la señal original
n_discreto = np.arange(0, T, 1 / Fs)  # Instantes de muestreo

# Generar señales en tiempo continuo
x_continuo1 = np.cos(2 * np.pi * F1 * t_continuo)
x_continuo2 = np.cos(2 * np.pi * F2 * t_continuo)

# Generar señales muestreadas
x_discreto1 = np.cos(2 * np.pi * F1 * n_discreto)
x_discreto2 = np.cos(2 * np.pi * F2 * n_discreto)

plt.figure(figsize=(10, 6))
plt.plot(t_continuo, x_continuo1, label=f"Frequency {F1} Hz", linestyle="dashed", color="brown")
plt.plot(t_continuo, x_continuo2, label=f"Frequency {F2} Hz", linestyle="dotted", color="black")
plt.scatter(
    n_discreto,
    x_discreto1,
    facecolors='none',
    edgecolors='red',
    s=100,
    label=f"Samples {F1} Hz",
)
plt.scatter(
    n_discreto,
    x_discreto2,
    facecolors="blue",
    edgecolors="blue",
    label=f"Samples {F2} Hz",
)

plt.title("Discrete Signals (Sampled)")
plt.xlabel("Time (s)")
plt.ylabel("Amplitude")

plt.legend()
plt.grid()
plt.show()

```

## Analog to digital convertion

::: {.callout-note title="What?"}

Mathematically, the sampling process is:

$$x[n] = x(nT_s), \quad -\infty < n < \infty$$

:::

Replacing in previous equations, we have the expression:

$$x[n] = x(nT_s) = a \cos\left( 2\pi F n T_s + \phi \right) = a \cos\left( 2\pi n \frac{F}{F_s} + \phi \right)
$$

Where:

$$\omega = \Omega T_s, \quad f = \frac{F}{F_s}$$

## Sample and quantization of an ECG signal

::: {.panel-tabset}

## Task

- Generate a synthetic ECG-like signal.
- Sample it at different rates.
- Apply quantization with different bit depths.

## Graph

```{python}
#| echo: false
#| eval: true
#| output: true
#| label: example of sampling and quantization 01
#| fig-align: center

# Generate a synthetic ECG-like signal (chirp function as approximation)
fs_original = 10000  # High sampling rate (Hz) - "continuous" signal
t = np.linspace(0, 1, fs_original, endpoint=False)  # 1-second signal
signal = np.sin(2 * np.pi * 1.7 * (t**2))  # Simulated chirp (similar to ECG waves)

# Downsample (Sampling Process)
fs_sampled = 200  # Sampling frequency in Hz (e.g., ECG sampled at 200 Hz)
t_sampled = np.arange(0, 1, 1/fs_sampled)
signal_sampled = np.sin(2 * np.pi * 1.7 * (t_sampled**2))

# Quantization (8-bit and 4-bit)
def quantize(signal, bits):
    levels = 2**bits
    min_val, max_val = signal.min(), signal.max()
    step = (max_val - min_val) / levels
    quantized_signal = np.round((signal - min_val) / step) * step + min_val
    return quantized_signal

signal_quantized_8bit = quantize(signal_sampled, 8)
signal_quantized_4bit = quantize(signal_sampled, 4)

# Plot Results
plt.figure(figsize=(12, 6))

# Original vs Sampled Signal
plt.subplot(2, 1, 1)
plt.plot(t, signal, 'k', alpha=0.3, label='Original Signal (High Resolution)')
plt.plot(t_sampled, signal_sampled, 'ro-', label=f'Sampled Signal ({fs_sampled} Hz)')
plt.xlabel("Time (s)")
plt.ylabel("Amplitude")
plt.legend()
plt.title("Sampling Process")

# Quantized Signals
plt.subplot(2, 1, 2)
plt.plot(t_sampled, signal_sampled, 'bo-', alpha=0.5, label="Original Sampled")
plt.plot(t_sampled, signal_quantized_8bit, 'go-', label="Quantized 8-bit")
plt.plot(t_sampled, signal_quantized_4bit, 'ro-', label="Quantized 4-bit")
plt.xlabel("Time (s)")
plt.ylabel("Amplitude")
plt.legend()
plt.title("Quantization Effect")

plt.tight_layout()
plt.show()

```

## Code

```{python}
#| echo: true
#| eval: false
#| output: false
#| label: example of sampling and quantization 02

import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import chirp

# Generate a synthetic ECG-like signal (chirp function as approximation)
fs_original = 10000  # High sampling rate (Hz) - "continuous" signal
t = np.linspace(0, 1, fs_original, endpoint=False)  # 1-second signal
signal = np.sin(2 * np.pi * 1.7 * (t**2))  # Simulated chirp (similar to ECG waves)

# Downsample (Sampling Process)
fs_sampled = 200  # Sampling frequency in Hz (e.g., ECG sampled at 200 Hz)
t_sampled = np.arange(0, 1, 1/fs_sampled)
signal_sampled = np.sin(2 * np.pi * 1.7 * (t_sampled**2))

# Quantization (8-bit and 4-bit)
def quantize(signal, bits):
    levels = 2**bits
    min_val, max_val = signal.min(), signal.max()
    step = (max_val - min_val) / levels
    quantized_signal = np.round((signal - min_val) / step) * step + min_val
    return quantized_signal

signal_quantized_8bit = quantize(signal_sampled, 8)
signal_quantized_4bit = quantize(signal_sampled, 4)

# Plot Results
plt.figure(figsize=(12, 6))

# Original vs Sampled Signal
plt.subplot(2, 1, 1)
plt.plot(t, signal, 'k', alpha=0.3, label='Original Signal (High Resolution)')
plt.plot(t_sampled, signal_sampled, 'ro-', label=f'Sampled Signal ({fs_sampled} Hz)')
plt.xlabel("Time (s)")
plt.ylabel("Amplitude")
plt.legend()
plt.title("Sampling Process")

# Quantized Signals
plt.subplot(2, 1, 2)
plt.plot(t_sampled, signal_sampled, 'bo-', alpha=0.5, label="Original Sampled")
plt.plot(t_sampled, signal_quantized_8bit, 'go-', label="Quantized 8-bit")
plt.plot(t_sampled, signal_quantized_4bit, 'ro-', label="Quantized 4-bit")
plt.xlabel("Time (s)")
plt.ylabel("Amplitude")
plt.legend()
plt.title("Quantization Effect")

plt.tight_layout()
plt.show()


```

:::

---

## Slide 1 — Course framing

**Practical Sampling & Quantization for Biomedical Signals**

* Focus: sampling, aliasing, reconstruction, quantization, SNR, range, companding
* Clinical touchstones: ECG, EEG, EMG, PPG
* Constraints: ≤7 lines/slide, Python plots only, no Fourier content
* Primary source: Oppenheim, Willsky, Nawab, *Signals and Systems*, 2nd ed. (ISBN: 978-0138147570)
* Secondary: Shannon (DOI: 10.1109/JRPROC.1949.232969), Nyquist (DOI: 10.1109/T-AIEE.1928.5055024), Jayant & Noll (ISBN: 0-13-211913-7)

---

## Slide 2 — Sampling model & Nyquist (with ECG example)

\::: columns
\::: {.column width=45%}
**Model**

* Sample period: \$T\_s=1/f\_s\$ (Oppenheim 2e, ISBN: 978-0138147570)
* Impulse train view: \$x\_s(t)=\sum\_{n=-\infty}^{\infty}x(nT\_s),\delta(t-nT\_s)\$ (Oppenheim 2e)
* Bandlimit \$B\$ ⇒ **Nyquist**: \$f\_s\ge 2B\$ (Shannon 1949, DOI above)
  \:::
  \::: {.column width=45%}
  **Clinical tie-in (ECG)**
* Diagnostic ECG bandwidth \$B\approx 150\ \mathrm{Hz}\$ ⇒ pick \$f\_s=500\ \mathrm{Hz}\$ for margin
* Rationale: \$f\_s\ge 2B\$ + antialias margin improves filter realizability (Shannon 1949; Webster MI 4e, ISBN: 978-0471676003)
  \:::
  \:::

---

## Slide 3 — Aliasing & anti-alias filtering (with EMG example)

\::: columns
\::: {.column width=45%}
**Aliasing**

* Frequencies above \$f\_s/2\$ fold into baseband as false low-frequency content (Oppenheim 2e)
* Prevent by pre-sampling low-pass: \$f\_c< f\_s/2\$ with transition guard band
  \:::
  \::: {.column width=45%}
  **Clinical tie-in (EMG)**
* Surface EMG has content up to \$\sim 500\text{–}1000\ \mathrm{Hz}\$
* Example: choose \$f\_s=2\ \mathrm{kHz}\$, \$f\_c\approx 800\ \mathrm{Hz}\$ to limit folding (Webster MI 4e, ISBN above)
  \:::
  \:::

---

## Slide 4 — Discrete-time reconstruction (conceptual)

* Goal: recover a continuous-time \$y(t)\$ consistent with samples \$x\[n]\$
* Ideal: band-limited interpolation + smoothing LPF (conceptual; no Fourier used)
* Practical DAC: zero-order hold followed by analog smoothing LPF (Oppenheim 2e)
* **Clinical tie-in (PPG)**: reconstruct smooth pulsatile waveform for heart-rate variability after downlink

---

## Slide 5 — Uniform quantization & step size \$\Delta\$ (with ECG example)

\::: columns
\::: {.column width=45%}
**Definitions**

* ADC input range $\[V\_{\min},V\_{\max}]\$, bit depth \$b\$
* Step size: $\Delta=\frac{V\_{\max}-V\_{\min}}{2^{b}} \quad\text{(Oppenheim 2e)}$
  \:::
  \::: {.column width=45%}
  **Clinical tie-in (ECG)**
* Example: \$\pm 5\ \mathrm{mV}\$ input, \$b=12\$ ⇒ \$\Delta=\frac{10\ \mathrm{mV}}{4096}\approx 2.44\ \mu\mathrm{V}\$
* Small \$\Delta\$ captures low-amplitude ST-segment changes (Webster MI 4e)
  \:::
  \:::

---

## Slide 6 — Quantization noise & SNR vs. bits

\::: columns
\::: {.column width=45%}
**Uniform noise model**

* Noise power: $\sigma\_q^2=\frac{\Delta^2}{12} \quad\text{(Oppenheim 2e)}$
* Full-scale sinusoid SNR: $\mathrm{SNR}\_{\mathrm{dB}}\approx 6.02\,b + 1.76 \quad\text{(Jayant & Noll, ISBN: 0-13-211913-7)}$
  \:::
  \::: {.column width=45%}
  **Clinical tie-in**
* 12-bit ⇒ \$\mathrm{SNR}\approx 6.02\cdot 12+1.76\approx 74\ \mathrm{dB}\$
* EEG (tens of \$\mu\$V): often benefits from \$b\ge 16\$ plus low-noise analog front-end (Webster MI 4e)
  \:::
  \:::

---

## Slide 7 — Input range, gain, and clipping

* Set front-end gain so expected peaks approach full-scale **without** saturation
* Clipping distorts morphology and invalidates \$SNR\$ assumptions (Oppenheim 2e)
* **Clinical tie-in (EMG)**: \$\pm 5\ \mathrm{mV}\$ at skin ⇒ gain \$\approx 1000\$ to map to \$\pm 5\ \mathrm{V}\$ ADC; motion bursts can clip ⇒ add headroom (Webster MI 4e)
* Use limiter or wider range if artifacts are frequent

---

## Slide 8 — Brief companding (telemetry)

\::: columns
\::: {.column width=45%}
**Idea**

* Nonlinear mapping to emphasize low amplitudes before quantization/transmission
* \$\mu\$-law: \$F(x)=\operatorname{sgn}(x)\frac{\ln(1+\mu |x|)}{\ln(1+\mu)}\$, \$|x|\le 1\$ (Jayant & Noll)
* Typical parameters: \$\mu=255\$ (North America), \$A=87.6\$ (Europe)
  \:::
  \::: {.column width=45%}
  **Clinical tie-in**
* Low-bandwidth telemetry of voice/biomedical waveforms: preserves small ECG/PPG fluctuations at cost of large-signal fidelity
* Standards context: ITU-T G.711 \$\mu\$-law/\$A\$-law PCM (identifier: G.711)
  \:::
  \:::

---

## Slide 9 — Plot: SNR vs. bit depth (formula-based)

* Deterministic illustration from \$b=6\ldots 20\$ using \$6.02,b+1.76\$
* Use when sizing ADC resolution given noise floor and clinical SNR target
* **Assumption**: full-scale sinusoid; real biometrics may deviate (Jayant & Noll)
* See code cell (matplotlib only)

```{python}
#| echo: true
#| fig-cap: "SNR(dB) versus ADC bit depth using SNR ≈ 6.02 b + 1.76 (Jayant & Noll, ISBN: 0-13-211913-7)."
import numpy as np
import matplotlib.pyplot as plt

np.random.seed(7)  # determinism (even though not used)
b = np.arange(6, 21)
snr_db = 6.02*b + 1.76

plt.figure(figsize=(6,4))
plt.plot(b, snr_db, marker='o')
plt.xlabel("Bit depth b")
plt.ylabel("SNR (dB)")
plt.title("Quantization-limited SNR vs. bits")
plt.grid(True)
plt.tight_layout()
```

---

## Slide 10 — References (IDs included)

* Oppenheim, A. V., Willsky, A. S., Nawab, S. H., *Signals and Systems*, 2nd ed., Prentice Hall, **ISBN: 978-0138147570**.
* Shannon, C. E., “Communication in the presence of noise,” *Proc. IRE*, 37(1), 1949, **DOI: 10.1109/JRPROC.1949.232969**.
* Nyquist, H., “Certain topics in telegraph transmission theory,” *Trans. AIEE*, 47, 1928, **DOI: 10.1109/T-AIEE.1928.5055024**.
* Jayant, N. S., Noll, P., *Digital Coding of Waveforms*, Prentice-Hall, 1984, **ISBN: 0-13-211913-7**.
* Webster, J. G. (ed.), *Medical Instrumentation: Application and Design*, 4th ed., Wiley, **ISBN: 978-0471676003**.
* ITU-T Recommendation **G.711**: Pulse Code Modulation (PCM) of voice frequencies (identifier: G.711).

---