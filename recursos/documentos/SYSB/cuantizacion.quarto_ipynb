{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Quantization\"\n",
        "author: \n",
        "    - Pablo Eduardo Caicedo Rodríguez\"\n",
        "date: today\n",
        "format: html\n",
        "---\n",
        "\n",
        "# Quantization in Digital Signal Processing (with a Biomedical Example)\n",
        "\n",
        "## 1. Purpose and big picture\n",
        "\n",
        "Quantization maps a continuous-amplitude signal to a finite set of discrete levels so that it can be represented by digits. After anti-alias filtering and sampling, an analog-to-digital converter (ADC) applies quantization. This process introduces an error that acts like noise under standard conditions; understanding its magnitude is essential to sizing bit depth, gain, and dynamic range in biomedical systems (ECG, EEG, EMG, PPG).\n",
        "\n",
        "## 2. Uniform quantizer model\n",
        "\n",
        "Let the ADC input range be $\\left[V\\_{\\min},,V\\_{\\max}\\right]$ with $b$ bits and $L=2^b$ levels. The step size (LSB) is\n",
        "\n",
        "$$\n",
        "\\Delta=\\frac{V_{\\max}-V_{\\min}}{L}.\n",
        "$$\n",
        "\n",
        "Two common realizations:\n",
        "\n",
        "* **Mid-tread (rounding)**: $Q(x)=\\Delta,\\mathrm{round}\\left(\\frac{x}{\\Delta}\\right)$ for $x\\in(V\\_{\\min},V\\_{\\max})$.\n",
        "* **Mid-rise (truncate with half-step offset)**: $Q(x)=\\Delta!\\left(\\left\\lfloor\\frac{x}{\\Delta}\\right\\rfloor+\\tfrac12\\right)$.\n",
        "\n",
        "Outside $\\left[V\\_{\\min},V\\_{\\max}\\right]$, **overload/clipping** occurs: $\\tilde{x}=Q(x)=V\\_{\\max}$ if $x>V\\_{\\max}$ and $\\tilde{x}=V\\_{\\min}$ if $x\\<V\\_{\\min}$.\n",
        "\n",
        "**Codebook and decision thresholds**: Decision thresholds lie at $k\\Delta$ and reconstruction levels at either $k\\Delta$ (mid-tread) or $(k+\\tfrac12)\\Delta$ (mid-rise).\n",
        "\n",
        "## 3. Quantization error and its statistics\n",
        "\n",
        "Define the **quantization error** $e=x-Q(x)$. Under the **high-resolution assumptions** (signal varies slowly relative to $\\Delta$, input well distributed within the range, and no overload), the error is modeled as white, signal-independent, and uniformly distributed on $\\left[-\\frac{\\Delta}{2},\\frac{\\Delta}{2}\\right]$:\n",
        "\n",
        "* Mean: $\\mathbb{E}\\left[e\\right]=0$.\n",
        "* Variance (power): $\\sigma\\_e^2=\\dfrac{\\Delta^2}{12}$.\n",
        "* RMS: $\\sigma\\_e=\\dfrac{\\Delta}{\\sqrt{12}}$.\n",
        "\n",
        "For a full-scale sinusoid, the **theoretical SNR** is\n",
        "\n",
        "$$\n",
        "\\mathrm{SNR}_{\\mathrm{dB}}\\approx 6.02\\,b + 1.76.\n",
        "$$\n",
        "\n",
        "If the signal uses only a fraction $\\rho$ ($0<\\rho\\le 1$) of full scale (FS) in RMS, then\n",
        "\n",
        "$$\n",
        "\\mathrm{SNR}_{\\mathrm{dB}} \\approx 6.02\\,b + 1.76 + 20\\log_{10}(\\rho).\n",
        "$$\n",
        "\n",
        "**Effective Number of Bits (ENOB)** from a measured in-band SNR:\n",
        "\n",
        "$$\n",
        "\\mathrm{ENOB} \\approx \\frac{\\mathrm{SNR}_{\\mathrm{dB}}-1.76}{6.02}.\n",
        "$$\n",
        "\n",
        "## 4. Input range, gain, and clipping\n",
        "\n",
        "Front-end analog gain $G$ maps a biomedical signal $x\\_{\\text{in}}$ to the ADC: $x\\_{\\text{ADC}}=G,x\\_{\\text{in}}$. The **input-referred LSB** is\n",
        "\n",
        "$$\n",
        "\\Delta_{\\text{in}}=\\frac{\\Delta}{G}.\n",
        "$$\n",
        "\n",
        "Choose $G$ to:\n",
        "\n",
        "1. avoid overload for rare peaks, and 2) maximize FS utilization to improve SNR. Poor gain wastes bits (small $\\rho$) or clips clinically relevant transients (e.g., ECG pacer spikes).\n",
        "\n",
        "## 5. Biomedical example: ECG acquisition\n",
        "\n",
        "Suppose a resting ECG has peak amplitudes around $\\pm 5,\\text{mV}$ at the electrodes. We design the analog front end so that $\\pm 5,\\text{mV}$ maps to $\\pm 1,\\text{V}$ at the ADC, i.e., $G=200$. Use a $b=12$-bit ADC over $\\left[-1,\\text{V},,1,\\text{V}\\right]$:\n",
        "\n",
        "* ADC LSB: $\\Delta = \\dfrac{2,\\text{V}}{2^{12}} \\approx 0.488,\\text{mV}$ (at the ADC input).\n",
        "* **Input-referred LSB**: $\\Delta\\_{\\text{in}}=\\dfrac{0.488,\\text{mV}}{200}\\approx 2.44,\\mu\\text{V}$.\n",
        "* **Input-referred quantization-noise RMS**: $\\dfrac{\\Delta\\_{\\text{in}}}{\\sqrt{12}}\\approx 0.704,\\mu\\text{V}\\_{\\mathrm{RMS}}$.\n",
        "\n",
        "If the ECG uses $\\rho=0.5$ of full scale (typical margin against clipping), the **quantization-limited SNR** is approximately\n",
        "\n",
        "$$\n",
        "\\mathrm{SNR}_{\\mathrm{dB}} \\approx 6.02\\times 12 + 1.76 + 20\\log_{10}(0.5) \\approx 74.0 - 6.0 \\approx 68\\,\\text{dB}.\n",
        "$$\n",
        "\n",
        "This is usually below amplifier and electrode noise constraints, so 12 bits are adequate for diagnostic ECG in this setting. If the chain is quieter (e.g., invasive potentials), higher bit depth or larger $G$ may be justified.\n",
        "\n",
        "## 6. Non-uniform quantization and companding (brief)\n",
        "\n",
        "When the amplitude distribution is strongly non-uniform, **companding** transforms $x$ before uniform quantization to allocate more levels where the signal spends more time. Classical laws:\n",
        "\n",
        "* **$\\mu$-law**: $y=\\mathrm{sgn}(x),\\dfrac{\\ln(1+\\mu |x|/X\\_{\\max})}{\\ln(1+\\mu)}$, $\\mu\\approx 255$ (telephony).\n",
        "* **$A$-law**: piecewise logarithmic with parameter $A$ (Europe).\n",
        "\n",
        "Companding is common in speech/audio telemetry; in biomedicine it is less standard for primary acquisition, but can help in low-bit-rate wireless monitoring where dynamic range is wide (e.g., PPG with motion).\n",
        "\n",
        "## 7. Dither (optional but practical)\n",
        "\n",
        "Adding small white noise (RMS $\\approx \\Delta/2$) **before** quantization decorrelates the error from the signal, eliminating patterning and bias at low amplitudes. This linearizes averages at the cost of a small SNR penalty. Dither can be beneficial for low-level EEG/EMG features and precise baseline estimates.\n",
        "\n",
        "## 8. Practical checklist\n",
        "\n",
        "* Choose $b$ so that $\\mathrm{SNR}\\_{\\mathrm{dB}}$ exceeds clinical SNR needs by margin (10–20 dB).\n",
        "* Set $G$ so typical peaks use $50$–$80%$ FS; verify pacer spikes and motion spikes do not clip.\n",
        "* Budget noise: electrode + amplifier + ADC quantization; the largest non-white source often dominates.\n",
        "* Validate with a **calibrated source** (sinusoidal and biomedical-like waveforms) and measure in-band SNR/ENOB.\n",
        "\n",
        "---\n",
        "\n",
        "## 9. Python demonstration: ECG quantization, SNR, and error statistics"
      ],
      "id": "ed3d7904"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| warning: false\n",
        "# Synthetic ECG, uniform quantization at multiple bit depths, SNR and plots\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "np.random.seed(42)\n",
        "\n",
        "# --- 1) Build a simple ECG template (P-QRS-T) using Gaussians ---\n",
        "fs = 360.0                      # sampling rate [Hz]\n",
        "T = 5.0                         # duration [s]\n",
        "t = np.arange(0, T, 1/fs)\n",
        "\n",
        "hr = 60.0                       # heart rate [bpm]\n",
        "RR = 60.0/hr                    # seconds per beat\n",
        "\n",
        "# Gaussian helper\n",
        "def g(t, mu, sigma, A):\n",
        "    return A*np.exp(-0.5*((t-mu)/sigma)**2)\n",
        "\n",
        "# One-beat template (times in seconds relative to beat onset)\n",
        "def ecg_template(t):\n",
        "    # amplitudes in mV, widths in s (very simplified)\n",
        "    P  = g(t, 0.20, 0.045,  0.10)\n",
        "    Q  = g(t, 0.36, 0.010, -0.25)\n",
        "    R  = g(t, 0.40, 0.012,  1.00)\n",
        "    S  = g(t, 0.44, 0.016, -0.35)\n",
        "    T  = g(t, 0.70, 0.080,  0.30)\n",
        "    return P + Q + R + S + T\n",
        "\n",
        "# Tile the template every RR seconds\n",
        "ecg_mV = np.zeros_like(t)\n",
        "for k in range(int(np.ceil(T/RR))):\n",
        "    tau = t - k*RR\n",
        "    ecg_mV += ecg_template(tau)\n",
        "\n",
        "# Optional baseline wander + small EMG-like noise (for realism)\n",
        "wander = 0.05*np.sin(2*np.pi*0.3*t)        # 0.05 mV @ 0.3 Hz\n",
        "noise  = 0.02*np.random.randn(len(t))      # 0.02 mV RMS\n",
        "ecg_mV = ecg_mV + wander + noise\n",
        "\n",
        "# --- 2) Analog front-end gain and ADC setup ---\n",
        "G = 200.0                     # gain: mV (input) -> V (ADC input)\n",
        "Vfs = 1.0                     # full-scale = +/-1 V\n",
        "Vmin, Vmax = -Vfs, Vfs\n",
        "\n",
        "x_adc = (ecg_mV/1000.0)*G     # convert mV to V and apply gain\n",
        "\n",
        "def quantize_uniform(x, bits, Vmin, Vmax, mid_tread=True):\n",
        "    # Saturate to avoid numeric overflow\n",
        "    x_clip = np.clip(x, Vmin, Vmax)\n",
        "    L = 2**bits\n",
        "    Delta = (Vmax - Vmin)/L\n",
        "    if mid_tread:\n",
        "        y = Delta*np.round(x_clip/Delta)\n",
        "    else:\n",
        "        y = Delta*(np.floor(x_clip/Delta) + 0.5)\n",
        "    y = np.clip(y, Vmin, Vmax)  # ensure within codebook range\n",
        "    return y, Delta\n",
        "\n",
        "def snr_db(x, y):\n",
        "    # SNR over the un-clipped region; compute RMS of signal and error\n",
        "    e = x - y\n",
        "    # Remove DC for SNR assessment\n",
        "    x_ac = x - np.mean(x)\n",
        "    e_ac = e - np.mean(e)\n",
        "    Px = np.mean(x_ac**2)\n",
        "    Pe = np.mean(e_ac**2)\n",
        "    return 10*np.log10(Px/Pe), e\n",
        "\n",
        "# --- 3) Quantize at different bit depths ---\n",
        "bits_list = [8, 10, 12]\n",
        "results = {}\n",
        "for b in bits_list:\n",
        "    y_adc, Delta = quantize_uniform(x_adc, b, Vmin, Vmax, mid_tread=True)\n",
        "    snr, e = snr_db(x_adc, y_adc)\n",
        "    results[b] = dict(y_adc=y_adc, Delta=Delta, snr_db=snr, err=e)\n",
        "\n",
        "# Print a small summary (ADC-domain). Input-referred values via division by G.\n",
        "print(\"Summary (ADC domain):\")\n",
        "for b in bits_list:\n",
        "    Delta = results[b][\"Delta\"]\n",
        "    snr = results[b][\"snr_db\"]\n",
        "    print(f\"{b:2d}-bit -> LSB Δ = {Delta*1e3:.3f} mV, Theoretical/Measured SNR ≈ {snr:5.1f} dB\")\n",
        "\n",
        "# Input-referred LSB and noise RMS for the 12-bit case\n",
        "Delta_in = results[12][\"Delta\"]/G\n",
        "sigma_q_in = Delta_in/np.sqrt(12)\n",
        "print(f\"\\nInput-referred (12-bit): Δ_in = {Delta_in*1e6:.3f} µV, σ_q ≈ {sigma_q_in*1e6:.3f} µV RMS\")\n",
        "\n",
        "# --- 4) Plot: original vs quantized (choose 10-bit for visibility) ---\n",
        "b_plot = 10\n",
        "idx = (t >= 1.5) & (t <= 2.7)  # show about one beat\n",
        "plt.figure()\n",
        "plt.title(f\"ECG (ADC input) vs. {b_plot}-bit quantized\")\n",
        "plt.plot(t[idx], x_adc[idx], label=\"Original (ADC input)\")\n",
        "plt.plot(t[idx], results[b_plot][\"y_adc\"][idx], label=f\"{b_plot}-bit\")\n",
        "plt.xlabel(\"Time [s]\")\n",
        "plt.ylabel(\"Amplitude [V]\")\n",
        "plt.legend()\n",
        "plt.grid(True)\n",
        "plt.show()\n",
        "\n",
        "# --- 5) Plot: quantization error histogram (8-bit to exaggerate steps) ---\n",
        "b_err = 8\n",
        "plt.figure()\n",
        "plt.title(f\"Quantization error histogram ({b_err}-bit)\")\n",
        "plt.hist(results[b_err][\"err\"], bins=80, density=True)\n",
        "plt.xlabel(\"Error [V]\")\n",
        "plt.ylabel(\"PDF estimate\")\n",
        "plt.grid(True)\n",
        "plt.show()"
      ],
      "id": "945c2495",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Interpretation**\n",
        "\n",
        "* The summary reports the measured SNR from the synthetic ECG after quantization for 8/10/12 bits; values will be below the $6.02b+1.76$ bound because the signal does not use full scale constantly and includes non-sinusoidal content.\n",
        "* The input-referred $\\Delta\\_{\\text{in}}$ and $\\sigma\\_q$ for 12 bits match the analytical estimates in Section 5 (a few $\\mu\\text{V}$), consistent with common ECG design targets.\n",
        "* The error histogram approaches a uniform distribution as assumptions hold; deviations indicate correlation (e.g., at low amplitudes or with deterministic waveforms)."
      ],
      "id": "4d8cb426"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/home/sylph/DataCantatio/ai-torch/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}