---
title: "Taller3: Análisis y diseños de filtros"
author: 
    - Pablo Eduardo Caicedo Rodríguez"
date: today
format: html
editor: visual
---

# Análisis de Señales Biomédicas: Transformada Z y Diseño de Filtros Digitales

## Introducción

El procesamiento digital de señales biomédicas (como ECG y EEG) emplea herramientas matemáticas para analizar y mejorar la calidad de estas señales, extrayendo información útil para diagnóstico y monitoreo clínico ([Procesamiento de señales biomédicas: EEG & FPGA](https://www.studysmarter.es/resumenes/ingenieria/ingenieria-biomedica/procesamiento-de-senales-biomedicas/#:~:text=El%20procesamiento%20%20de%20se%C3%B1ales,el%20cuidado%20de%20los%20pacientes)). En particular, la transformada Z y los filtros digitales (FIR e IIR) son fundamentales para modelar, analizar y modificar señales en tiempo discreto. Por ejemplo, es común eliminar interferencias de línea base o ruido de red eléctrica (50/60 Hz) mediante filtros pasoalto o de rechazo (notch) adecuados ([](http://www.jscholaronline.org/articles/JBER/Signal-Processing.pdf#:~:text=wander%2C%20powerline%20interference%2C%20electromyo%02graphic%20,pass%20filter%20of%20an%20appropriate)). Este reporte teórico describe los conceptos clave para resolver un taller de análisis de señales biomédicas, cubriendo la **transformada Z**, la **estabilidad y región de convergencia (ROC)**, la **representación de sistemas LTI** (Lineales e Invariantes en el Tiempo) mediante **polos y ceros**, la **respuesta al impulso**, los **diagramas de bloques**, y el **diseño de filtros digitales FIR e IIR** (incluyendo métodos de ventaneo y transformación bilineal). Se incluyen ejemplos prácticos en Python (usando `numpy` y `scipy`) para ilustrar implementaciones, con un claro enfoque en aplicaciones biomédicas como el filtrado de señales ECG/EEG. Las explicaciones se apoyan en referencias académicas para asegurar rigor teórico.

## Transformada Z y sistemas LTI discretos

La **transformada Z** convierte una señal $x[n]$ de tiempo discreto en una representación en el dominio complejo. En forma bilateral, se define como: 

$$X(z) = \mathcal{Z}\{x[n]\} = \sum_{n=-\infty}^{\infty} x[n]\,z^{-n},$$ 

donde $z$ es una variable compleja $z = A e^{j\omega}$ (con $A=|z|$ y $\omega = \arg(z)$) ([Transformada Z - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Transformada_Z#:~:text=La%20TZ%20bilateral%20de%20una,que%20se%20define)) ([Transformada Z - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Transformada_Z#:~:text=Image%3A%20%7B%5Cdisplaystyle%20X%28z%29%3DZ%5C%7Bx%5Bn%5D%5C%7D%3D%5Csum%20_%7Bn%3D,n%7D%5C)).  En señales causales ($x[n]=0$ para $n<0$), suele usarse la **transformada Z unilateral** definida desde $n=0$ hasta $\infty$ ([Transformada Z - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Transformada_Z#:~:text=En%20el%20procesamiento%20de%20se%C3%B1ales,hacia%20afuera)). La transformada Z es análoga a la transformada de Laplace en sistemas continuos, y de hecho puede verse como una serie de Laurent (suma infinita de potencias) ([Transformada Z - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Transformada_Z#:~:text=nombre%20m%C3%A1s%20adecuado%20para%20la,las%20se%C3%B1ales%20de%20tiempo%20continuo)). 

**Región de Convergencia (ROC):** No toda señal tiene transformada Z en forma cerrada; la serie anterior converge únicamente en ciertas regiones del plano $z$. La **ROC** se define como el conjunto de valores de $z$ para los cuales la serie converge absolutamente ([Transformada Z - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Transformada_Z#:~:text=una%20se%C3%B1al%20tiene%20una%20suma,n%7D%7D%20es%20absolutamente%20sumable)). En términos prácticos, la ROC es el rango de $z$ donde $\sum_{n=-\infty}^{\infty}|x[n]z^{-n}| < \infty$ ([Transformada Z - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Transformada_Z#:~:text=una%20se%C3%B1al%20tiene%20una%20suma,n%7D%7D%20es%20absolutamente%20sumable)). Por ejemplo, si $x[n] = a^n u[n]$ (secuencia exponencial causal con $u[n]$ la escalón unidad), su transformada Z es $X(z) = \frac{1}{1 - a\,z^{-1}}$, pero esta expresión es válida solo si $|z| > |a|$ (ya que la serie geométrica converge cuando $|a/z|<1$). Así, la ROC en este caso es $|z| > |a|$. Si la señal fuera anti-causal ($x[n]=0$ para $n>0$), la ROC sería $|z| < |a|$ (convergencia hacia adentro). Si $x[n]$ tiene duración finita (FIR), su transformada Z existe para todo $z\neq0$ excepto quizá puntos donde la propia definición tenga singularidades (por lo general ROC = todo el plano $z$, excepto tal vez $z=0$ o $z=\infty$) ([Transformada Z - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Transformada_Z#:~:text=una%20se%C3%B1al%20tiene%20una%20suma,n%7D%7D%20es%20absolutamente%20sumable)). La ROC **nunca incluye polos** (donde la función $X(z)$ diverge) ([Transformada Z - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Transformada_Z#:~:text=,existir%20ning%C3%BAn%20polo%20para%20ROC)), es típicamente un anillo o media-plano en el plano $z$, y su ubicación está ligada a propiedades de la señal como causalidad y estabilidad.

**Polos y ceros:** Cualquier función de transferencia discreta o transformada Z de una señal racional puede expresarse en forma de polos y ceros. Los **ceros** son valores de $z$ que anulan $X(z)$ (raíces del numerador), y los **polos** donde $X(z)$ diverge (raíces del denominador). Por ejemplo, en $X(z) = \frac{1}{1 - a z^{-1}}$, hay un polo en $z=a$ y un cero en $z=\infty$ (o equivalente, un cero de orden 1 en el origen en la función $X(z)$ multiplicada por $z^{-1}$). La representación gráfica de polos y ceros en el plano $z$ proporciona intuición sobre el comportamiento frecuencial: los ceros en la circunferencia unitaria ($|z|=1$) cancelan ciertas frecuencias, mientras que los polos cercanos a la circunferencia unitaria amplifican componentes espectrales cercanas a su ángulo.

**Causalidad:** Un sistema LTI discreto es causal si $h[n]=0$ para $n<0$ (su respuesta impulso es nula en tiempos negativos). En la transformada Z, esto implica que la ROC es externa, es decir, de la forma $|z|>R$ (convergencia hacia $\infty$) ([Transformada Z - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Transformada_Z#:~:text=En%20el%20procesamiento%20de%20se%C3%B1ales,hacia%20afuera)). Todos los polos de un sistema causal deben estar *dentro* de la ROC (que para causal es exterior al polo de mayor radio) ([z transform - BIBO Stability in Z-domain - Signal Processing Stack Exchange](https://dsp.stackexchange.com/questions/53152/bibo-stability-in-z-domain#:~:text=As%20explained%20above%2C%20the%20ROC,by%20two%20or%20more%20poles)). Un detalle importante es que la ubicación de polos por sí sola no determina completamente la causalidad o estabilidad; la ROC es la que define cuál de las posibles señales con esos polos es la realizada ([z transform - BIBO Stability in Z-domain - Signal Processing Stack Exchange](https://dsp.stackexchange.com/questions/53152/bibo-stability-in-z-domain#:~:text=It%20is%20important%20to%20understand,not%20include%20the%20unit%20circle)). Por ejemplo, una misma función racional puede corresponder a un sistema causal inestable o a un sistema no causal estable, dependiendo de si la ROC se toma fuera o entre polos ([z transform - BIBO Stability in Z-domain - Signal Processing Stack Exchange](https://dsp.stackexchange.com/questions/53152/bibo-stability-in-z-domain#:~:text=It%20is%20important%20to%20understand,not%20include%20the%20unit%20circle)).

**Estabilidad BIBO:** Un sistema es estable (en sentido BIBO: Bounded-Input Bounded-Output) si **su respuesta al impulso $h[n]$ es absolutamente sumable**, $\sum_{n=-\infty}^{\infty}|h[n]| < \infty$. Esta condición garantiza que cualquier entrada acotada produce salida acotada ([BIBO stability - Wikipedia](https://en.wikipedia.org/wiki/BIBO_stability#:~:text=If%20Image%3A%20,R%7D%20%7D%20and)). En el dominio Z, estabilidad equivale a que la ROC de $H(z)$ **contenga al círculo unitario** ($|z|=1$) ([z transform - BIBO Stability in Z-domain - Signal Processing Stack Exchange](https://dsp.stackexchange.com/questions/53152/bibo-stability-in-z-domain#:~:text=As%20explained%20above%2C%20the%20ROC,by%20two%20or%20more%20poles)). Para sistemas causales, esto se traduce en que **todos los polos deben estar dentro del círculo unitario** (ya que la ROC causal comienza fuera del polo de mayor magnitud) ([z transform - BIBO Stability in Z-domain - Signal Processing Stack Exchange](https://dsp.stackexchange.com/questions/53152/bibo-stability-in-z-domain#:~:text=As%20explained%20above%2C%20the%20ROC,by%20two%20or%20more%20poles)). Por tanto, un filtro digital causal será estable si sus polos $p_i$ satisfacen $|p_i|<1$. En sistemas no causales (e.g. acausales diseñados con filtrado hacia atrás y adelante para cancelar fase), la estabilidad puede lograrse con polos fuera del unitario siempre y cuando la ROC (un anillo) incluya el unitario ([z transform - BIBO Stability in Z-domain - Signal Processing Stack Exchange](https://dsp.stackexchange.com/questions/53152/bibo-stability-in-z-domain#:~:text=in%20discrete%20time%29,by%20two%20or%20more%20poles)), aunque estos casos son menos comunes en línea real. En general, para diseño de filtros digitales **asumiremos causalidad**, por lo que chequear estabilidad equivale a verificar polos dentro del unitario.

**Ejemplo (ECG y estabilidad):** Considere un filtro pasoalto diseñado para remover la línea base de ECG definido por la diferencia $y[n] = x[n] - x[n-1]$. Su función de transferencia es $H(z) = 1 - z^{-1}$, con un cero en $z=1$ (cancela DC) y un polo en $z=0$ (simple, debido al $z^{-1}$). Este sistema es causal (diferencia causal) y su único polo $z=0$ está dentro del círculo unitario, por lo que es estable. De hecho, su respuesta al impulso $h[n]=\delta[n] - \delta[n-1]$ suma 0 en valor absoluto (sumable). Este filtro elimina componentes de muy baja frecuencia, como la deriva de línea base en un ECG ([](http://www.jscholaronline.org/articles/JBER/Signal-Processing.pdf#:~:text=wander%2C%20powerline%20interference%2C%20electromyo%02graphic%20,pass%20filter%20of%20an%20appropriate)), sin inestabilidad.

## Análisis de sistemas LTI en tiempo discreto

Un sistema LTI discreto queda caracterizado completamente por su **respuesta al impulso** $h[n]$. Dada cualquier entrada $x[n]$, la salida es la **convolución discreta** $y[n] = (x*h)[n] = \sum_{k=-\infty}^{\infty} h[k]\,x[n-k]$. En el dominio Z, esta convolución se convierte en multiplicación: $Y(z) = H(z)\,X(z)$ (dentro de la intersección de ROC de $X$ y $H$). La función de transferencia $H(z)$ de un sistema LTI causal viene dada por la transformada Z de $h[n]$ (unilateral). En sistemas de coeficientes constantes (difundidos en ingeniería), $H(z)$ suele ser una **función racional** de $z$: 

$$H(z) = \frac{B(z)}{A(z)} = \frac{b_0 + b_1 z^{-1} + \cdots + b_M z^{-M}}{1 + a_1 z^{-1} + \cdots + a_N z^{-N}},$$ 

donde $B(z)$ y $A(z)$ son polinomios en $z^{-1}$. La razón de escribir en potencias de $z^{-1}$ es para reflejar la causalidad (solo potencias no positivas de $z$). La ecuación en diferencias asociada es: 

$$y[n] + a_1 y[n-1] + \cdots + a_N y[n-N] = b_0 x[n] + b_1 x[n-1] + \cdots + b_M x[n-M].$$ 

Este es el modelo típico de sistemas LTI discreto. Si $N=0$ (no hay realimentación, solo ceros), el sistema es **FIR** (Finite Impulse Response), pues $h[n]$ es de duración finita (máximo $M$). Si $N>0$, hay realimentación y el sistema es **IIR** (Infinite Impulse Response), con respuesta al impulso teóricamente infinita (aunque decreciente si es estable).

**Diagramas de bloques:** Un LTI puede implementarse mediante sumas, retardos ($z^{-1}$ representa un retardo de 1 muestra) y multiplicaciones por constantes. El diagrama de bloques representa visualmente la ecuación en diferencias. Por ejemplo, para un filtro IIR de segundo orden: 

$$y[n] = -a_1 y[n-1] - a_2 y[n-2] + b_0 x[n] + b_1 x[n-1] + b_2 x[n-2],$$ 

el diagrama en forma **Directa II** combinaría los términos en una estructura canónica con dos bloques de retardo en la rama de realimentación y avance, sumadores para combinar las ramas, y coeficientes $a_i$, $b_i$. Cada polo corresponde a un lazo de realimentación (coeficientes $a_i$) y cada cero a una ramificación hacia la entrada (coeficientes $b_i$). Dibujar estos diagramas ayuda a entender la estructura interna, pero en este reporte nos enfocaremos más en el análisis matemático. Cabe destacar que **el tipo de filtro (pasa-bajos, pasa-altos, etc.) puede inferirse** de $H(z)$: por ejemplo, si $H(e^{j\omega})$ (respuesta en frecuencia) atenúa bajas frecuencias y deja pasar altas, es pasa-altos. Un método práctico es evaluar $H(z)$ en $z=e^{j0}$ (DC, $\omega=0$) y en $z=e^{j\pi}$ (Nyquist, $\omega=\pi$): si $|H(e^{j0})|=0$ y $|H(e^{j\pi})|\approx 1$, es pasa-altos; al revés sería pasa-bajos. Los **ceros en $z=1$** anulan $\omega=0$ (eliminan DC), típicos en pasa-altos ([](http://www.jscholaronline.org/articles/JBER/Signal-Processing.pdf#:~:text=wander%2C%20powerline%20interference%2C%20electromyo%02graphic%20,pass%20filter%20of%20an%20appropriate)), mientras **ceros en $z=-1$** anulan $\omega=\pi$ (eliminan la componente de Nyquist, típicos en pasa-bajos). Por su parte, **polos cercanos a $z=1$** refuerzan respuesta en bajas frecuencias; polos cercanos a $z=-1$ refuerzan la alta frecuencia $\pi$. Así, el diagrama polo-cero brinda intuición: ceros sobre la circunferencia unitaria en cierto ángulo $\theta_0$ causan una **notch** (anulación) en la frecuencia $\omega=\theta_0$, mientras polos cerca de la unidad en $\theta_0$ generan picos (potenciales resonancias) alrededor de esa frecuencia.

**Ejemplo (Filtro notch 60 Hz):** Un problema común en bioseñales es eliminar la interferencia de la red eléctrica (50/60 Hz) sobre, por ejemplo, EEG o ECG. Un filtro digital sencillo para eliminar 60 Hz (asumiendo frecuencia de muestreo $f_s=5000$ Hz) es colocar **ceros conjugados en $z = e^{\pm j 2\pi(60/5000)}$**. La función de transferencia resultante puede ser: 

$$H(z) = 1 - 2\cos(2\pi\frac{60}{5000})\,z^{-1} + z^{-2}.$$ 

Este $H(z)$ tiene ceros en $e^{\pm j2\pi(60/5000)}$ que anulan exactamente la componente de 60 Hz, implementando un filtro *notch*. Además, es un filtro FIR (orden 2) con coeficientes simétricos, lo que le da fase lineal (importante para no deformar la forma de onda). ¿Es estable? Sí, al ser FIR no hay polos fuera del origen (solo polos en 0, con módulo 0). ¿Es causal? Sí, depende solo de muestras presentes y pasadas de la señal ($x[n]$, $x[n-1]$, $x[n-2]$). ¿Qué tipo de filtro es? Es un **rechaza-banda estrecho** centrado en 60 Hz (deja pasar el resto, pero rechaza esa frecuencia). En aplicaciones, este notch suele atenuar ruido de red sin distorsionar significativamente las señales de interés ([](http://www.jscholaronline.org/articles/JBER/Signal-Processing.pdf#:~:text=Hz,The%20chapter)).

## Diseño de filtros FIR por el método de ventanas

Los filtros FIR (Respuesta al Impulso Finita) son ampliamente utilizados en procesamiento biomédico porque pueden diseñarse para tener **respuesta en fase lineal**, evitando distorsión de fase en la señal filtrada (lo cual es útil para preservar la morfología de ondas ECG, por ejemplo). Una manera conceptualmente sencilla de diseñar un FIR es mediante el **método de ventana** ([WindowFIRDesign.fm](https://course.ece.cmu.edu/~ece396/lectures/L19/WindowFIRDesign.pdf#:~:text=would%20choose%20the%20Hamming%20window%2C,In%20this)). Consiste en: (1) definir la respuesta frecuencial ideal deseada $H_d(e^{j\omega})$, (2) obtener la respuesta al impulso ideal $h_d[n]$ como la transformada inversa de Fourier de $H_d$, y (3) truncar $h_d[n]$ (que usualmente es infinita o muy larga) mediante una **función ventana** $w[n]$ para obtener un FIR realizable $h[n] = h_d[n]\,w[n]$. 

Por ejemplo, supongamos que queremos un filtro **pasa-bajos ideal** con frecuencia de corte $\omega_c$. El impulso ideal es $h_d[n] = \frac{\sin(\omega_c n)}{\pi n}$ (un sinc) que se extiende infinitamente. Para obtener un FIR causal de longitud $M$, se multiplica $h_d[n]$ por una ventana $w[n]$ de longitud $M$ centrada apropiadamente (y a menudo se aplica un corrimiento para hacer el filtro causal). Las ventanas comúnmente utilizadas incluyen: **Rectangular, Bartlett (triangular), Hann (Hanning), Hamming, Blackman**, y la **Kaiser** (que es ajustable). Cada ventana introduce un cierto **lóbulo principal** en la respuesta en frecuencia (determinando la anchura de la transición) y **lóbulos laterales** (que determinan el ripple o atenuación en bandas de rechazo) ([WindowFIRDesign.fm](https://course.ece.cmu.edu/~ece396/lectures/L19/WindowFIRDesign.pdf#:~:text=From%20the%20discussion%20above%20we,9%201)) ([WindowFIRDesign.fm](https://course.ece.cmu.edu/~ece396/lectures/L19/WindowFIRDesign.pdf#:~:text=Fig,4%CF%80)).

Las características típicas de ventanas clásicas (según Oppenheim et al. ([WindowFIRDesign.fm](https://course.ece.cmu.edu/~ece396/lectures/L19/WindowFIRDesign.pdf#:~:text=would%20choose%20the%20Hamming%20window%2C,In%20this)) ([WindowFIRDesign.fm](https://course.ece.cmu.edu/~ece396/lectures/L19/WindowFIRDesign.pdf#:~:text=Hamming%20,M%20%2B%201))) son:

- **Rectangular:** lóbulo principal más angosto (ancho $\approx 4\pi/M$ rad) pero lóbulos laterales más altos (primer sidelobe ~$-13$ dB, atenuación de rechazo $\sim$21 dB) ([WindowFIRDesign.fm](https://course.ece.cmu.edu/~ece396/lectures/L19/WindowFIRDesign.pdf#:~:text=Fig,4%CF%80)). Da la transición más abrupta para un orden dado, al costo de peor rechazo de banda.
- **Bartlett (triangular):** lóbulo principal algo más ancho ($\approx 8\pi/M$), sidelobes ~$-25$ dB ([WindowFIRDesign.fm](https://course.ece.cmu.edu/~ece396/lectures/L19/WindowFIRDesign.pdf#:~:text=Fig,4%CF%80)).
- **Hann:** lóbulo principal $\approx 8\pi/M$, sidelobes ~$-31$ dB ([WindowFIRDesign.fm](https://course.ece.cmu.edu/~ece396/lectures/L19/WindowFIRDesign.pdf#:~:text=Fig,4%CF%80)) (mejor rechazo que rectangular pero transiciones más suaves).
- **Hamming:** lóbulo principal $\approx 8\pi/M$, sidelobes $\approx -41$ dB (mínima atenuación ~53 dB en rechazo) ([WindowFIRDesign.fm](https://course.ece.cmu.edu/~ece396/lectures/L19/WindowFIRDesign.pdf#:~:text=would%20choose%20the%20Hamming%20window%2C,In%20this)) ([WindowFIRDesign.fm](https://course.ece.cmu.edu/~ece396/lectures/L19/WindowFIRDesign.pdf#:~:text=Hamming%20,M%20%2B%201)). Es muy popular por su buen compromiso entre ancho de transición y rechazo en banda eliminada.
- **Blackman:** lóbulo principal más ancho ($\approx 12\pi/M$) pero sidelobes muy bajos (~$-57$ dB, atenuación ~74 dB) ([WindowFIRDesign.fm](https://course.ece.cmu.edu/~ece396/lectures/L19/WindowFIRDesign.pdf#:~:text=Hamming%20,M%20%2B%201)).
- **Kaiser:** permite escoger un parámetro $\beta$ para controlar la atenuación de lóbulo lateral, ofreciendo flexibilidad. Aproximadamente, para lograr $A$ dB de atenuación, $\beta \approx 0.1102(A-8.7)$ (para $A>50$), y el ancho de transición normalizado $\Delta\omega$ se relaciona con el orden $M$ y $\beta$ por $M \approx \frac{A - 8}{2.285\,\Delta\omega}$ ([WindowFIRDesign.fm](https://course.ece.cmu.edu/~ece396/lectures/L19/WindowFIRDesign.pdf#:~:text=would%20choose%20the%20Hamming%20window%2C,In%20this)) (estas fórmulas provienen de aproximaciones de Kaiser y ayudan a dimensionar el filtro).

El método de ventanas es sencillo pero implica un **compromiso fijo** entre ancho de transición y ripple: una vez elegida la ventana, la única forma de mejorar la pendiente de corte es aumentar $M$ (orden del filtro). Por ejemplo, la ventana Hamming siempre tendrá ~$-53$ dB de mínimo en rechazo sin importar $M$ ([WindowFIRDesign.fm](https://course.ece.cmu.edu/~ece396/lectures/L19/WindowFIRDesign.pdf#:~:text=would%20choose%20the%20Hamming%20window%2C,In%20this)), pero al incrementar $M$ se reducirá la anchura de transición. En contraste, la ventana rectangular logra transiciones muy rápidas con orden modesto, pero su pobre rechazo (~21 dB) la hace inadecuada si necesitamos, digamos, eliminar ruido fuerte. En señales biomédicas, suele preferirse reducir al mínimo distorsiones residuales de ruido, por lo que ventanas con mejor rechazo (Hamming, Blackman o Kaiser ajustada) son comunes.

**Cálculo del orden para especificaciones dadas:** Dado un requerimiento de diseño (ej. atenuación mínima de 40 dB en banda eliminada y transición de 10 Hz), podemos estimar el orden necesario. Por ejemplo, en el taller se plantea diseñar un pasa-bajos FIR con $f_c = 55$ Hz (definido al nivel de $-6$ dB), que alcance al menos 20 dB de atenuación a 60 Hz y >40 dB más allá de 80 Hz. Esto implica una banda de transición bastante estrecha (de ~55 a 60 Hz) y un rechazo fuerte. Un enfoque sería probar varias ventanas:

- **Rectangular:** probablemente no pueda dar 40 dB de rechazo (limita ~21 dB).
- **Hamming:** puede dar ~53 dB de rechazo, suficiente, pero el ancho de transición $\Delta f$ será ~$\frac{3.3}{M}$ (en radianes normalizados, equivalente aprox. a $\frac{0.26 f_s}{M}$ en Hz para banda bilateral). Para $\Delta f \approx 5$ Hz con $f_s$ suficientemente grande, requerirá un $M$ elevado. 
- **Blackman:** daría >60 dB de rechazo, pero su transición es más ancha (por ser $12\pi/M$ rad). 
- **Kaiser:** se puede ajustar para 40 dB con quizás menor $M$ que Hamming, porque se elige justo la atenuación requerida y minimiza ancho de transición para ese nivel.

En el taller, se sugiere *calcular el orden mínimo para cada ventana* cumpliendo las specs y elegir la de menor orden. Esto implicaría usar fórmulas o tablas estándar ([WindowFIRDesign.fm](https://course.ece.cmu.edu/~ece396/lectures/L19/WindowFIRDesign.pdf#:~:text=From%20the%20discussion%20above%20we,9%201)) ([WindowFIRDesign.fm](https://course.ece.cmu.edu/~ece396/lectures/L19/WindowFIRDesign.pdf#:~:text=Fig,4%CF%80)). Por ejemplo, para 40 dB de rechazo y $\Delta f = 20$ Hz (digamos entre 60 y 80 Hz), la Hamming podría necesitar $M \approx \frac{3.3\cdot 2\pi}{(20/f_s)2\pi} = \frac{3.3 f_s}{20}$ (esta es una estimación tosca usando $\Delta\omega \approx 8\pi/M$). Si la señal es de voz muestreada a 8 kHz (caso típico, aunque aquí es biomédica a 200 Hz?), podemos obtener números específicos. En general, se podría iterar aumentando $M$ y midiendo la respuesta espectral hasta que los requisitos se satisfagan. 

A modo de **ilustración práctica**, diseñemos un filtro FIR pasa-bajos con método del ventaneo en Python, usando `scipy.signal.firwin`. Por simplicidad, tomemos $f_s=200$ Hz, $f_c=30$ Hz, y usemos ventana de Hamming:

```python
import numpy as np
from scipy import signal
fs = 200.0  # Hz
fc = 30.0   # Hz (deseamos pasa-bajos)
N = 51      # orden (se puede ajustar)
taps = signal.firwin(N, cutoff=fc, window='hamming', fs=fs)
w, H = signal.freqz(taps, worN=8000, fs=fs)
# Convertir respuesta a dB:
H_db = 20*np.log10(np.abs(H))
# Encontrar atenuación en 60 Hz:
idx_60 = np.argmin(np.abs(w-60))
print(f"Atenuación a 60Hz: {H_db[idx_60]:.2f} dB")
```

*(El código anterior calcula los coeficientes FIR con ventana de Hamming y evalúa la respuesta. Se puede iterar sobre N hasta lograr >40 dB en 80 Hz, etc.)*

En general, el método de ventanas es rápido y fácil de implementar. Su principal limitación es la falta de control preciso sobre las bandas: el ripple y transición vienen determinados por la elección de ventana, no exactamente por parámetros deseados (excepto en Kaiser donde hay más control). Aún así, es muy útil en procesamiento biomédico cuando queremos filtros lineales en fase y podemos permitir órdenes relativamente altos (el costo computacional suele ser menor preocupación en aplicaciones off-line, pero en tiempo real un FIR muy largo puede introducir latencia).

## Diseño de filtros IIR por transformación bilineal

Los filtros IIR (Respuesta Infinita al Impulso) se suelen diseñar a partir de **filtros analógicos prototipo** utilizando transformaciones como la **transformación bilineal**. Este enfoque aprovecha décadas de diseños analógicos bien estudiados (Butterworth, Chebyshev, Elíptico, etc.) y los lleva al dominio digital asegurando estabilidad y correspondiendo frecuencias de interés.

**Transformación bilineal:** Es una transformación conforme que mapea el plano-$s$ (Laplace) en el plano-$z$ (Z) mediante la sustitución: 

$$ s = \frac{2}{T}\,\frac{z-1}{\,z+1\,}, $$

donde $T$ es el periodo de muestreo (usualmente tomamos $T=1$ para frecuencias normalizadas, o usamos $2/T$ para incluir $f_s$ explícitamente) ([Transformación bilineal - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Transformaci%C3%B3n_bilineal#:~:text=Image%3A%20,1%7D%7Bz%2B1%7D%7D%5Cright%29.%5C)) ([Transformación bilineal - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Transformaci%C3%B3n_bilineal#:~:text=Un%20filtro%20causal%20perteneciente%20al,guardan%20su%20caracter%C3%ADstica%20de%20estabilidad)). Esta sustitución se adopta universalmente para convertir funciones de transferencia analógicas $H_a(s)$ en funciones $H_d(z)$ digitales ([Transformación bilineal - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Transformaci%C3%B3n_bilineal#:~:text=Image%3A%20,1%7D%7Bz%2B1%7D%7D%5Cright%29.%5C)). La clave es que la transformación bilineal **preserva la estabilidad**: polos en el semiplano izquierdo ($\Re(s)<0$) mapean dentro del círculo unitario ($|z|<1$) ([Transformación bilineal - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Transformaci%C3%B3n_bilineal#:~:text=Un%20filtro%20causal%20perteneciente%20al,guardan%20su%20caracter%C3%ADstica%20de%20estabilidad)). Así, un filtro analógico estable producirá un filtro digital estable ([Transformación bilineal - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Transformaci%C3%B3n_bilineal#:~:text=Un%20filtro%20causal%20perteneciente%20al,guardan%20su%20caracter%C3%ADstica%20de%20estabilidad)). También mapea el eje $j\omega$ (eje imaginario $s = j\Omega$) en la circunferencia unitaria ($z = e^{j\omega T}$) ([Transformación bilineal - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Transformaci%C3%B3n_bilineal#:~:text=Este%20m%C3%A9todo%20describe%20una%20forma,pertenecientes%20al%20plano%20z)), aunque **no linealmente** en frecuencia. De hecho, existe una **distorsión de la respuesta frecuencial** conocida como *warping*: la relación entre frecuencia analógica $\Omega$ y digital $\omega$ viene dada por $\omega = 2 \arctan(\Omega T/2)$ (y su inversa $\Omega = \frac{2}{T}\tan(\omega/2)$) ([Transformación bilineal - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Transformaci%C3%B3n_bilineal#:~:text=Warp%3A%20alteraci%C3%B3n%20de%20la%20respuesta,en%20frecuencia)). Esto significa que la escala de frecuencias se comprime al mapear al dominio digital, especialmente conforme $\omega$ se acerca a Nyquist ($\pi$ rad/s). 

Para lidiar con el *warping*, en el diseño se realiza una **pre-distorsión (pre-warping)** de las especificaciones. Si deseamos que una frecuencia analógica $\Omega_p$ de corte corresponda exactamente a una digital $\omega_p$, calculamos $\Omega_p = \frac{2}{T}\tan(\omega_p/2)$. Lo mismo para frecuencias de banda de rechazo, etc., antes de diseñar el filtro analógico. Luego aplicamos la transformación bilineal. En la práctica, las funciones auxiliares de diseño (como `scipy.signal.buttord`, `cheb1ord`, etc.) permiten ingresar especificaciones directamente en el dominio digital y hacen el prewarping internamente ([11.3. Common IIR filters — Digital Signals Theory](https://brianmcfee.net/dstbook-site/content/ch11-iir/IIRFilters.html#:~:text=Type,has%20as%20its%20key%20parameters)) ([11.3. Common IIR filters — Digital Signals Theory](https://brianmcfee.net/dstbook-site/content/ch11-iir/IIRFilters.html#:~:text=ripple%20%3D%203%20%20,attenuation%20in%20the%20stop%20band)).

**Prototipos analógicos comunes:** 

- **Butterworth:** Magnitud con máxima planitud en banda de paso (respuesta *maximally flat*). No presenta ondulaciones en banda de paso ni rechazo, pero la transición es la más lenta de los tipos clásicos ([11.3. Common IIR filters — Digital Signals Theory](https://brianmcfee.net/dstbook-site/content/ch11-iir/IIRFilters.html#:~:text=,band)). Su función de magnitud al cuadrado es $|H(j\Omega)|^2 = \frac{1}{1 + (\frac{\Omega}{\Omega_c})^{2N}}$. Para un orden $N$, la atenuación en rechazo aumenta gradualmente con la frecuencia. Útil cuando se quiere respuesta suave sin ripple.
- **Chebyshev Tipo I:** Presenta **rizado en banda de paso** (ε dB de variación) pero ninguna ondulación en banda de rechazo ([11.3. Common IIR filters — Digital Signals Theory](https://brianmcfee.net/dstbook-site/content/ch11-iir/IIRFilters.html#:~:text=,band)). A cambio, logra una caída más abrupta que Butterworth para el mismo orden ([11.3. Common IIR filters — Digital Signals Theory](https://brianmcfee.net/dstbook-site/content/ch11-iir/IIRFilters.html#:~:text=Type,has%20as%20its%20key%20parameters)) ([11.3. Common IIR filters — Digital Signals Theory](https://brianmcfee.net/dstbook-site/content/ch11-iir/IIRFilters.html#:~:text=after%20,fold)). La magnitud cumple $|H(j\Omega)|^2 = \frac{1}{1 + \epsilon^2 T_N^2(\Omega/\Omega_c)}$, donde $T_N$ es el polinomio de Chebyshev de primer tipo (oscila entre ±1). Permite especificar ripple tolerado en pasobanda.
- **Chebyshev Tipo II:** Lo opuesto: sin ripple en banda de paso, pero con ondulación controlada en banda de rechazo. También llamados filtros de Chebyshev inversos. Tienen una transición algo más lenta que los tipo I para igual orden, pero fase más lineal en pasobanda (al no tener ripple ahí).
- **Elíptico (Cauer):** Permite **rizado tanto en pasobanda como en rechazo** (ambos controlables) ([11.3. Common IIR filters — Digital Signals Theory](https://brianmcfee.net/dstbook-site/content/ch11-iir/IIRFilters.html#:~:text=If%20we%20allow%20ripple%20in,can%20have%20extremely%20steep%20transitions)), logrando la caída más **empinada** de todas las aproximaciones para un orden dado ([11.3. Common IIR filters — Digital Signals Theory](https://brianmcfee.net/dstbook-site/content/ch11-iir/IIRFilters.html#:~:text=Fig,distortion%20in%20the%20Elliptic%20filter)). Son los más eficientes en términos de orden, a costa de ripple en ambas bandas y mayor no linealidad de fase. Incluyen ceros de transmisión en la banda eliminada, lo que les da atenuación muy alta cerca de los bordes.

En resumen ([11.3. Common IIR filters — Digital Signals Theory](https://brianmcfee.net/dstbook-site/content/ch11-iir/IIRFilters.html#:~:text=,band)): **Butterworth** no tiene ripple en ninguna banda (pero pendiente menor), **Chebyshev I** tiene ripple en paso (no en rechazo), **Chebyshev II** ripple en rechazo (no en paso), y **Elíptico** ripple en ambas, pero transición más rápida. La **Figura 1** ilustra las diferencias de respuesta en un ejemplo práctico.

 ([image]()) **Figura 1:** Comparación de la respuesta en magnitud (en dB) para filtros IIR pasa-bajos diseñados con las mismas especificaciones (pasa-bajos con $f_{p}=3.4$ kHz con 1 dB de ripple en banda de paso, $f_{s}=3.8$ kHz con 30 dB de atenuación). El filtro **elíptico** (orden 3, línea roja) logra la transición más abrupta (caída más rápida alrededor de 3.4-3.8 kHz) a costa de presentar ondulaciones tanto en la banda de paso como en la de rechazo. El **Chebyshev I** (orden 3, línea naranja) exhibe ripple en la banda de paso pero no en la de rechazo, con una pendiente intermedia. El **Butterworth** (orden 4, línea amarilla) no tiene ripple en ninguna banda, pero requiere un orden mayor y su caída es más paulatina (transición más suave) ([11.3. Common IIR filters — Digital Signals Theory](https://brianmcfee.net/dstbook-site/content/ch11-iir/IIRFilters.html#:~:text=,band)) ([11.3. Common IIR filters — Digital Signals Theory](https://brianmcfee.net/dstbook-site/content/ch11-iir/IIRFilters.html#:~:text=Fig,distortion%20in%20the%20Elliptic%20filter)). Todos cumplen con los requisitos (–1 dB a 3.4 kHz, –30 dB a 3.8 kHz), pero el orden mínimo necesario varía (Butterworth necesitó $N=4$ mientras Chebyshev I y Elíptico lograron con $N=3$). Esto ilustra el compromiso entre pendiente de transición y ondulaciones en las distintas aproximaciones.

En diseño, elegir el tipo de filtro depende de la aplicación: en bioseñales, a veces se prefiere Butterworth para evitar cualquier ripple (ej. filtrar ECG sin distorsionar amplitud de componentes clínicas), otras veces un Chebyshev o Elíptico puede ser apropiado si se necesita un filtro muy selectivo (ej. aislar una banda muy estrecha de EEG) y se puede tolerar cierta variación en la ganancia de la banda útil. La fase de los IIR no es lineal, pero si la distorsión de fase es un problema (por ejemplo, desplazamiento o deformación de picos en ECG), puede mitigarse aplicando el filtro hacia adelante y hacia atrás (filtrado por procesamiento inverso con `filtfilt` de SciPy, logrando respuesta cero-fase a costa de procesar offline) ([](http://www.jscholaronline.org/articles/JBER/Signal-Processing.pdf#:~:text=signal%20therefore%20Finite%20Impulse%20Response,3)). En muchos casos, se pueden usar filtros IIR en tiempo real y lograr correcciones de fase si es necesario mediante técnicas de compensación o filtrado bidireccional.

**Diseño por especificaciones:** Las funciones `buttord`, `cheb1ord`, `cheb2ord`, `ellipord` de Python/MATLAB calculan el orden mínimo y frecuencia de corte necesaria para cumplir especificaciones dadas (paso, rechazo, ripple). Luego `butter`, `cheby1/2`, `ellip` generan los coeficientes. En el taller, se plantea diseñar un pasa-bajos IIR para voz (ej. telefónica: $f_s=8$ kHz, $f_p=3.4$ kHz, $f_s=3.8$ kHz, ripple 1 dB, atenuación 30 dB). Un proceso típico sería: usar `ellipord` para obtener el orden mínimo elíptico, `cheb1ord` para Chebyshev I, etc., comparar órdenes y elegir uno. En nuestro ejemplo de la Figura 1, ya vimos cómo Butterworth requería orden 4 frente a 3 de Chebyshev/Elíptico para la misma tarea, lo cual es común (Butterworth suele necesitar más orden para specs estrictas). Generalmente, **Elíptico da el menor orden**, seguido por Chebyshev, luego Butterworth ([11.3. Common IIR filters — Digital Signals Theory](https://brianmcfee.net/dstbook-site/content/ch11-iir/IIRFilters.html#:~:text=Fig,distortion%20in%20the%20Elliptic%20filter)). Sin embargo, a veces se evita Elíptico si un ripple en rechazo muy bajo es crítico (porque incluso la pequeña ondulación en banda eliminada puede ser indeseable para ciertas mediciones sensibles, aunque en la mayoría de casos biomédicos 30 dB de atenuación es suficiente sin importar un leve ripple residual). 

**Implementación en Python:** A continuación se ilustra cómo diseñar un filtro Chebyshev Tipo I con SciPy para cumplir especificaciones de voz: 

```python
import numpy as np
from scipy.signal import cheb1ord, cheby1, freqz
fs = 8000.0  # Hz
fp = 3400.0  # Hz pasabanda
fsb = 3800.0 # Hz stopband
rp = 1.0     # dB ripple paso
rs = 30.0    # dB atenuacion rechazo
N, Wn = cheb1ord(fp, fsb, rp, rs, fs=fs)  # orden y frecuencia crítica
b, a = cheby1(N, rp, Wn, btype='low', fs=fs)
w, h = freqz(b, a, worN=1024, fs=fs)
# Verificar desempeño:
H_db = 20*np.log10(np.abs(h))
print(f"Orden Chebyshev I = {N}")
print(f"Ganancia a 3.4kHz = {H_db[np.argmin(np.abs(w-3400))]:.2f} dB")
print(f"Atenuación a 3.8kHz = {H_db[np.argmin(np.abs(w-3800))]:.2f} dB")
```

*(Este código calcula el orden mínimo y coeficientes de un Chebyshev I, luego evalúa la ganancia en 3.4 kHz y 3.8 kHz para verificar que esté cerca de –1 dB y –30 dB respectivamente.)*

El resultado confirmaría el cumplimiento de especificaciones con el filtro diseñado. Del mismo modo podríamos probar `ellipord/ellip` y `buttord/butter`. Vale notar que los diseños IIR generalmente no tienen control explícito de fase lineal (la fase es no lineal e importa evaluar el impacto en la señal; a veces, se realizan calibraciones o se aplica filtrado hacia atrás como mencionado para obtener fase cero).

## Validación espectral y aplicaciones en señales biomédicas

Una vez diseñado un filtro (FIR o IIR), es crucial **validar su respuesta en frecuencia** para asegurarse de que cumple con los requisitos. Esto implica computar $H(e^{j\omega})$ – típicamente mediante `freqz` – y verificar ganancias en las bandas de paso (p.ej. pérdida de inserción o ripple) y bandas de rechazo (atenuación mínima). También se puede aplicar el filtro a señales de prueba:

- **Impulso unitario:** la salida debe ser $h[n]$ (sirve para obtener la respuesta al impulso directamente).
- **Escalón unitario:** la salida debe aproximarse a la respuesta al escalón (integral de $h[n]$), útil para verificar estabilidad (un filtro pasaaltos, por ej., a entrada escalón debería asentarse a un valor constante, indicando que DC fue removido pero no inestabilidad creciente).
- **Señal senoidal a frecuencias críticas:** por ejemplo, inyectar una senoide en la frecuencia de corte para ver si sale atenuada a ~-3 dB o -6 dB según definición; inyectar una senoide en banda eliminada para confirmar fuerte atenuación.

En contexto biomédico, se suele validar con señales reales. Por ejemplo, si diseñamos un filtro para eliminar deriva de línea base en ECG, podemos probarlo con una señal ECG con deriva artificial y comprobar que efectivamente la elimina sin distorsionar el complejo QRS.

 ([image]()) **Figura 2:** Ejemplo de filtrado de un segmento de señal ECG con un filtro pasoalto para remover la deriva de línea base. En **naranja** se muestra el ECG original contaminado con una deriva lenta (simulada como una componente de muy baja frecuencia que causa que la línea base oscile). En **amarillo** se muestra la señal tras aplicar un filtro pasaaltos Butterworth de 4° orden con $f_c \approx 0.5$ Hz (aplicado con filtrado hacia adelante y atrás para lograr fase cero). Se observa que la señal filtrada se centra alrededor de cero voltios, eliminando las variaciones lentas de la línea base, mientras preserva las características importantes del ECG (picos QRS, ondas P y T) ([](http://www.jscholaronline.org/articles/JBER/Signal-Processing.pdf#:~:text=wander%2C%20powerline%20interference%2C%20electromyo%02graphic%20,pass%20filter%20of%20an%20appropriate)). Este proceso mejora la calidad de la señal para análisis posterior (por ejemplo, facilitando la detección de eventos cardiacos), sin introducir distorsión apreciable en la forma de onda rápida del ECG.

Otro ejemplo es la eliminación de interferencia de red: un filtro notch diseñado como en secciones previas se puede aplicar a una señal EEG a la que deliberadamente se le suma un seno de 50 Hz; la validación consistiría en ver el espectro antes y después (verificando que la línea de 50 Hz desaparece tras filtrar) y que la actividad EEG en otras bandas permanece intacta.

En el diseño de filtros FIR e IIR para voz o bioseñales, a veces se comparan métodos. Por ejemplo, en el taller se pide diseñar tanto un FIR por ventana como un IIR por transformación bilineal para ciertas especificaciones. **Comparar la respuesta espectral** es instructivo: un FIR puede requerir mayor orden para lograr la misma nitidez de corte que un IIR, pero tendrá fase lineal; el IIR logrará la especificación con menos coeficientes, pero introducirá dispersión de fase. Dependiendo de la aplicación, uno u otro puede ser preferible. Estudios en filtrado de ECG han encontrado, por ejemplo, que filtros IIR y FIR bien diseñados pueden ambos remover el ruido de línea base efectivamente; los IIR (como filtros Butterworth pasaaltos) pueden ser implementados en tiempo real con pocas operaciones ([comp.dsp | How to write a NotchFilter procedure| page 2](https://www.dsprelated.com/showthread/comp.dsp/58988-2.php#:~:text=comp.dsp%20,notch%20and%20back)), mientras que FIR largos podrían introducir retardo si no se aplican con técnicas especiales. Sin embargo, los FIR lineales en fase aseguran que características como la amplitud del ST o la morfología de la onda P no se deformen ni se desplacen temporalmente, lo cual es crítico en ciertos análisis diagnósticos.

En resumen, la validación espectral (y temporal) de los filtros diseñados garantiza que el filtro funcione como esperado en las señales biomédicas objetivo. Se recomienda siempre verificar **ganancia en banda pasante** (por ej., asegurarse de que un filtro pasa-bajos no atenúe significativamente componentes importantes de la señal, salvo el ripple permitido) y **atenuación en banda eliminada** (asegurarse de que el ruido o interferencia objetivo realmente se reduce a niveles aceptables). Con herramientas como Python/Matlab, esta validación se realiza fácilmente visualizando la respuesta en frecuencia (como en las Figuras 1 y 2) y realizando pruebas con señales sintéticas o reales.

## Conclusiones

Este reporte abordó los fundamentos teóricos necesarios para analizar y diseñar sistemas discretos aplicados a señales biomédicas. Se revisó la transformada Z y su papel en caracterizar señales y sistemas LTI, destacando la importancia de la región de convergencia, polos, ceros, causalidad y estabilidad ([z transform - BIBO Stability in Z-domain - Signal Processing Stack Exchange](https://dsp.stackexchange.com/questions/53152/bibo-stability-in-z-domain#:~:text=As%20explained%20above%2C%20the%20ROC,by%20two%20or%20more%20poles)). También se discutió cómo interpretar y construir diagramas de bloques a partir de ecuaciones en diferencias, algo útil para implementar filtros digitalmente. En la parte de diseño, se cubrieron dos enfoques contrastantes: **filtros FIR por método de ventanas**, sencillos y con fase lineal (deseable en biomédica), y **filtros IIR por transformación bilineal** a partir de prototipos analógicos (eficientes en orden, aunque con fase no lineal). Se compararon los principales tipos de aproximaciones analógicas (Butterworth, Chebyshev I/II, Elíptico) resaltando sus ventajas y compromisos ([11.3. Common IIR filters — Digital Signals Theory](https://brianmcfee.net/dstbook-site/content/ch11-iir/IIRFilters.html#:~:text=,band)). 

A lo largo del documento, se enfatizó la aplicación en señales reales: eliminar deriva de línea base con pasaaltos, suprimir interferencia de red con filtros notch, limitar el ancho de banda de voz o EEG con pasabajos, etc., todo soportado por referencias académicas y ejemplos de código. En la práctica, el ingeniero biomédico debe decidir el tipo de filtro según los requisitos clínicos: por ejemplo, ¿es más importante no distorsionar la forma de onda (fase lineal) o tener un filtro muy agudo (menor orden)? Este tipo de decisiones se facilita con la comprensión profunda de los conceptos aquí explicados.

Con este marco teórico, se está en capacidad de abordar el taller propuesto: calcular transformadas Z y ROC de señales, analizar sistemas LTI (impulso, estabilidad, salida a entradas dadas), dibujar sus polos, ceros y estructuras, así como diseñar filtros FIR e IIR que satisfagan especificaciones dadas, especialmente dentro del contexto de procesamiento de señales biomédicas donde la fidelidad y eficacia del filtrado impactan directamente la calidad de la información diagnóstica obtenida.

**Referencias:** Las referencias provistas en el texto (ej.【23】,【17】,【40】) corresponden a fuentes que respaldan y complementan los puntos discutidos, incluyendo textos de procesamiento digital de señales, artículos de investigación en filtrado de ECG/EEG, y documentación de funciones de diseño de filtros. Estas fuentes ofrecen mayor detalle para el lector interesado en profundizar en aspectos específicos. En particular, se destacan obras clásicas como Oppenheim & Schafer en diseño FIR ([WindowFIRDesign.fm](https://course.ece.cmu.edu/~ece396/lectures/L19/WindowFIRDesign.pdf#:~:text=Fig,4%CF%80)), y recursos modernos como libros abiertos de señales y sistemas ([Transformada Z - Wikipedia, la enciclopedia libre](https://es.wikipedia.org/wiki/Transformada_Z#:~:text=una%20se%C3%B1al%20tiene%20una%20suma,n%7D%7D%20es%20absolutamente%20sumable)) y tutoriales de SciPy ([11.3. Common IIR filters — Digital Signals Theory](https://brianmcfee.net/dstbook-site/content/ch11-iir/IIRFilters.html#:~:text=Type,has%20as%20its%20key%20parameters)) que enriquecen la comprensión teórica y práctica del procesamiento de señales biomédicas.