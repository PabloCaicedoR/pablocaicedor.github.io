---
title: Procesamiento de Señales e Imágenes Médicas
coursecode: PSIM-80
date: 2024-10-21
year: 2024
period: 2
timeallowed: Una Hora.
openorclosed: Apuntes con caligrafía propia.
permitted: NO se permite comunciación con compañeros ni préstamo de elementos.
instructions: |
   Responda cada pregunta según las instrucciones de la sección
   
   El examen consta de un total de **50** puntos.
   
studentinfo: true
monofont: 'Source Code Pro'
monofontoptions: 
  - Scale=0.55
---

```{r}
#| echo: false
#| eval: true
#| output: false
#| label: Carga R Libraries
#| 
library("DiagrammeR")
library("reticulate")
library("kableExtra")
library("tidyverse")
library("knitr")
library("cowplot")
library("ggfx")

use_python("/usr/bin/python3.12")

knitr::opts_chunk$set(echo = FALSE)

def.chunk.hook <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
    x <- def.chunk.hook(x, options)
    ifelse(options$size != "normalsize", paste0("\n \\", options$size, "\n\n", x, "\n\n \\normalsize"), x)
})

```

```{python}
#| echo: false
#| eval: true
#| output: false
#| label: Carga Librerias
import pydicom as pyimag1
import cv2 as pyimag2
import matplotlib.pyplot as pyimag3
import numpy as pyimag4

ruta = "../../data/imagen_dicom.dcm"
angle = -45
```
     
## Sección Única. Preguntas con múltiple respuesta. (50 puntos)

Responda las preguntas, teniendo en cuenta el siguiente fragmento de código
```{python}
#| echo: true
#| eval: true
#| output: false
#| code-line-numbers: true
#| label: Primera Sección

data_imagen = pyimag1.dcmread(ruta)
image = data_imagen.pixel_array
pyimag3.imshow(image, cmap="gray")
pyimag3.axis("off")

kernel1 = (1 / 9) * pyimag4.array([[1, 1, 1], [1, 1, 1], [1, 1, 1]])
kernel2 = pyimag4.array([[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]])
conv1 = pyimag2.filter2D(image, ddepth=-1, kernel=kernel1)
conv1_normalized = pyimag2.normalize(conv1,
                        None, 
                        0, 
                        255, 
                        pyimag2.NORM_MINMAX)
conv2 = pyimag2.filter2D(image, ddepth=-1, kernel=kernel2)
conv2_normalized = pyimag2.normalize(conv2,
                        None, 
                        0, 
                        255, 
                        pyimag2.NORM_MINMAX)
rows, cols = image.shape
M = pyimag2.getRotationMatrix2D((cols//2, rows//2), angle, 1)
transformed_image = pyimag2.warpAffine(image, M, (cols, rows))
```

   #. (10 Puntos) ¿Que representa pyimag4?
      #. Representa a la librería matplotlib.
      #. Representa a la librería opencv.
      #. Representa a la librería numpy.
      #. Representa a la librería pydicom.

   #. (10 puntos) Cuál(es) de las siguientes afirmaciones es correcta. 
      #. El kernel1 es un operador de detección de bordes  
      #. El kernel2 es un operador de promedio.
      #. El kernel1 es un operador de promedio.
      #. El kernel2 es un operador de detección de bordes

   #. (10 puntos) Cuál es la función del comando pyimag2.normalize?
      #. Convierte la imagen a una resolución de bit UINT16
      #. Convierte la imagen a una resolución de bit UINT8
      #. Convierte la imagen a una resolución de bit UINT32
      #. Convierte la imagen a una resolución de bit FLOAT 
   
   #. (10 Puntos) Cuál es el valor de la variable _angle_ si *transformed_image* es la presentada en la @fig-Image01:
      #. Angle = 45
      #. Angle = -45
      #. Angle = 180
      #. Ninguna de las anteriores
```{python}
#| echo: false
#| eval: true
#| output: true
#| label: fig-Image01
pyimag3.imshow(transformed_image, cmap="gray")
pyimag3.axis("off")
```

#. (10 Puntos) ¿Cuales de las siguientes operaciones no se puede realizar con la función warpAffine
   #. Escalamiento
   #. Traslación.
   #. Convolución.
   #. Transformación Gamma.