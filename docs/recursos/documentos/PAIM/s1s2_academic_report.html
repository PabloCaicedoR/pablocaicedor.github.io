<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Experto en Procesamiento de Imágenes Médicas">
<meta name="dcterms.date" content="2026-01-19">

<title>Reporte Académico Detallado: Fundamentos y Calidad en Imagen Médica – PECR Knowledge Hub</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-573233a4bd347eedae9128c71fd62591.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../recursos/estilos/styles_site.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../.././recursos/imagenes/generales/logo.svg" alt="" class="navbar-logo light-content">
    <img src="../../.././recursos/imagenes/generales/logo.svg" alt="" class="navbar-logo dark-content">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Principal</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">Acerca de mi</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introducción" id="toc-introducción" class="nav-link active" data-scroll-target="#introducción">Introducción</a></li>
  <li><a href="#sesión-1-representación-digital-y-percepción-visual" id="toc-sesión-1-representación-digital-y-percepción-visual" class="nav-link" data-scroll-target="#sesión-1-representación-digital-y-percepción-visual">Sesión 1: Representación Digital y Percepción Visual</a>
  <ul class="collapse">
  <li><a href="#modelado-de-la-digitalización" id="toc-modelado-de-la-digitalización" class="nav-link" data-scroll-target="#modelado-de-la-digitalización">Modelado de la Digitalización</a>
  <ul class="collapse">
  <li><a href="#implementación-en-python-simulación-de-profundidad-de-bits" id="toc-implementación-en-python-simulación-de-profundidad-de-bits" class="nav-link" data-scroll-target="#implementación-en-python-simulación-de-profundidad-de-bits">Implementación en Python: Simulación de Profundidad de Bits</a></li>
  </ul></li>
  <li><a href="#espacios-de-color-en-aplicaciones-biomédicas" id="toc-espacios-de-color-en-aplicaciones-biomédicas" class="nav-link" data-scroll-target="#espacios-de-color-en-aplicaciones-biomédicas">Espacios de Color en Aplicaciones Biomédicas</a>
  <ul class="collapse">
  <li><a href="#implementación-en-python-conversión-perceptual" id="toc-implementación-en-python-conversión-perceptual" class="nav-link" data-scroll-target="#implementación-en-python-conversión-perceptual">Implementación en Python: Conversión Perceptual</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sesión-2-caracterización-de-la-calidad-en-entornos-clínicos" id="toc-sesión-2-caracterización-de-la-calidad-en-entornos-clínicos" class="nav-link" data-scroll-target="#sesión-2-caracterización-de-la-calidad-en-entornos-clínicos">Sesión 2: Caracterización de la Calidad en Entornos Clínicos</a>
  <ul class="collapse">
  <li><a href="#naturaleza-estocástica-del-ruido" id="toc-naturaleza-estocástica-del-ruido" class="nav-link" data-scroll-target="#naturaleza-estocástica-del-ruido">Naturaleza Estocástica del Ruido</a>
  <ul class="collapse">
  <li><a href="#implementación-en-python-modelado-de-ruido-clínico" id="toc-implementación-en-python-modelado-de-ruido-clínico" class="nav-link" data-scroll-target="#implementación-en-python-modelado-de-ruido-clínico">Implementación en Python: Modelado de Ruido Clínico</a></li>
  </ul></li>
  <li><a href="#métricas-de-desempeño-snr-y-cnr" id="toc-métricas-de-desempeño-snr-y-cnr" class="nav-link" data-scroll-target="#métricas-de-desempeño-snr-y-cnr">Métricas de Desempeño: SNR y CNR</a>
  <ul class="collapse">
  <li><a href="#implementación-en-python-cálculo-automático-de-métricas" id="toc-implementación-en-python-cálculo-automático-de-métricas" class="nav-link" data-scroll-target="#implementación-en-python-cálculo-automático-de-métricas">Implementación en Python: Cálculo Automático de Métricas</a></li>
  </ul></li>
  <li><a href="#resolución-espacial-y-la-mtf" id="toc-resolución-espacial-y-la-mtf" class="nav-link" data-scroll-target="#resolución-espacial-y-la-mtf">Resolución Espacial y la MTF</a>
  <ul class="collapse">
  <li><a href="#introducción-a-la-calidad-de-imagen-desde-la-frecuencia" id="toc-introducción-a-la-calidad-de-imagen-desde-la-frecuencia" class="nav-link" data-scroll-target="#introducción-a-la-calidad-de-imagen-desde-la-frecuencia">Introducción a la Calidad de Imagen desde la Frecuencia</a></li>
  <li><a href="#fundamentos-matemáticos-de-la-psf-a-la-mtf" id="toc-fundamentos-matemáticos-de-la-psf-a-la-mtf" class="nav-link" data-scroll-target="#fundamentos-matemáticos-de-la-psf-a-la-mtf">Fundamentos Matemáticos: De la PSF a la MTF</a></li>
  </ul></li>
  <li><a href="#visualización-de-la-psf-y-su-relación-con-la-resolución" id="toc-visualización-de-la-psf-y-su-relación-con-la-resolución" class="nav-link" data-scroll-target="#visualización-de-la-psf-y-su-relación-con-la-resolución">Visualización de la PSF y su relación con la resolución</a></li>
  </ul></li>
  <li><a href="#section" id="toc-section" class="nav-link" data-scroll-target="#section"></a>
  <ul class="collapse">
  <li><a href="#determinación-práctica-de-la-mtf-el-método-del-borde" id="toc-determinación-práctica-de-la-mtf-el-método-del-borde" class="nav-link" data-scroll-target="#determinación-práctica-de-la-mtf-el-método-del-borde">Determinación Práctica de la MTF: El Método del Borde</a></li>
  <li><a href="#el-proceso-de-cálculo" id="toc-el-proceso-de-cálculo" class="nav-link" data-scroll-target="#el-proceso-de-cálculo">El Proceso de Cálculo</a>
  <ul class="collapse">
  <li><a href="#implementación-en-python-cálculo-de-mtf-desde-un-borde" id="toc-implementación-en-python-cálculo-de-mtf-desde-un-borde" class="nav-link" data-scroll-target="#implementación-en-python-cálculo-de-mtf-desde-un-borde">Implementación en Python: Cálculo de MTF desde un Borde</a></li>
  </ul></li>
  <li><a href="#interpretación-clínica-de-la-curva-mtf" id="toc-interpretación-clínica-de-la-curva-mtf" class="nav-link" data-scroll-target="#interpretación-clínica-de-la-curva-mtf">Interpretación Clínica de la Curva MTF</a>
  <ul class="collapse">
  <li><a href="#aplicación-en-mamografía-vs.-tc-corporal" id="toc-aplicación-en-mamografía-vs.-tc-corporal" class="nav-link" data-scroll-target="#aplicación-en-mamografía-vs.-tc-corporal">Aplicación en Mamografía vs.&nbsp;TC Corporal</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#conclusión-de-las-sesiones-1-y-2" id="toc-conclusión-de-las-sesiones-1-y-2" class="nav-link" data-scroll-target="#conclusión-de-las-sesiones-1-y-2">Conclusión de las Sesiones 1 y 2</a></li>
  <li><a href="#referencias-académicas" id="toc-referencias-académicas" class="nav-link" data-scroll-target="#referencias-académicas">Referencias Académicas</a></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="s1s2_academic_report.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Reporte Académico Detallado: Fundamentos y Calidad en Imagen Médica</h1>
<p class="subtitle lead">Sesiones 1 y 2 - Especialización en Procesamiento Avanzado de Imágenes Médicas (PAIM)</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Experto en Procesamiento de Imágenes Médicas </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 19, 2026</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introducción" class="level1">
<h1>Introducción</h1>
<p>En el ámbito de la Ingeniería Biomédica, el procesamiento de imágenes no es simplemente una manipulación estética, sino un proceso de extracción de información biológica fidedigna. Este reporte detalla los contenidos de las sesiones 1 y 2, centrados en cómo la representación digital y las métricas de calidad impactan la interpretabilidad diagnóstica y la confiabilidad de los sistemas de Inteligencia Artificial.</p>
<hr>
</section>
<section id="sesión-1-representación-digital-y-percepción-visual" class="level1">
<h1>Sesión 1: Representación Digital y Percepción Visual</h1>
<p>La primera sesión establece el modelo matemático de la imagen y analiza cómo las limitaciones del Sistema Visual Humano (SVH) condicionan el diseño de algoritmos de procesamiento.</p>
<section id="modelado-de-la-digitalización" class="level2">
<h2 class="anchored" data-anchor-id="modelado-de-la-digitalización">Modelado de la Digitalización</h2>
<p>Una imagen médica continua <span class="math inline">\(f(x, y)\)</span> debe ser transformada en una matriz discreta <span class="math inline">\(I[m, n]\)</span>. Este proceso se divide en:</p>
<ol type="1">
<li><strong>Muestreo Espacial:</strong> Determina la resolución espacial. En radiografía digital, el tamaño del píxel suele oscilar entre 100 y 200 <span class="math inline">\(\mu m\)</span>.</li>
<li><strong>Cuantización de Intensidad:</strong> Define la resolución de contraste. Mientras que las imágenes comerciales usan 8 bits, los estándares clínicos requieren entre 12 y 16 bits para representar adecuadamente la escala de unidades Hounsfield (HU) en Tomografía o niveles de gris en Rayos X.</li>
</ol>
<section id="implementación-en-python-simulación-de-profundidad-de-bits" class="level3">
<h3 class="anchored" data-anchor-id="implementación-en-python-simulación-de-profundidad-de-bits">Implementación en Python: Simulación de Profundidad de Bits</h3>
<p>El siguiente código demuestra el efecto de la reducción de la profundidad de bits (cuantización) sobre una imagen médica, evidenciando el artefacto de “falso contorneo”.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> skimage <span class="im">import</span> data, img_as_float, color</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simulate_quantization(image, bits):</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Simula el efecto de reducir la profundidad de bits.</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    levels <span class="op">=</span> <span class="dv">2</span><span class="op">**</span>bits</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.<span class="bu">round</span>(image <span class="op">*</span> (levels <span class="op">-</span> <span class="dv">1</span>)) <span class="op">/</span> (levels <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Cargamos una imagen de prueba y la normalizamos</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> img_as_float(data.camera()) </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulamos diferentes profundidades</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>q_8bit <span class="op">=</span> simulate_quantization(image, <span class="dv">8</span>)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>q_4bit <span class="op">=</span> simulate_quantization(image, <span class="dv">4</span>)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>q_2bit <span class="op">=</span> simulate_quantization(image, <span class="dv">2</span>)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">18</span>, <span class="dv">6</span>))</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].imshow(q_8bit, cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">'Resolución Estándar (8-bit)'</span>)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].imshow(q_4bit, cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">'Cuantización 4-bit (16 niveles)'</span>)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>].imshow(q_2bit, cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>].set_title(<span class="st">'Cuantización 2-bit (4 niveles)'</span>)</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax <span class="kw">in</span> axes: ax.axis(<span class="st">'off'</span>)</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
</section>
<section id="espacios-de-color-en-aplicaciones-biomédicas" class="level2">
<h2 class="anchored" data-anchor-id="espacios-de-color-en-aplicaciones-biomédicas">Espacios de Color en Aplicaciones Biomédicas</h2>
<p>Aunque el diagnóstico radiológico es monocromático, la patología digital y la endoscopia dependen críticamente del color. El espacio RGB no es adecuado para el análisis cuantitativo debido a su falta de uniformidad perceptual. Se prefiere el espacio <strong>CIELAB</strong>, donde la luminosidad (<span class="math inline">\(L^*\)</span>) está desacoplada de la información cromática (<span class="math inline">\(a^*, b^*\)</span>).</p>
<section id="implementación-en-python-conversión-perceptual" class="level3">
<h3 class="anchored" data-anchor-id="implementación-en-python-conversión-perceptual">Implementación en Python: Conversión Perceptual</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> skimage.color <span class="im">import</span> rgb2lab, lab2rgb</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Ejemplo con imagen de retina</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>retina_rgb <span class="op">=</span> data.retina()</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>retina_lab <span class="op">=</span> rgb2lab(retina_rgb)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Extracción de componentes</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>L_channel <span class="op">=</span> retina_lab[:, :, <span class="dv">0</span>] <span class="co"># Luminosidad (información estructural)</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>plt.imshow(retina_rgb)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Imagen Original (RGB)'</span>)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>plt.imshow(L_channel, cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Componente de Luminosidad (L*)'</span>)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<hr>
</section>
</section>
</section>
<section id="sesión-2-caracterización-de-la-calidad-en-entornos-clínicos" class="level1">
<h1>Sesión 2: Caracterización de la Calidad en Entornos Clínicos</h1>
<p>La calidad de una imagen médica se define por su capacidad para permitir un diagnóstico preciso. Esto se cuantifica mediante tres pilares: Ruido, Contraste y Resolución.</p>
<section id="naturaleza-estocástica-del-ruido" class="level2">
<h2 class="anchored" data-anchor-id="naturaleza-estocástica-del-ruido">Naturaleza Estocástica del Ruido</h2>
<p>En imagenología médica, el ruido no es una señal aditiva simple; es un proceso dependiente de la física de adquisición:</p>
<ul>
<li><strong>Ruido de Poisson (Cuántico):</strong> Domina en Rayos X y TC. Surge debido a la llegada aleatoria de fotones al detector. Su varianza es proporcional a la intensidad de la señal.</li>
<li><strong>Ruido Gaussiano (Electrónico):</strong> Originado por la instrumentación del detector y la digitalización.</li>
</ul>
<section id="implementación-en-python-modelado-de-ruido-clínico" class="level3">
<h3 class="anchored" data-anchor-id="implementación-en-python-modelado-de-ruido-clínico">Implementación en Python: Modelado de Ruido Clínico</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add_poisson_noise(image):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Simula el ruido cuántico típico de adquisiciones de Rayos X.</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Ajuste de escala para simular flujo de fotones</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    peak <span class="op">=</span> <span class="dv">50</span> </span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    noisy <span class="op">=</span> np.random.poisson(image <span class="op">*</span> peak) <span class="op">/</span> peak</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.clip(noisy, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>phantom <span class="op">=</span> data.shepp_logan_phantom()</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>noisy_phantom <span class="op">=</span> add_poisson_noise(phantom)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>))</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>plt.imshow(phantom, cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Fantoma Ideal'</span>)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>plt.imshow(noisy_phantom, cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Fantoma con Ruido de Poisson (Cuántico)'</span>)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
</section>
<section id="métricas-de-desempeño-snr-y-cnr" class="level2">
<h2 class="anchored" data-anchor-id="métricas-de-desempeño-snr-y-cnr">Métricas de Desempeño: SNR y CNR</h2>
<p>Para que un algoritmo de IA o un radiólogo identifique una patología, la lesión debe ser distinguible del fondo ruidoso.</p>
<ol type="1">
<li><strong>SNR (Signal-to-Noise Ratio):</strong> Relación entre la intensidad media de la señal y la desviación estándar del ruido en una región de interés (ROI).</li>
<li><strong>CNR (Contrast-to-Noise Ratio):</strong> Evalúa la diferencia de intensidad entre dos tejidos (ej. tumor vs.&nbsp;parénquima sano) normalizada por el ruido.</li>
</ol>
<p><span class="math display">\[CNR = \frac{|\mu_{tumor} - \mu_{sano}|}{\sigma_{ruido}}\]</span></p>
<section id="implementación-en-python-cálculo-automático-de-métricas" class="level3">
<h3 class="anchored" data-anchor-id="implementación-en-python-cálculo-automático-de-métricas">Implementación en Python: Cálculo Automático de Métricas</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_metrics(img, roi_sig, roi_bg):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Calcula SNR y CNR basadas en coordenadas [y1, y2, x1, x2].</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    signal <span class="op">=</span> img[roi_sig[<span class="dv">0</span>]:roi_sig[<span class="dv">1</span>], roi_sig[<span class="dv">2</span>]:roi_sig[<span class="dv">3</span>]]</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    background <span class="op">=</span> img[roi_bg[<span class="dv">0</span>]:roi_bg[<span class="dv">1</span>], roi_bg[<span class="dv">2</span>]:roi_bg[<span class="dv">3</span>]]</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    mu_s <span class="op">=</span> np.mean(signal)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    mu_b <span class="op">=</span> np.mean(background)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    sigma_b <span class="op">=</span> np.std(background)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    snr <span class="op">=</span> mu_s <span class="op">/</span> sigma_b</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    cnr <span class="op">=</span> np.<span class="bu">abs</span>(mu_s <span class="op">-</span> mu_b) <span class="op">/</span> sigma_b</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> snr, cnr</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Definición de ROIs sobre el fantoma (ejemplo ilustrativo)</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="co"># ROI señal: elipse central; ROI fondo: área negra superior</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>snr, cnr <span class="op">=</span> get_metrics(noisy_phantom, [<span class="dv">180</span>, <span class="dv">220</span>, <span class="dv">180</span>, <span class="dv">220</span>], [<span class="dv">10</span>, <span class="dv">40</span>, <span class="dv">10</span>, <span class="dv">40</span>])</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Métricas de Calidad:</span><span class="ch">\n</span><span class="ss">SNR: </span><span class="sc">{</span>snr<span class="sc">:.4f}</span><span class="ch">\n</span><span class="ss">CNR: </span><span class="sc">{</span>cnr<span class="sc">:.4f}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
</section>
<section id="resolución-espacial-y-la-mtf" class="level2">
<h2 class="anchored" data-anchor-id="resolución-espacial-y-la-mtf">Resolución Espacial y la MTF</h2>
<section id="introducción-a-la-calidad-de-imagen-desde-la-frecuencia" class="level3">
<h3 class="anchored" data-anchor-id="introducción-a-la-calidad-de-imagen-desde-la-frecuencia">Introducción a la Calidad de Imagen desde la Frecuencia</h3>
<p>En el procesamiento avanzado de imágenes médicas (PAIM), la resolución espacial suele malinterpretarse como el simple número de píxeles o el tamaño de la matriz de adquisición. Sin embargo, para un ingeniero biomédico, la resolución es una propiedad dinámica que depende de la capacidad del sistema para transferir el contraste del objeto real a la imagen digital.</p>
<p>La <strong>Función de Transferencia de Modulación (MTF)</strong> es la métrica reina para caracterizar esta capacidad. Representa la fidelidad de un sistema de imagen en función de la frecuencia espacial, cuantificando cómo se degrada el contraste a medida que las estructuras se vuelven más pequeñas y densas.</p>
<p>Este reporte desglosa la MTF desde sus fundamentos matemáticos hasta su implementación computacional, proporcionando una visión integral esencial para el desarrollo de algoritmos de restauración e IA confiable.</p>
<hr>
</section>
<section id="fundamentos-matemáticos-de-la-psf-a-la-mtf" class="level3">
<h3 class="anchored" data-anchor-id="fundamentos-matemáticos-de-la-psf-a-la-mtf">Fundamentos Matemáticos: De la PSF a la MTF</h3>
<p>Para entender la MTF, primero debemos definir la <strong>Función de Dispersión de Punto (Point Spread Function - PSF)</strong>.</p>
<section id="la-función-de-dispersión-de-punto-psf" class="level4">
<h4 class="anchored" data-anchor-id="la-función-de-dispersión-de-punto-psf">La Función de Dispersión de Punto (PSF)</h4>
<p>Si capturamos la imagen de un punto infinitesimal (una delta de Dirac <span class="math inline">\(\delta(x, y)\)</span>), el sistema no devolverá un punto perfecto, sino una mancha borrosa debido a la difracción, el tamaño del foco en Rayos X o el movimiento del paciente. Esta mancha es la PSF.</p>
<p>Matemáticamente, la imagen <span class="math inline">\(g(x, y)\)</span> es la convolución del objeto <span class="math inline">\(f(x, y)\)</span> con la PSF <span class="math inline">\(h(x, y)\)</span>:
<span class="math display">\[g(x, y) = f(x, y) * h(x, y)\]</span></p>
</section>
<section id="la-función-de-transferencia-óptica-otf" class="level4">
<h4 class="anchored" data-anchor-id="la-función-de-transferencia-óptica-otf">La Función de Transferencia Óptica (OTF)</h4>
<p>Al aplicar la Transformada de Fourier a la PSF, pasamos del dominio espacial al dominio de la frecuencia. El resultado es la OTF:
<span class="math display">\[OTF(u, v) = \mathcal{F}\{h(x, y)\}\]</span>
Donde <span class="math inline">\((u, v)\)</span> son las frecuencias espaciales (ciclos/mm o lp/mm).</p>
</section>
<section id="definición-de-mtf" class="level4">
<h4 class="anchored" data-anchor-id="definición-de-mtf">Definición de MTF</h4>
<p>La MTF es simplemente la magnitud (módulo) de la OTF, usualmente normalizada a la unidad en frecuencia cero:
<span class="math display">\[MTF(u, v) = \frac{|OTF(u, v)|}{|OTF(0, 0)|}\]</span></p>
</section>
</section>
</section>
<section id="visualización-de-la-psf-y-su-relación-con-la-resolución" class="level2">
<h2 class="anchored" data-anchor-id="visualización-de-la-psf-y-su-relación-con-la-resolución">Visualización de la PSF y su relación con la resolución</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.fft <span class="im">import</span> fft2, fftshift</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_psf(sigma, size<span class="op">=</span><span class="dv">128</span>):</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Genera una PSF Gaussiana que simula el desenfoque del sistema."""</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.linspace(<span class="op">-</span>size<span class="op">//</span><span class="dv">2</span>, size<span class="op">//</span><span class="dv">2</span>, size)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> np.linspace(<span class="op">-</span>size<span class="op">//</span><span class="dv">2</span>, size<span class="op">//</span><span class="dv">2</span>, size)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    x, y <span class="op">=</span> np.meshgrid(x, y)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    psf <span class="op">=</span> np.exp(<span class="op">-</span>(x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> y<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> sigma<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> psf <span class="op">/</span> np.<span class="bu">sum</span>(psf)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>psf_sharp <span class="op">=</span> generate_psf(sigma<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>psf_blur <span class="op">=</span> generate_psf(sigma<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">5</span>))</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].imshow(psf_sharp, cmap<span class="op">=</span><span class="st">'hot'</span>)<span class="op">;</span> ax[<span class="dv">0</span>].set_title(<span class="st">'PSF Sistema Alta Resolución'</span>)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].imshow(psf_blur, cmap<span class="op">=</span><span class="st">'hot'</span>)<span class="op">;</span> ax[<span class="dv">1</span>].set_title(<span class="st">'PSF Sistema Baja Resolución'</span>)</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<hr>
</section>
</section>
<section id="section" class="level1">
<h1></h1>
<p>3 Cascada de Modulación: El Sistema como Filtro</p>
<p>En un entorno clínico (ej. un tomógrafo), la MTF total no depende de un solo componente, sino que es el producto de las MTF individuales de cada etapa de la cadena de adquisición:
<span class="math display">\[MTF_{total}(u) = MTF_{foco}(u) \cdot MTF_{detector}(u) \cdot MTF_{movimiento}(u) \cdot MTF_{algoritmo}(u)\]</span></p>
<p>Esta propiedad es fundamental. Si el detector tiene una resolución excelente pero el foco del tubo de Rayos X es grande, la MTF total se verá limitada por el componente más débil.</p>
<hr>
<section id="determinación-práctica-de-la-mtf-el-método-del-borde" class="level2">
<h2 class="anchored" data-anchor-id="determinación-práctica-de-la-mtf-el-método-del-borde">Determinación Práctica de la MTF: El Método del Borde</h2>
<p>Medir una PSF directamente es difícil porque no existen “puntos perfectos” en la práctica clínica. Por ello, utilizamos la <strong>Función de Respuesta al Borde (Edge Response Function - ERF)</strong>.</p>
</section>
<section id="el-proceso-de-cálculo" class="level2">
<h2 class="anchored" data-anchor-id="el-proceso-de-cálculo">El Proceso de Cálculo</h2>
<ol type="1">
<li><strong>Adquisición:</strong> Se toma la imagen de un borde afilado (ej. una placa de plomo).</li>
<li><strong>ERF:</strong> Se extrae el perfil de intensidades perpendicular al borde.</li>
<li><strong>LSF (Line Spread Function):</strong> Se deriva la ERF para obtener la respuesta a una línea.
<span class="math display">\[LSF(x) = \frac{d}{dx}ERF(x)\]</span></li>
<li><strong>MTF:</strong> Se aplica la Transformada de Fourier a la LSF.</li>
</ol>
<section id="implementación-en-python-cálculo-de-mtf-desde-un-borde" class="level3">
<h3 class="anchored" data-anchor-id="implementación-en-python-cálculo-de-mtf-desde-un-borde">Implementación en Python: Cálculo de MTF desde un Borde</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.ndimage <span class="im">import</span> gaussian_filter1d</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.fft <span class="im">import</span> fft</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_mtf_from_edge(edge_profile):</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Calcula la MTF a partir de un perfil de borde (ERF).</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. Derivada para obtener la LSF</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    lsf <span class="op">=</span> np.diff(edge_profile)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2. Ventaneo (Hanning) para reducir ruido en los extremos</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    lsf <span class="op">=</span> lsf <span class="op">*</span> np.hanning(<span class="bu">len</span>(lsf))</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 3. Transformada de Fourier</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    mtf <span class="op">=</span> np.<span class="bu">abs</span>(fft(lsf))</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 4. Normalización</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    mtf <span class="op">=</span> mtf <span class="op">/</span> mtf[<span class="dv">0</span>]</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mtf[:<span class="bu">len</span>(mtf)<span class="op">//</span><span class="dv">2</span>]</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulación de un perfil de borde con ruido</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">100</span>, <span class="dv">1000</span>)</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>erf_ideal <span class="op">=</span> np.where(x <span class="op">&lt;</span> <span class="dv">50</span>, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>erf_real <span class="op">=</span> gaussian_filter1d(erf_ideal, sigma<span class="op">=</span><span class="dv">5</span>) <span class="op">+</span> np.random.normal(<span class="dv">0</span>, <span class="fl">0.01</span>, <span class="dv">1000</span>)</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>mtf_result <span class="op">=</span> calculate_mtf_from_edge(erf_real)</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>))</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>plt.plot(mtf_result, label<span class="op">=</span><span class="st">'MTF Sistema Simulado'</span>)</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Frecuencia Espacial (unidades relativas)'</span>)</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Modulación (Contraste)'</span>)</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Curva MTF calculada vía Método del Borde'</span>)</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<hr>
</section>
</section>
<section id="interpretación-clínica-de-la-curva-mtf" class="level2">
<h2 class="anchored" data-anchor-id="interpretación-clínica-de-la-curva-mtf">Interpretación Clínica de la Curva MTF</h2>
<p>Una curva MTF se lee de la siguiente manera:</p>
<ul>
<li><strong>Frecuencia 0 (DC):</strong> Siempre es 1.0. Representa objetos infinitamente grandes donde el contraste se preserva totalmente.</li>
<li><strong>Frecuencia de Corte (<span class="math inline">\(f_c\)</span>):</strong> La frecuencia donde la MTF cae a cero. Es el límite físico de resolución.</li>
<li><strong>MTF al 50% (<span class="math inline">\(f_{50}\)</span>):</strong> Indica la frecuencia donde el sistema pierde la mitad de su contraste original. Es un buen indicador de la nitidez percibida.</li>
<li><strong>MTF al 10% (<span class="math inline">\(f_{10}\)</span>):</strong> Se considera a menudo el límite de resolución detectable por el ojo humano en condiciones clínicas.</li>
</ul>
<section id="aplicación-en-mamografía-vs.-tc-corporal" class="level3">
<h3 class="anchored" data-anchor-id="aplicación-en-mamografía-vs.-tc-corporal">Aplicación en Mamografía vs.&nbsp;TC Corporal</h3>
<p>En mamografía, donde se buscan microcalcificaciones (<span class="math inline">\(\sim 100 \mu m\)</span>), se requiere una MTF alta en frecuencias elevadas (ej. hasta 10-15 lp/mm). En un TC de abdomen, nos interesan frecuencias más bajas para distinguir órganos</p>
<hr>
</section>
</section>
</section>
<section id="conclusión-de-las-sesiones-1-y-2" class="level1">
<h1>Conclusión de las Sesiones 1 y 2</h1>
<p>El análisis de estas sesiones demuestra que el procesamiento avanzado de imágenes médicas requiere una comprensión profunda de la física subyacente. La <strong>cuantización</strong> afecta la sensibilidad del contraste, mientras que el <strong>ruido cuántico</strong> impone límites fundamentales a la detectabilidad. El uso de métricas objetivas como <strong>CNR</strong> es indispensable para validar cualquier etapa posterior de segmentación o clasificación mediante IA.</p>
</section>
<section id="referencias-académicas" class="level1">
<h1>Referencias Académicas</h1>
<ol type="1">
<li><strong>González, R. C., &amp; Woods, R. E.</strong> (2002). <em>Digital Image Processing</em>. Prentice Hall.</li>
<li><strong>Deserno, T. M.</strong> (2011). <em>Biomedical Image Processing</em>. Springer.</li>
<li><strong>Haidekker, M. A.</strong> (2011). <em>Advanced Biomedical Image Analysis</em>. John Wiley &amp; Sons.</li>
</ol>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>