<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Pablo Eduardo Caicedo Rodríguez”">
<meta name="dcterms.date" content="2025-09-23">

<title>Quantization – PECR Knowledge Hub</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-0f4abfba90e28d8cc931d883d3f444f4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../recursos/estilos/styles_site.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../.././recursos/imagenes/generales/logo.svg" alt="" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Principal</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">Acerca de mi</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Quantization</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Pablo Eduardo Caicedo Rodríguez” </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 23, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="quantization-in-digital-signal-processing-with-a-biomedical-example" class="level1">
<h1>Quantization in Digital Signal Processing (with a Biomedical Example)</h1>
<section id="purpose-and-big-picture" class="level2">
<h2 class="anchored" data-anchor-id="purpose-and-big-picture">1. Purpose and big picture</h2>
<p>Quantization maps a continuous-amplitude signal to a finite set of discrete levels so that it can be represented by digits. After anti-alias filtering and sampling, an analog-to-digital converter (ADC) applies quantization. This process introduces an error that acts like noise under standard conditions; understanding its magnitude is essential to sizing bit depth, gain, and dynamic range in biomedical systems (ECG, EEG, EMG, PPG).</p>
</section>
<section id="uniform-quantizer-model" class="level2">
<h2 class="anchored" data-anchor-id="uniform-quantizer-model">2. Uniform quantizer model</h2>
<p>Let the ADC input range be <span class="math inline">\(\left[V\_{\min},,V\_{\max}\right]\)</span> with <span class="math inline">\(b\)</span> bits and <span class="math inline">\(L=2^b\)</span> levels. The step size (LSB) is</p>
<p><span class="math display">\[
\Delta=\frac{V_{\max}-V_{\min}}{L}.
\]</span></p>
<p>Two common realizations:</p>
<ul>
<li><strong>Mid-tread (rounding)</strong>: <span class="math inline">\(Q(x)=\Delta,\mathrm{round}\left(\frac{x}{\Delta}\right)\)</span> for <span class="math inline">\(x\in(V\_{\min},V\_{\max})\)</span>.</li>
<li><strong>Mid-rise (truncate with half-step offset)</strong>: <span class="math inline">\(Q(x)=\Delta!\left(\left\lfloor\frac{x}{\Delta}\right\rfloor+\tfrac12\right)\)</span>.</li>
</ul>
<p>Outside <span class="math inline">\(\left[V\_{\min},V\_{\max}\right]\)</span>, <strong>overload/clipping</strong> occurs: <span class="math inline">\(\tilde{x}=Q(x)=V\_{\max}\)</span> if <span class="math inline">\(x&gt;V\_{\max}\)</span> and <span class="math inline">\(\tilde{x}=V\_{\min}\)</span> if <span class="math inline">\(x\&lt;V\_{\min}\)</span>.</p>
<p><strong>Codebook and decision thresholds</strong>: Decision thresholds lie at <span class="math inline">\(k\Delta\)</span> and reconstruction levels at either <span class="math inline">\(k\Delta\)</span> (mid-tread) or <span class="math inline">\((k+\tfrac12)\Delta\)</span> (mid-rise).</p>
</section>
<section id="quantization-error-and-its-statistics" class="level2">
<h2 class="anchored" data-anchor-id="quantization-error-and-its-statistics">3. Quantization error and its statistics</h2>
<p>Define the <strong>quantization error</strong> <span class="math inline">\(e=x-Q(x)\)</span>. Under the <strong>high-resolution assumptions</strong> (signal varies slowly relative to <span class="math inline">\(\Delta\)</span>, input well distributed within the range, and no overload), the error is modeled as white, signal-independent, and uniformly distributed on <span class="math inline">\(\left[-\frac{\Delta}{2},\frac{\Delta}{2}\right]\)</span>:</p>
<ul>
<li>Mean: <span class="math inline">\(\mathbb{E}\left[e\right]=0\)</span>.</li>
<li>Variance (power): <span class="math inline">\(\sigma\_e^2=\dfrac{\Delta^2}{12}\)</span>.</li>
<li>RMS: <span class="math inline">\(\sigma\_e=\dfrac{\Delta}{\sqrt{12}}\)</span>.</li>
</ul>
<p>For a full-scale sinusoid, the <strong>theoretical SNR</strong> is</p>
<p><span class="math display">\[
\mathrm{SNR}_{\mathrm{dB}}\approx 6.02\,b + 1.76.
\]</span></p>
<p>If the signal uses only a fraction <span class="math inline">\(\rho\)</span> (<span class="math inline">\(0&lt;\rho\le 1\)</span>) of full scale (FS) in RMS, then</p>
<p><span class="math display">\[
\mathrm{SNR}_{\mathrm{dB}} \approx 6.02\,b + 1.76 + 20\log_{10}(\rho).
\]</span></p>
<p><strong>Effective Number of Bits (ENOB)</strong> from a measured in-band SNR:</p>
<p><span class="math display">\[
\mathrm{ENOB} \approx \frac{\mathrm{SNR}_{\mathrm{dB}}-1.76}{6.02}.
\]</span></p>
</section>
<section id="input-range-gain-and-clipping" class="level2">
<h2 class="anchored" data-anchor-id="input-range-gain-and-clipping">4. Input range, gain, and clipping</h2>
<p>Front-end analog gain <span class="math inline">\(G\)</span> maps a biomedical signal <span class="math inline">\(x\_{\text{in}}\)</span> to the ADC: <span class="math inline">\(x\_{\text{ADC}}=G,x\_{\text{in}}\)</span>. The <strong>input-referred LSB</strong> is</p>
<p><span class="math display">\[
\Delta_{\text{in}}=\frac{\Delta}{G}.
\]</span></p>
<p>Choose <span class="math inline">\(G\)</span> to:</p>
<ol type="1">
<li>avoid overload for rare peaks, and 2) maximize FS utilization to improve SNR. Poor gain wastes bits (small <span class="math inline">\(\rho\)</span>) or clips clinically relevant transients (e.g., ECG pacer spikes).</li>
</ol>
</section>
<section id="biomedical-example-ecg-acquisition" class="level2">
<h2 class="anchored" data-anchor-id="biomedical-example-ecg-acquisition">5. Biomedical example: ECG acquisition</h2>
<p>Suppose a resting ECG has peak amplitudes around <span class="math inline">\(\pm 5,\text{mV}\)</span> at the electrodes. We design the analog front end so that <span class="math inline">\(\pm 5,\text{mV}\)</span> maps to <span class="math inline">\(\pm 1,\text{V}\)</span> at the ADC, i.e., <span class="math inline">\(G=200\)</span>. Use a <span class="math inline">\(b=12\)</span>-bit ADC over <span class="math inline">\(\left[-1,\text{V},,1,\text{V}\right]\)</span>:</p>
<ul>
<li>ADC LSB: <span class="math inline">\(\Delta = \dfrac{2,\text{V}}{2^{12}} \approx 0.488,\text{mV}\)</span> (at the ADC input).</li>
<li><strong>Input-referred LSB</strong>: <span class="math inline">\(\Delta\_{\text{in}}=\dfrac{0.488,\text{mV}}{200}\approx 2.44,\mu\text{V}\)</span>.</li>
<li><strong>Input-referred quantization-noise RMS</strong>: <span class="math inline">\(\dfrac{\Delta\_{\text{in}}}{\sqrt{12}}\approx 0.704,\mu\text{V}\_{\mathrm{RMS}}\)</span>.</li>
</ul>
<p>If the ECG uses <span class="math inline">\(\rho=0.5\)</span> of full scale (typical margin against clipping), the <strong>quantization-limited SNR</strong> is approximately</p>
<p><span class="math display">\[
\mathrm{SNR}_{\mathrm{dB}} \approx 6.02\times 12 + 1.76 + 20\log_{10}(0.5) \approx 74.0 - 6.0 \approx 68\,\text{dB}.
\]</span></p>
<p>This is usually below amplifier and electrode noise constraints, so 12 bits are adequate for diagnostic ECG in this setting. If the chain is quieter (e.g., invasive potentials), higher bit depth or larger <span class="math inline">\(G\)</span> may be justified.</p>
</section>
<section id="non-uniform-quantization-and-companding-brief" class="level2">
<h2 class="anchored" data-anchor-id="non-uniform-quantization-and-companding-brief">6. Non-uniform quantization and companding (brief)</h2>
<p>When the amplitude distribution is strongly non-uniform, <strong>companding</strong> transforms <span class="math inline">\(x\)</span> before uniform quantization to allocate more levels where the signal spends more time. Classical laws:</p>
<ul>
<li><strong><span class="math inline">\(\mu\)</span>-law</strong>: <span class="math inline">\(y=\mathrm{sgn}(x),\dfrac{\ln(1+\mu |x|/X\_{\max})}{\ln(1+\mu)}\)</span>, <span class="math inline">\(\mu\approx 255\)</span> (telephony).</li>
<li><strong><span class="math inline">\(A\)</span>-law</strong>: piecewise logarithmic with parameter <span class="math inline">\(A\)</span> (Europe).</li>
</ul>
<p>Companding is common in speech/audio telemetry; in biomedicine it is less standard for primary acquisition, but can help in low-bit-rate wireless monitoring where dynamic range is wide (e.g., PPG with motion).</p>
</section>
<section id="dither-optional-but-practical" class="level2">
<h2 class="anchored" data-anchor-id="dither-optional-but-practical">7. Dither (optional but practical)</h2>
<p>Adding small white noise (RMS <span class="math inline">\(\approx \Delta/2\)</span>) <strong>before</strong> quantization decorrelates the error from the signal, eliminating patterning and bias at low amplitudes. This linearizes averages at the cost of a small SNR penalty. Dither can be beneficial for low-level EEG/EMG features and precise baseline estimates.</p>
</section>
<section id="practical-checklist" class="level2">
<h2 class="anchored" data-anchor-id="practical-checklist">8. Practical checklist</h2>
<ul>
<li>Choose <span class="math inline">\(b\)</span> so that <span class="math inline">\(\mathrm{SNR}\_{\mathrm{dB}}\)</span> exceeds clinical SNR needs by margin (10–20 dB).</li>
<li>Set <span class="math inline">\(G\)</span> so typical peaks use <span class="math inline">\(50\)</span>–<span class="math inline">\(80%\)</span> FS; verify pacer spikes and motion spikes do not clip.</li>
<li>Budget noise: electrode + amplifier + ADC quantization; the largest non-white source often dominates.</li>
<li>Validate with a <strong>calibrated source</strong> (sinusoidal and biomedical-like waveforms) and measure in-band SNR/ENOB.</li>
</ul>
<hr>
</section>
<section id="python-demonstration-ecg-quantization-snr-and-error-statistics" class="level2">
<h2 class="anchored" data-anchor-id="python-demonstration-ecg-quantization-snr-and-error-statistics">9. Python demonstration: ECG quantization, SNR, and error statistics</h2>
<div id="0f80199d" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Synthetic ECG, uniform quantization at multiple bit depths, SNR and plots</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 1) Build a simple ECG template (P-QRS-T) using Gaussians ---</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>fs <span class="op">=</span> <span class="fl">360.0</span>                      <span class="co"># sampling rate [Hz]</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">5.0</span>                         <span class="co"># duration [s]</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.arange(<span class="dv">0</span>, T, <span class="dv">1</span><span class="op">/</span>fs)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>hr <span class="op">=</span> <span class="fl">60.0</span>                       <span class="co"># heart rate [bpm]</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>RR <span class="op">=</span> <span class="fl">60.0</span><span class="op">/</span>hr                    <span class="co"># seconds per beat</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Gaussian helper</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> g(t, mu, sigma, A):</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> A<span class="op">*</span>np.exp(<span class="op">-</span><span class="fl">0.5</span><span class="op">*</span>((t<span class="op">-</span>mu)<span class="op">/</span>sigma)<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="co"># One-beat template (times in seconds relative to beat onset)</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ecg_template(t):</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># amplitudes in mV, widths in s (very simplified)</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    P  <span class="op">=</span> g(t, <span class="fl">0.20</span>, <span class="fl">0.045</span>,  <span class="fl">0.10</span>)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    Q  <span class="op">=</span> g(t, <span class="fl">0.36</span>, <span class="fl">0.010</span>, <span class="op">-</span><span class="fl">0.25</span>)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    R  <span class="op">=</span> g(t, <span class="fl">0.40</span>, <span class="fl">0.012</span>,  <span class="fl">1.00</span>)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    S  <span class="op">=</span> g(t, <span class="fl">0.44</span>, <span class="fl">0.016</span>, <span class="op">-</span><span class="fl">0.35</span>)</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    T  <span class="op">=</span> g(t, <span class="fl">0.70</span>, <span class="fl">0.080</span>,  <span class="fl">0.30</span>)</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> P <span class="op">+</span> Q <span class="op">+</span> R <span class="op">+</span> S <span class="op">+</span> T</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Tile the template every RR seconds</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>ecg_mV <span class="op">=</span> np.zeros_like(t)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">int</span>(np.ceil(T<span class="op">/</span>RR))):</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    tau <span class="op">=</span> t <span class="op">-</span> k<span class="op">*</span>RR</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    ecg_mV <span class="op">+=</span> ecg_template(tau)</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Optional baseline wander + small EMG-like noise (for realism)</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>wander <span class="op">=</span> <span class="fl">0.05</span><span class="op">*</span>np.sin(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span><span class="fl">0.3</span><span class="op">*</span>t)        <span class="co"># 0.05 mV @ 0.3 Hz</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>noise  <span class="op">=</span> <span class="fl">0.02</span><span class="op">*</span>np.random.randn(<span class="bu">len</span>(t))      <span class="co"># 0.02 mV RMS</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>ecg_mV <span class="op">=</span> ecg_mV <span class="op">+</span> wander <span class="op">+</span> noise</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 2) Analog front-end gain and ADC setup ---</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> <span class="fl">200.0</span>                     <span class="co"># gain: mV (input) -&gt; V (ADC input)</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>Vfs <span class="op">=</span> <span class="fl">1.0</span>                     <span class="co"># full-scale = +/-1 V</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>Vmin, Vmax <span class="op">=</span> <span class="op">-</span>Vfs, Vfs</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>x_adc <span class="op">=</span> (ecg_mV<span class="op">/</span><span class="fl">1000.0</span>)<span class="op">*</span>G     <span class="co"># convert mV to V and apply gain</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> quantize_uniform(x, bits, Vmin, Vmax, mid_tread<span class="op">=</span><span class="va">True</span>):</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Saturate to avoid numeric overflow</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>    x_clip <span class="op">=</span> np.clip(x, Vmin, Vmax)</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>    L <span class="op">=</span> <span class="dv">2</span><span class="op">**</span>bits</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>    Delta <span class="op">=</span> (Vmax <span class="op">-</span> Vmin)<span class="op">/</span>L</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> mid_tread:</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> Delta<span class="op">*</span>np.<span class="bu">round</span>(x_clip<span class="op">/</span>Delta)</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> Delta<span class="op">*</span>(np.floor(x_clip<span class="op">/</span>Delta) <span class="op">+</span> <span class="fl">0.5</span>)</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> np.clip(y, Vmin, Vmax)  <span class="co"># ensure within codebook range</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> y, Delta</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> snr_db(x, y):</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>    <span class="co"># SNR over the un-clipped region; compute RMS of signal and error</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>    e <span class="op">=</span> x <span class="op">-</span> y</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Remove DC for SNR assessment</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>    x_ac <span class="op">=</span> x <span class="op">-</span> np.mean(x)</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>    e_ac <span class="op">=</span> e <span class="op">-</span> np.mean(e)</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>    Px <span class="op">=</span> np.mean(x_ac<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>    Pe <span class="op">=</span> np.mean(e_ac<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">10</span><span class="op">*</span>np.log10(Px<span class="op">/</span>Pe), e</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 3) Quantize at different bit depths ---</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>bits_list <span class="op">=</span> [<span class="dv">8</span>, <span class="dv">10</span>, <span class="dv">12</span>]</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {}</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> b <span class="kw">in</span> bits_list:</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>    y_adc, Delta <span class="op">=</span> quantize_uniform(x_adc, b, Vmin, Vmax, mid_tread<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>    snr, e <span class="op">=</span> snr_db(x_adc, y_adc)</span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>    results[b] <span class="op">=</span> <span class="bu">dict</span>(y_adc<span class="op">=</span>y_adc, Delta<span class="op">=</span>Delta, snr_db<span class="op">=</span>snr, err<span class="op">=</span>e)</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a><span class="co"># Print a small summary (ADC-domain). Input-referred values via division by G.</span></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Summary (ADC domain):"</span>)</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> b <span class="kw">in</span> bits_list:</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>    Delta <span class="op">=</span> results[b][<span class="st">"Delta"</span>]</span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>    snr <span class="op">=</span> results[b][<span class="st">"snr_db"</span>]</span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>b<span class="sc">:2d}</span><span class="ss">-bit -&gt; LSB Δ = </span><span class="sc">{</span>Delta<span class="op">*</span><span class="fl">1e3</span><span class="sc">:.3f}</span><span class="ss"> mV, Theoretical/Measured SNR ≈ </span><span class="sc">{</span>snr<span class="sc">:5.1f}</span><span class="ss"> dB"</span>)</span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a><span class="co"># Input-referred LSB and noise RMS for the 12-bit case</span></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>Delta_in <span class="op">=</span> results[<span class="dv">12</span>][<span class="st">"Delta"</span>]<span class="op">/</span>G</span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>sigma_q_in <span class="op">=</span> Delta_in<span class="op">/</span>np.sqrt(<span class="dv">12</span>)</span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Input-referred (12-bit): Δ_in = </span><span class="sc">{</span>Delta_in<span class="op">*</span><span class="fl">1e6</span><span class="sc">:.3f}</span><span class="ss"> µV, σ_q ≈ </span><span class="sc">{</span>sigma_q_in<span class="op">*</span><span class="fl">1e6</span><span class="sc">:.3f}</span><span class="ss"> µV RMS"</span>)</span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 4) Plot: original vs quantized (choose 10-bit for visibility) ---</span></span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>b_plot <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>idx <span class="op">=</span> (t <span class="op">&gt;=</span> <span class="fl">1.5</span>) <span class="op">&amp;</span> (t <span class="op">&lt;=</span> <span class="fl">2.7</span>)  <span class="co"># show about one beat</span></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>plt.figure()</span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="ss">f"ECG (ADC input) vs. </span><span class="sc">{</span>b_plot<span class="sc">}</span><span class="ss">-bit quantized"</span>)</span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a>plt.plot(t[idx], x_adc[idx], label<span class="op">=</span><span class="st">"Original (ADC input)"</span>)</span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a>plt.plot(t[idx], results[b_plot][<span class="st">"y_adc"</span>][idx], label<span class="op">=</span><span class="ss">f"</span><span class="sc">{</span>b_plot<span class="sc">}</span><span class="ss">-bit"</span>)</span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Time [s]"</span>)</span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Amplitude [V]"</span>)</span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 5) Plot: quantization error histogram (8-bit to exaggerate steps) ---</span></span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a>b_err <span class="op">=</span> <span class="dv">8</span></span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a>plt.figure()</span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="ss">f"Quantization error histogram (</span><span class="sc">{</span>b_err<span class="sc">}</span><span class="ss">-bit)"</span>)</span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a>plt.hist(results[b_err][<span class="st">"err"</span>], bins<span class="op">=</span><span class="dv">80</span>, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Error [V]"</span>)</span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"PDF estimate"</span>)</span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Summary (ADC domain):
 8-bit -&gt; LSB Δ = 7.812 mV, Theoretical/Measured SNR ≈  24.1 dB
10-bit -&gt; LSB Δ = 1.953 mV, Theoretical/Measured SNR ≈  36.0 dB
12-bit -&gt; LSB Δ = 0.488 mV, Theoretical/Measured SNR ≈  48.1 dB

Input-referred (12-bit): Δ_in = 2.441 µV, σ_q ≈ 0.705 µV RMS</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="cuantizacion_files/figure-html/cell-2-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="cuantizacion_files/figure-html/cell-2-output-3.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p><strong>Interpretation</strong></p>
<ul>
<li>The summary reports the measured SNR from the synthetic ECG after quantization for 8/10/12 bits; values will be below the <span class="math inline">\(6.02b+1.76\)</span> bound because the signal does not use full scale constantly and includes non-sinusoidal content.</li>
<li>The input-referred <span class="math inline">\(\Delta\_{\text{in}}\)</span> and <span class="math inline">\(\sigma\_q\)</span> for 12 bits match the analytical estimates in Section 5 (a few <span class="math inline">\(\mu\text{V}\)</span>), consistent with common ECG design targets.</li>
<li>The error histogram approaches a uniform distribution as assumptions hold; deviations indicate correlation (e.g., at low amplitudes or with deterministic waveforms).</li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>