<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Dr.&nbsp;Pablo Eduardo Caicedo Rodríguez">

<title>Resolución Detallada: Examen de Procesamiento de Imágenes (PSIM) – PECR Knowledge Hub</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-1d3fa2149f8108c2ed7d4d9b670d7d8b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No se han encontrado resultados",
    "search-matching-documents-text": "documentos encontrados",
    "search-copy-link-title": "Copiar el enlace en la búsqueda",
    "search-hide-matches-text": "Ocultar resultados adicionales",
    "search-more-match-text": "resultado adicional en este documento",
    "search-more-matches-text": "resultados adicionales en este documento",
    "search-clear-button-title": "Borrar",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancelar",
    "search-submit-button-title": "Enviar",
    "search-label": "Buscar"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../recursos/estilos/styles_site.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../.././recursos/imagenes/generales/logo.svg" alt="" class="navbar-logo light-content">
    <img src="../../.././recursos/imagenes/generales/logo.svg" alt="" class="navbar-logo dark-content">
    </a>
  </div>
            <div id="quarto-search" class="" title="Buscar"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Navegación de palanca" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Principal</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">Acerca de mi</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Resolución Detallada: Examen de Procesamiento de Imágenes (PSIM)</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Autor/a</div>
    <div class="quarto-title-meta-contents">
             <p>Dr.&nbsp;Pablo Eduardo Caicedo Rodríguez </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Fecha de publicación</div>
    <div class="quarto-title-meta-contents">
      <p class="date">31 de octubre de 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<style>
  body {
    font-family: 'Georgia', serif;
    line-height: 1.6;
    margin: 40px;
    background-color: #f4f4f9;
    color: #333;
  }
  .pregunta {
    background-color: #fce4ec;
    border-left: 5px solid #d81b60;
    padding: 15px;
    margin-bottom: 20px;
    border-radius: 4px;
  }
  .respuesta-correcta {
    font-weight: bold;
    color: #4a148c;
    background-color: #f3e5f5;
    padding: 5px;
    border-radius: 3px;
    display: inline-block;
  }
  .explicacion {
    margin-top: 10px;
    padding: 10px;
    border: 1px solid #e1bee7;
    border-radius: 4px;
    background-color: #ffffff;
  }
  h2 {
    color: #880e4f;
    border-bottom: 2px solid #d81b60;
    padding-bottom: 5px;
    margin-top: 30px;
  }
</style>
<section id="resolución-y-análisis-del-cuestionario-de-procesamiento-de-imágenes-psim" class="level1">
<h1>Resolución y Análisis del Cuestionario de Procesamiento de Imágenes (PSIM)</h1>
<p>Este documento contiene la resolución justificada de cada ítem del examen, enfocándose en la <strong>cuantificación</strong>, las <strong>operaciones punto a punto (pixel-wise)</strong>, el <strong>filtrado por kernel</strong>, los <strong>histogramas</strong> y los <strong>gradientes</strong> en el contexto biomédico.</p>
<hr>
<section id="pregunta-1-cuantización-y-rango-dinámico-en-radiografía-dental" class="level2">
<h2 class="anchored" data-anchor-id="pregunta-1-cuantización-y-rango-dinámico-en-radiografía-dental">Pregunta 1: Cuantización y Rango Dinámico en Radiografía Dental</h2>
<div class="pregunta">
<p><strong>Enunciado:</strong> En una radiografía dental de 12 bits se exporta por error a 8 bits antes del análisis de contraste local. ¿Cuál consecuencia técnicamente correcta describe mejor el efecto de esta cuantización sobre regiones de bajo contraste (por ejemplo, límites esmalte dentina)?</p>
</div>
<div class="respuesta-correcta">
<p>Respuesta Correcta: A</p>
</div>
<div class="explicacion">
<p><strong>Análisis Conceptual:</strong>
El cambio de <strong>12 bits</strong> (<span class="math inline">\(2^{12}=4096\)</span> niveles) a <strong>8 bits</strong> (<span class="math inline">\(2^8=256\)</span> niveles) representa una drástica reducción del número de niveles de gris disponibles. Esta operación es una <strong>cuantización destructiva</strong> en el rango de intensidad.</p>
<p><strong>Justificación Didáctica:</strong>
Una reducción en el número de bits del píxel reduce la <strong>resolución de contraste</strong> o <strong>rango dinámico útil</strong>. Las regiones de bajo contraste, como la sutil transición entre el esmalte y la dentina, dependen de pequeñas diferencias de intensidad. Al tener menos niveles disponibles, estas diferencias sutiles pueden mapearse al mismo nivel, haciéndose <strong>indiscernibles</strong>. El efecto directo es la <strong>pérdida de la capacidad de discriminar diferencias sutiles</strong> en el rango útil.</p>
</div>
<hr>
</section>
<section id="pregunta-2-operaciones-pixel-wise-y-su-efecto-en-el-histograma" class="level2">
<h2 class="anchored" data-anchor-id="pregunta-2-operaciones-pixel-wise-y-su-efecto-en-el-histograma">Pregunta 2: Operaciones Pixel-wise y su Efecto en el Histograma</h2>
<div class="pregunta">
<p><strong>Enunciado:</strong> En RM cerebral se aplica una corrección de brillo mediante operación punto a punto <span class="math inline">\(g(x,y)=f(x,y)+\beta\)</span> ¿Qué cambio esperado se observa en el histograma de intensidades?</p>
</div>
<div class="respuesta-correcta">
<p>Respuesta Correcta: B</p>
</div>
<div class="explicacion">
<p><strong>Análisis Conceptual:</strong>
La operación <span class="math inline">\(g(x,y)=f(x,y)+\beta\)</span> es una <strong>transformación lineal simple</strong> (traslación o <em>bias</em>) que se aplica a cada píxel de forma independiente (pixel-wise). Sumar una constante <span class="math inline">\(\beta\)</span> a la intensidad <span class="math inline">\(f(x,y)\)</span> de todos los píxeles no altera la relación relativa entre las intensidades; es decir, la dispersión de los datos se mantiene.</p>
<p><strong>Justificación Didáctica:</strong>
El <strong>histograma</strong> representa la distribución de las intensidades.
* La <strong>media</strong> (brillo promedio) cambia en <span class="math inline">\(\beta\)</span>. Esto se traduce en un <strong>desplazamiento del histograma</strong>.
* La <strong>varianza</strong> (dispersión de intensidades) permanece <strong>similar</strong> (si no hay saturación por el desplazamiento), ya que la distancia entre los valores de los píxeles se conserva. Por lo tanto, el histograma se desplaza, pero no se ensancha ni se comprime.</p>
</div>
<hr>
</section>
<section id="pregunta-3-ecualización-de-histograma" class="level2">
<h2 class="anchored" data-anchor-id="pregunta-3-ecualización-de-histograma">Pregunta 3: Ecualización de Histograma</h2>
<div class="pregunta">
<p><strong>Enunciado:</strong> Para mejorar el contraste en una radiografía de tórax, se considera ecualización de histograma global sobre imagen en 12 bits. ¿Cuál efecto esperado describe mejor este proceso?</p>
</div>
<div class="respuesta-correcta">
<p>Respuesta Correcta: B</p>
</div>
<div class="explicacion">
<p><strong>Análisis Conceptual:</strong>
La <strong>Ecualización de Histograma</strong> es una técnica de mejora de contraste basada en una transformación no lineal que utiliza la función de <strong>Distribución Acumulada (CDF)</strong> de las intensidades de la imagen como mapa de transformación.</p>
<p><strong>Justificación Didáctica:</strong>
El objetivo de la ecualización es forzar la función de densidad de probabilidad (PDF) de las intensidades de salida a ser lo más <strong>uniforme</strong> posible.
* Esto se logra <strong>redistribuyendo</strong> las intensidades: las regiones del histograma donde hay muchas ocurrencias (baja diferencia visual) se estiran, y las regiones donde hay pocas ocurrencias se comprimen.
* El efecto es que la imagen utiliza de forma más eficiente el <strong>rango dinámico</strong> disponible, lo que resulta en un <strong>realce del contraste global</strong>.</p>
</div>
<hr>
</section>
<section id="pregunta-4-operaciones-elemento-a-elemento-pixel-wise" class="level2">
<h2 class="anchored" data-anchor-id="pregunta-4-operaciones-elemento-a-elemento-pixel-wise">Pregunta 4: Operaciones Elemento a Elemento (Pixel-wise)</h2>
<div class="pregunta">
<p><strong>Enunciado:</strong> Se aplican operaciones elemento a elemento (pixel-wise) para corregir <em>vignetting</em> (oscurecimiento periférico por caída de iluminación hacia los bordes) en fundoscopía: <span class="math inline">\(g(x,y)=\alpha(x,y)\cdot f(x,y).\)</span> con <span class="math inline">\(\alpha(x,y)\)</span> campo de ganancia estimado. ¿Qué propiedad <strong>no</strong> es requerida para esta operación?</p>
</div>
<div class="respuesta-correcta">
<p>Respuesta Correcta: A</p>
</div>
<div class="explicacion">
<p><strong>Análisis Conceptual:</strong>
La operación <span class="math inline">\(g(x,y)=\alpha(x,y)\cdot f(x,y)\)</span> es una <strong>corrección de campo plano multiplicativa</strong>. Es una operación intrínsecamente <strong>pixel-wise</strong>.</p>
<p><strong>Justificación Didáctica:</strong>
* Las propiedades B (Definición punto a punto), C (Conocimiento de <span class="math inline">\(\alpha(x,y)\)</span>) y D (Compatibilidad de tamaño) son <strong>requisitos de implementación</strong> para realizar la multiplicación correctamente.
* <strong>A. Linealidad del operador respecto a la suma de imágenes:</strong> Si bien el operador <span class="math inline">\(T(f) = \alpha \cdot f\)</span> <em>es</em> lineal respecto a la suma de imágenes (es decir, <span class="math inline">\(T(f_1 + f_2) = T(f_1) + T(f_2)\)</span>), esta propiedad <strong>no es un requisito fundamental</strong> para la <em>ejecución</em> de una operación pixel-wise, a diferencia de los requisitos de dominio y tamaño. En el contexto de qué propiedad podría no ser estrictamente necesaria o relevante para la <em>implementación</em> misma de una corrección de campo plano multiplicativa, la linealidad se considera la menos crítica entre las opciones, ya que el foco es la acción multiplicativa local.</p>
</div>
<hr>
</section>
<section id="pregunta-5-filtrado-por-kernel-suavizado-y-preservación-de-bordes" class="level2">
<h2 class="anchored" data-anchor-id="pregunta-5-filtrado-por-kernel-suavizado-y-preservación-de-bordes">Pregunta 5: Filtrado por Kernel: Suavizado y Preservación de Bordes</h2>
<div class="pregunta">
<p><strong>Enunciado:</strong> Para atenuar ruido <em>speckle</em> en ecografía, se evalúan filtros lineales. ¿Qué combinación de kernel y tamaño ofrece la mejor relación entre suavizado y preservación de bordes en estructuras vasculares finas?</p>
</div>
<div class="respuesta-correcta">
<p>Respuesta Correcta: B</p>
</div>
<div class="explicacion">
<p><strong>Análisis Conceptual:</strong>
El ruido <em>speckle</em> es un ruido multiplicativo presente en imágenes de coherencia (como ecografía). Un filtro de suavizado lineal, como el <strong>Gaussiano</strong>, es un buen punto de partida para su atenuación, ya que suaviza el ruido sin introducir artefactos de bloque.</p>
<p><strong>Justificación Didáctica:</strong>
Para lograr la <strong>mejor relación entre suavizado y preservación de bordes finos</strong>, se requiere un equilibrio:
* El suavizado requiere un <span class="math inline">\(\sigma\)</span> y un tamaño de ventana adecuados.
* Los <strong>bordes finos</strong> (estructuras vasculares) se desenfocan si el kernel es demasiado grande o <span class="math inline">\(\sigma\)</span> es muy alto (como en C y A).
* Un <strong>filtro Gaussiano <span class="math inline">\(3\times3\)</span> con <span class="math inline">\(\sigma=1\)</span></strong> proporciona un <strong>suavizado ligero y localizado</strong>. Esto es suficiente para reducir el impacto del <em>speckle</em> minimizando el desenfoque lateral, lo que es crucial para mantener la nitidez y la localización de las estructuras finas. La opción D (Mediana) es mejor para ruido impulsivo y distorsiona la forma de onda del <em>speckle</em> de forma diferente.</p>
</div>
<hr>
</section>
<section id="pregunta-6-detección-de-bordes-módulo-del-gradiente-sobel" class="level2">
<h2 class="anchored" data-anchor-id="pregunta-6-detección-de-bordes-módulo-del-gradiente-sobel">Pregunta 6: Detección de Bordes: Módulo del Gradiente (Sobel)</h2>
<div class="pregunta">
<p><strong>Enunciado:</strong> Para la detección de bordes en angiografía (DSA), se aplican gradientes con Sobel. ¿Cuál afirmación es correcta sobre el módulo del gradiente <span class="math inline">\(|| \nabla f ||\)</span> obtenido con Sobel?</p>
</div>
<div class="respuesta-correcta">
<p>Respuesta Correcta: B</p>
</div>
<div class="explicacion">
<p><strong>Análisis Conceptual:</strong>
El operador <strong>Sobel</strong> es un operador basado en la <strong>convolución</strong> que calcula la magnitud del vector gradiente de la intensidad de la imagen. El gradiente es un vector que apunta en la dirección de máximo cambio de intensidad y cuya magnitud <span class="math inline">\(|| \nabla f ||\)</span> es la tasa de ese cambio.</p>
<p><strong>Justificación Didáctica:</strong>
* El módulo del gradiente <strong>aproxima derivadas parciales</strong> <span class="math inline">\((\partial f / \partial x, \partial f / \partial y)\)</span> utilizando <strong>máscaras discretas</strong> (<span class="math inline">\(G_x\)</span> y <span class="math inline">\(G_y\)</span>).
* El resultado es una imagen donde la intensidad del píxel es proporcional a la magnitud de la transición de intensidad en ese punto, lo que efectivamente <strong>resalta las transiciones</strong> (bordes).
* La opción A es incorrecta porque el gradiente <strong>no es invariante ante cambios de escala de intensidad</strong>; si <span class="math inline">\(f\)</span> se multiplica por <span class="math inline">\(k\)</span>, el gradiente también se multiplica por <span class="math inline">\(k\)</span>.
* La opción D es incorrecta: la derivada (gradiente) <strong>amplifica el ruido</strong> de alta frecuencia, por lo que el suavizado previo es casi siempre necesario.</p>
</div>
<hr>
</section>
<section id="pregunta-7-realce-de-bordes-kernel-laplaciano-y-riesgo" class="level2">
<h2 class="anchored" data-anchor-id="pregunta-7-realce-de-bordes-kernel-laplaciano-y-riesgo">Pregunta 7: Realce de Bordes: Kernel Laplaciano y Riesgo</h2>
<div class="pregunta">
<p><strong>Enunciado:</strong> En mamografía digital, se considera una convolución con kernel de realce de bordes (tipo Laplaciano) seguida de umbralización adaptativa. ¿Cuál riesgo técnico es más relevante si el kernel no está adecuadamente normalizado/compensado?</p>
</div>
<div class="respuesta-correcta">
<p>Respuesta Correcta: A</p>
</div>
<div class="explicacion">
<p><strong>Análisis Conceptual:</strong>
Los filtros Laplacianos son operadores de segunda derivada, que actúan como <strong>filtros pasa-altos</strong>. El resultado de la convolución Laplaciana se usa generalmente para detectar cambios rápidos de intensidad (bordes) o para sumar a la imagen original (máscara de enfoque).</p>
<p><strong>Justificación Didáctica:</strong>
Como filtros pasa-altos, los Laplacianos amplifican las altas frecuencias. Si el kernel de realce no está diseñado cuidadosamente (no compensado o normalizado), su efecto será doblemente perjudicial:
1. <strong>Generación de artefactos de sobre-realce (overshoot):</strong> Crea efectos de halos o anillos artificiales alrededor de los bordes.
2. <strong>Amplificación del ruido:</strong> El ruido (siempre considerado alta frecuencia) se amplifica junto con los bordes, lo que <strong>disminuye la relación señal-ruido</strong> y puede oscurecer detalles diagnósticos sutiles.
El riesgo más relevante es la <strong>amplificación de ruido de alta frecuencia</strong> y la introducción de <strong>artefactos de sobre-realce</strong>.</p>
</div>
<hr>
</section>
<section id="pregunta-8-preprocesamiento-para-detección-de-bordes" class="level2">
<h2 class="anchored" data-anchor-id="pregunta-8-preprocesamiento-para-detección-de-bordes">Pregunta 8: Preprocesamiento para Detección de Bordes</h2>
<div class="pregunta">
<p><strong>Enunciado:</strong> En RM ponderada en T1, antes de aplicar operadores de gradiente (Sobel/Prewitt) para detección de bordes, se decide un preprocesamiento mínimo. ¿Cuál opción mejora la robustez de la detección sin sacrificar en exceso la localización del borde?</p>
</div>
<div class="respuesta-correcta">
<p>Respuesta Correcta: A</p>
</div>
<div class="explicacion">
<p><strong>Análisis Conceptual:</strong>
La operación de detección de bordes por gradiente es un proceso inherentemente susceptible al ruido. Un paso previo de <strong>suavizado</strong> es obligatorio para aumentar la <strong>robustez</strong> de la detección.</p>
<p><strong>Justificación Didáctica:</strong>
* El <strong>Suavizado Gaussiano</strong> es el método de suavizado preferido en el procesamiento de imágenes por sus propiedades de separación y por ser el único kernel que es localmente invariante ante la escala de brillo.
* Para <strong>reducir el impacto del ruido</strong> (robustez) sin <strong>sacrificar en exceso la localización del borde</strong>, se requiere un suavizado <strong>ligero</strong> (<span class="math inline">\(\sigma \approx 1\)</span>). Esto cumple con el requisito de ser un <strong>preprocesamiento mínimo</strong> efectivo.
* Las opciones B, C y D son subóptimas: C (Promedio <span class="math inline">\(7\times7\)</span>) sacrifica excesivamente la localización; D (Aumento de nitidez) amplificaría el ruido; y B (Ecualización) es un cambio de contraste global que no es necesario para el gradiente y no está directamente relacionado con la reducción de ruido.</p>
</div>
</section>
</section>
<section id="resolución-y-análisis-del-cuestionario-de-procesamiento-de-imágenes-psim---ii" class="level1">
<h1>Resolución y Análisis del Cuestionario de Procesamiento de Imágenes (PSIM) - II</h1>
<p>Este documento presenta la resolución justificada de cada pregunta, enfocándose en la interacción de operaciones básicas (cuantización, transformaciones afines, histogramas) y kernels (suavizado, gradientes) en el contexto de imágenes biomédicas.</p>
<hr>
<section id="pregunta-1-cuantización-irreversible-y-reescalado" class="level2">
<h2 class="anchored" data-anchor-id="pregunta-1-cuantización-irreversible-y-reescalado">Pregunta 1: Cuantización Irreversible y Reescalado</h2>
<div class="pregunta">
<p><strong>Enunciado:</strong> Una radiografía dental (12 bits) se cuantiza a 8 bits y luego se reescala linealmente para ocupar <span class="math inline">\([0, 255]\)</span> antes del análisis de bordes. ¿Qué enunciado describe mejor el impacto final sobre la detectabilidad de límites esmalte dentina?</p>
</div>
<div class="respuesta-correcta">
<p>Respuesta Correcta: B</p>
</div>
<div class="explicacion">
<p><strong>Análisis Conceptual:</strong>
La <strong>cuantización</strong> de 12 bits (<span class="math inline">\(4096\)</span> niveles) a 8 bits (<span class="math inline">\(256\)</span> niveles) es una operación <strong>irreversible</strong>. Esto significa que las diferencias sutiles de intensidad (bajo contraste) que se podían distinguir con 12 bits se agrupan en un solo nivel en 8 bits, perdiendo la información original.</p>
<p><strong>Justificación Didáctica:</strong>
El <strong>reescalado lineal</strong> posterior simplemente toma los <span class="math inline">\(256\)</span> valores existentes y los expande para ocupar el nuevo rango <span class="math inline">\([0, 255]\)</span>. Esta operación <strong>no puede restituir la información de contraste</strong> que se perdió en la reducción inicial de bits. La discriminación sutil de los límites esmalte-dentina, vital en las radiografías dentales, permanece degradada.</p>
</div>
<hr>
</section>
<section id="pregunta-2-transformación-afín-y-efecto-en-el-histograma" class="level2">
<h2 class="anchored" data-anchor-id="pregunta-2-transformación-afín-y-efecto-en-el-histograma">Pregunta 2: Transformación Afín y Efecto en el Histograma</h2>
<div class="pregunta">
<p><strong>Enunciado:</strong> En resonancia magnética cerebral, se aplica <span class="math inline">\(g(x,y)=\alpha f(x,y)+\beta\)</span> con <span class="math inline">\(\alpha&gt;1\)</span> y <span class="math inline">\(\beta&lt;0\)</span> para optimizar contraste. ¿Qué efecto esperado tiene sobre el histograma?</p>
</div>
<div class="respuesta-correcta">
<p>Respuesta Correcta: D</p>
</div>
<div class="explicacion">
<p><strong>Análisis Conceptual:</strong>
La operación <span class="math inline">\(g(x,y)=\alpha f(x,y)+\beta\)</span> es una <strong>transformación afín</strong> que afecta tanto el brillo como el contraste:
1. <strong>Multiplicación por <span class="math inline">\(\alpha\)</span> (<span class="math inline">\(\alpha&gt;1\)</span>):</strong> Esto es una <strong>expansión de contraste</strong> (o estiramiento del rango), lo que <strong>aumenta la varianza</strong>.
2. <strong>Suma de <span class="math inline">\(\beta\)</span> (<span class="math inline">\(\beta&lt;0\)</span>):</strong> Esto es una <strong>disminución de brillo</strong>, lo que <strong>desplaza la media a valores menores</strong>.</p>
<p><strong>Justificación Didáctica:</strong>
El efecto combinado es: <strong>aumentar la dispersión</strong> (mayor varianza) y <strong>mover la distribución a la izquierda</strong> (menor media).</p>
</div>
<hr>
</section>
<section id="pregunta-3-realce-de-bordes-por-resta-unsharp-masking" class="level2">
<h2 class="anchored" data-anchor-id="pregunta-3-realce-de-bordes-por-resta-unsharp-masking">Pregunta 3: Realce de Bordes por Resta (Unsharp Masking)</h2>
<div class="pregunta">
<p><strong>Enunciado:</strong> En angiografía por sustracción digital, se emplea un esquema de realce por resta de una versión suavizada de la imagen: (i) suavizado gaussiano, (ii) diferencia <span class="math inline">\((f-\bar{f})\)</span>, (iii) combinación <span class="math inline">\((f+k(f-\bar{f}))\)</span>. Al incrementar <span class="math inline">\((k)\)</span> para resaltar vasos finos, ¿cuál compromiso y mitigación son correctos?</p>
</div>
<div class="respuesta-correcta">
<p>Respuesta Correcta: B</p>
</div>
<div class="explicacion">
<p><strong>Análisis Conceptual:</strong>
Este esquema es la técnica de <strong>Máscara de Enfoque</strong> (<em>Unsharp Masking</em>). El factor <span class="math inline">\(k\)</span> controla la agresividad del realce de las altas frecuencias (<span class="math inline">\((f-\bar{f})\)</span>).</p>
<p><strong>Justificación Didáctica:</strong>
* Un <span class="math inline">\(k\)</span> mayor amplifica las altas frecuencias, lo que incluye tanto los <strong>bordes finos</strong> como el <strong>ruido</strong>.
* El riesgo es la aparición de <strong>oscilaciones indeseadas</strong> (<em>ringing</em> o <em>overshoot</em>) cerca de los bordes y la <strong>amplificación del ruido de alta frecuencia</strong>.
* La mitigación correcta para contrarrestar este efecto es aplicar un <strong>suavizado previo ligero</strong> a la imagen original (<span class="math inline">\(f\)</span>) antes de calcular la máscara, para atenuar el ruido sin perder los detalles de los vasos finos.</p>
</div>
<hr>
</section>
<section id="pregunta-4-ecualización-global-del-histograma" class="level2">
<h2 class="anchored" data-anchor-id="pregunta-4-ecualización-global-del-histograma">Pregunta 4: Ecualización Global del Histograma</h2>
<div class="pregunta">
<p><strong>Enunciado:</strong> En radiografía de tórax, la ecualización global del histograma puede:</p>
</div>
<div class="respuesta-correcta">
<p>Respuesta Correcta: A</p>
</div>
<div class="explicacion">
<p><strong>Análisis Conceptual:</strong>
La <strong>Ecualización de Histograma</strong> transforma la función de densidad de probabilidad para hacerla más uniforme.</p>
<p><strong>Justificación Didáctica:</strong>
* El proceso <strong>uniforma la ocupación del rango dinámico</strong> y <strong>realza el contraste</strong> en regiones agrupadas.
* Sin embargo, al estirar las regiones homogéneas (baja varianza) del histograma, las pequeñas variaciones de intensidad (ruido) en esas regiones se separan y se hacen más evidentes. Por lo tanto, la ecualización <strong>incrementa el ruido percibido en regiones homogéneas</strong>.</p>
</div>
<hr>
</section>
<section id="pregunta-5-operaciones-pixel-wise-corrección-multiplicativa" class="level2">
<h2 class="anchored" data-anchor-id="pregunta-5-operaciones-pixel-wise-corrección-multiplicativa">Pregunta 5: Operaciones Pixel-wise: Corrección Multiplicativa</h2>
<div class="pregunta">
<p><strong>Enunciado:</strong> Para <em>vignetting</em> (oscurecimiento periférico por caída de iluminación hacia los bordes) en fundoscopía, se estima <span class="math inline">\(\alpha(x,y)\)</span> mediante campo plano y se corrige <span class="math inline">\(g(x,y)=\alpha f(x,y)\)</span>. ¿Qué afirmación es correcta?</p>
</div>
<div class="respuesta-correcta">
<p>Respuesta Correcta: B</p>
</div>
<div class="explicacion">
<p><strong>Análisis Conceptual:</strong>
La corrección de <em>vignetting</em> es una <strong>corrección de campo plano</strong>. El <em>vignetting</em> es un <strong>sesgo multiplicativo</strong>.</p>
<p><strong>Justificación Didáctica:</strong>
La mejor práctica para la corrección es estimar el factor de iluminación (<span class="math inline">\(\alpha(x,y)\)</span>) capturando un campo plano bajo <strong>condiciones de adquisición similares</strong> a las de la imagen real. Esta estimación es la base para corregir el <strong>sesgo multiplicativo</strong> impuesto por el sistema óptico de la fundoscopía. La corrección es multiplicativa (no aditiva) y la compatibilidad de tamaño de <span class="math inline">\(\alpha\)</span> y <span class="math inline">\(f\)</span> es crucial.</p>
</div>
<hr>
</section>
<section id="pregunta-6-filtrado-compromiso-srn-y-costo-computacional-x2-puntos" class="level2">
<h2 class="anchored" data-anchor-id="pregunta-6-filtrado-compromiso-srn-y-costo-computacional-x2-puntos">Pregunta 6: Filtrado: Compromiso SRN y Costo Computacional (x2 puntos)</h2>
<div class="pregunta">
<p><strong>Enunciado:</strong> Para suprimir ruido granular característico de la ecografía en tiempo real, se requiere un buen compromiso entre relación señal-ruido (SRN) y costo computacional. ¿Qué opción es más adecuada?</p>
</div>
<div class="respuesta-correcta">
<p>Respuesta Correcta: C</p>
</div>
<div class="explicacion">
<p><strong>Análisis Conceptual:</strong>
El objetivo es maximizar la <strong>eficiencia computacional</strong> (necesaria para el tiempo real) manteniendo un buen <strong>suavizado</strong>. El costo de una convolución <span class="math inline">\(N\times N\)</span> es <span class="math inline">\(O(N^2)\)</span>.</p>
<p><strong>Justificación Didáctica:</strong>
El filtro <strong>Gaussiano es separable</strong>. Esto permite descomponer una convolución <span class="math inline">\(N\times N\)</span> en dos convoluciones, una <span class="math inline">\(N\times 1\)</span> y otra <span class="math inline">\(1\times N\)</span>, reduciendo el costo de <span class="math inline">\(O(N^2)\)</span> a <span class="math inline">\(O(2N)\)</span>. Aplicar un <strong>Gaussiano separable <span class="math inline">\(3\times3\)</span> dos veces</strong> (o incluso un kernel mayor) es una técnica altamente eficiente. Un <span class="math inline">\(3\times3\)</span> separable tiene un costo muy bajo (<span class="math inline">\(O(6)\)</span>) en comparación con un <span class="math inline">\(9\times9\)</span> no separable (<span class="math inline">\(O(81)\)</span>), ofreciendo un <strong>excelente compromiso costo-SRN</strong> para procesamiento en tiempo real.</p>
</div>
<hr>
</section>
<section id="pregunta-7-gradientes-comparación-sobel-vs.-prewitt" class="level2">
<h2 class="anchored" data-anchor-id="pregunta-7-gradientes-comparación-sobel-vs.-prewitt">Pregunta 7: Gradientes: Comparación Sobel vs.&nbsp;Prewitt</h2>
<div class="pregunta">
<p><strong>Enunciado:</strong> Sobre gradientes: comparación entre Sobel y Prewitt en imágenes ruidosas (angiografía). ¿Qué enunciado es correcto?</p>
</div>
<div class="respuesta-correcta">
<p>Respuesta Correcta: D</p>
</div>
<div class="explicacion">
<p><strong>Análisis Conceptual:</strong>
Tanto Sobel como Prewitt son operadores de gradiente que usan máscaras <span class="math inline">\(3\times3\)</span> para aproximar las derivadas parciales. Sobel difiere en que pondera los píxeles adyacentes a la dirección de la derivada.</p>
<p><strong>Justificación Didáctica:</strong>
La máscara de <strong>Sobel incorpora una ponderación central (factor de 2)</strong> que actúa efectivamente como un <strong>suavizado leve</strong> en la dirección perpendicular al borde. Dado que el ruido es amplificado por la derivación, este suavizado inherente hace que <strong>Sobel sea ligeramente más robusto al ruido</strong> en comparación con Prewitt, cuya máscara es uniforme.</p>
</div>
<hr>
</section>
<section id="pregunta-8-kernel-laplaciano-no-normalizado" class="level2">
<h2 class="anchored" data-anchor-id="pregunta-8-kernel-laplaciano-no-normalizado">Pregunta 8: Kernel Laplaciano No Normalizado</h2>
<div class="pregunta">
<p><strong>Enunciado:</strong> En mamografía, se aplica un kernel de realce de bordes de segunda derivada (tipo Laplaciano) seguido de umbral adaptativo. Si el kernel no está normalizado (suma distinta de 0) ni compensado, el riesgo principal es:</p>
</div>
<div class="respuesta-correcta">
<p>Respuesta Correcta: A</p>
</div>
<div class="explicacion">
<p><strong>Análisis Conceptual:</strong>
Los filtros de realce de bordes (pasa-altos) amplifican el ruido de alta frecuencia junto con los detalles finos (bordes).</p>
<p><strong>Justificación Didáctica:</strong>
Si el kernel de realce es excesivamente agresivo o no está correctamente diseñado, la <strong>amplificación del ruido</strong> puede hacer que las variaciones aleatorias de intensidad (ruido) superen el umbral adaptativo. Esto lleva a una alta tasa de <strong>falsos positivos</strong> (detección de puntos de ruido como estructuras) y a un <strong>realce excesivo</strong> (<em>overshoot</em> o <em>ringing</em>) en los bordes legítimos.</p>
</div>
<hr>
</section>
<section id="pregunta-9-detección-de-bordes-suavizado-gaussiano-y-sigma" class="level2">
<h2 class="anchored" data-anchor-id="pregunta-9-detección-de-bordes-suavizado-gaussiano-y-sigma">Pregunta 9: Detección de Bordes: Suavizado Gaussiano y <span class="math inline">\(\sigma\)</span></h2>
<div class="pregunta">
<p><strong>Enunciado:</strong> En resonancia magnética ponderada en T1, se desea robustecer la detección de bordes finos con operadores de gradiente sin deslocalizar bordes. Se dispone de suavizado gaussiano con <span class="math inline">\(\sigma \in \{0.5, 1.0, 2.0\}\)</span>. ¿Qué estrategia es más adecuada?</p>
</div>
<div class="respuesta-correcta">
<p>Respuesta Correcta: A</p>
</div>
<div class="explicacion">
<p><strong>Análisis Conceptual:</strong>
Para la detección de bordes, <span class="math inline">\(\sigma\)</span> controla el balance entre <strong>robustez</strong> (mayor <span class="math inline">\(\sigma\)</span>, mejor rechazo de ruido) y <strong>localización</strong> (menor <span class="math inline">\(\sigma\)</span>, borde más preciso).</p>
<p><strong>Justificación Didáctica:</strong>
La <strong>detección de bordes finos sin deslocalización</strong> exige un compromiso. La estrategia más sofisticada y efectiva es la <strong>multiescala</strong>:
* Se prueban múltiples valores de <span class="math inline">\(\sigma\)</span> (e.g., <span class="math inline">\(0.5\)</span> y <span class="math inline">\(1.0\)</span>).
* Se selecciona el resultado que ofrece un <strong>pico de gradiente máximo estable</strong>. Esto permite al algoritmo adaptarse a la escala de los bordes, logrando una <strong>detección robusta</strong> frente al ruido de la RM sin sacrificar la precisión de la localización. Usar un <span class="math inline">\(\sigma\)</span> grande (2.0) deslocalizaría los bordes finos.</p>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copiado");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copiado");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>