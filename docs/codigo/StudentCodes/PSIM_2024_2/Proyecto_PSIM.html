<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>DETECCIÓN DE LA LEUCEMIA LINFOBLÁSTICA AGUDA – PECR Knowledge Hub</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-c40e139f9c4114c612eb61de435499b9.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../recursos/estilos/styles_site.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../.././recursos/imagenes/generales/logo.svg" alt="" class="navbar-logo light-content">
    <img src="../../.././recursos/imagenes/generales/logo.svg" alt="" class="navbar-logo dark-content">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Principal</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">Acerca de mi</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">DETECCIÓN DE LA LEUCEMIA LINFOBLÁSTICA AGUDA</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>La leucemia linfoblástica aguda (LLA) es un tipo de cáncer hematológico caracterizado por la proliferación descontrolada de linfoblastos inmaduros en la médula ósea, la sangre y otros órganos. Este trastorno impide la producción adecuada de células sanguíneas normales, lo que provoca síntomas como anemia, infecciones recurrentes y sangrados anormales. [1]</p>
<p>El cáncer es una de las principales causas de mortalidad entre niños y adolescentes en todo el mundo; cada año se diagnostica cáncer a aproximadamente 274.000 niños de entre 0 y 19 años. [2]</p>
<p>En América Latina y el Caribe, se estima que alrededor de 30.000 niñas, niños y adolescentes menores de 19 años resultarán afectados por el cáncer anualmente. De ellos, casi 10.000 fallecerán a causa de esta enfermedad.
En los países de ingresos altos, más del 80% de los niños afectados de cáncer se curan, pero en muchos países de ingresos medianos y bajos la tasa de curación es de aproximadamente el 20%.[3]</p>
<p>Las defunciones evitables debidas a los cánceres infantiles en los países de ingresos medianos y bajos se producen a consecuencia de la falta de diagnóstico, los diagnósticos incorrectos o tardíos, las dificultades para acceder a la atención sanitaria, el abandono del tratamiento, la muerte por toxicidad y las mayores tasas de recidivas. [3]</p>
<section id="frotis-de-sangre" class="level1">
<h1>Frotis de Sangre</h1>
<p>Un frotis de sangre es una prueba de laboratorio que se utiliza para examinar las células sanguíneas bajo un microscopio. Consiste en tomar una pequeña muestra de sangre del paciente, extenderla sobre un portaobjetos y luego teñirla con colorantes especiales para poder visualizar las diferentes células sanguíneas (glóbulos rojos, glóbulos blancos y plaquetas) y observar cualquier anomalía en su forma, tamaño o cantidad.</p>
</section>
<section id="obejtivos-del-proyecto" class="level1">
<h1>OBEJTIVOS DEL PROYECTO</h1>
<ol type="1">
<li><p>Explorar y comprender el dataset: Obtener una visión general del dataset de imágenes de frotis de sangre, incluyendo el número de imágenes, las clases disponibles (sano, leucemia), y el preprocesamiento necesario.</p></li>
<li><p>Preprocesamiento de imágenes: Aplicar técnicas de procesamiento de imágenes para preparar los datos para el modelo de regresión logística, como:
Conversión de imágenes a escala de grises.
Reducción de ruido y mejora de la calidad de las imágenes.
Normalización de los valores de píxeles.</p></li>
<li><p>Extracción de características relevantes: Identificar características importantes de las imágenes de frotis de sangre que puedan ayudar en la clasificación de leucemia, como texturas, formas celulares y patrones visuales.</p></li>
<li><p>Implementación del modelo de regresión logística: Desarrollar un modelo de regresión logística para la clasificación binaria (leucemia vs.&nbsp;sano) utilizando las características extraídas.</p></li>
<li><p>Entrenamiento y evaluación del modelo: Dividir el dataset en conjuntos de entrenamiento y prueba, entrenar el modelo de regresión logística y evaluar su desempeño usando métricas como precisión, recall, F1-score y la matriz de confusión.</p></li>
<li><p>Optimización del modelo: Ajustar los hiperparámetros del modelo de regresión logística para mejorar su rendimiento.</p></li>
<li><p>Visualización de resultados: Crear gráficas y visualizaciones para mostrar los resultados del modelo, como las curvas ROC y las predicciones de clasificación sobre imágenes de prueba.</p></li>
<li><p>Análisis de errores y mejora del modelo: Analizar los errores del modelo y explorar posibles mejoras, como el ajuste de características o la inclusión de más datos de entrenamiento.</p></li>
<li><p>Documentación y presentación de resultados: Redactar un informe detallado que explique el proceso, las técnicas utilizadas, los resultados obtenidos y las conclusiones.</p></li>
</ol>
<div id="cell-4" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-outputid="d632653c-9ab0-4c9c-f323-d96a97252833" data-execution_count="1">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> google.colab <span class="im">import</span> drive</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cv2</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>drive.mount(<span class="st">'/content/drive'</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Mounted at /content/drive</code></pre>
</div>
</div>
<div id="cell-5" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:1000}}" data-outputid="0f89ceec-80f0-4bd7-f5e7-8e2756a9f725" data-execution_count="2">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># **1. Cargar Datos Iniciales y Preprocesar**</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Carga los datos de los resultados de células sanas y con leucemia.</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>df_sanas <span class="op">=</span> pd.read_csv(<span class="st">'resultados_celulas_sanas.csv'</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>df_leucemia <span class="op">=</span> pd.read_csv(<span class="st">'resultados_celulas_leucemia.csv'</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Etiquetar las células sanas con 0 y las de leucemia con 1.</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>df_sanas[<span class="st">'Etiqueta'</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>df_leucemia[<span class="st">'Etiqueta'</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Combinar ambos datasets en uno solo.</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>df_combinado <span class="op">=</span> pd.concat([df_sanas, df_leucemia])</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Seleccionar las características y la etiqueta objetivo.</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> df_combinado[[<span class="st">'Número de Células'</span>, <span class="st">'Área Promedio'</span>, <span class="st">'Área Total'</span>, <span class="st">'Intensidad Promedio (Grises)'</span>]].values</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> df_combinado[<span class="st">'Etiqueta'</span>].values</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="co"># **2. Normalizar las Variables**</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Normaliza las características del dataset para que todas estén en una escala similar.</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> normalizar_datos(X, peso_intensidad<span class="op">=</span><span class="dv">3</span>):</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    medias <span class="op">=</span> np.mean(X, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    desv_est <span class="op">=</span> np.std(X, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    X_norm <span class="op">=</span> (X <span class="op">-</span> medias) <span class="op">/</span> desv_est</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    X_norm[:, <span class="dv">3</span>] <span class="op">*=</span> peso_intensidad  <span class="co"># Aumentar peso de la intensidad promedio</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> X_norm, medias, desv_est</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Normalizar y guardar estadísticas para su reutilización.</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>X_norm, medias, desv_est <span class="op">=</span> normalizar_datos(X)</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Agregar un término independiente (bias) a las características normalizadas.</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>X_norm <span class="op">=</span> np.column_stack([np.ones(<span class="bu">len</span>(X)), X_norm])</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a><span class="co"># **3. Función Sigmoide**</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a><span class="co"># Define la función sigmoide utilizada en la regresión logística.</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sigmoid(z):</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> np.exp(<span class="op">-</span>z))</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a><span class="co"># **4. Regresión Logística con Regularización L1 (LASSO)**</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a><span class="co"># Implementa la regresión logística entrenando un modelo para clasificar las células.</span></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> regresion_logistica(X, y, alpha<span class="op">=</span><span class="fl">0.01</span>, num_iter<span class="op">=</span><span class="dv">1000</span>, lambda_reg<span class="op">=</span><span class="fl">0.1</span>):</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>    theta <span class="op">=</span> np.zeros(X.shape[<span class="dv">1</span>])</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="bu">len</span>(y)</span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>    costos <span class="op">=</span> []</span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_iter):</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> np.dot(X, theta)</span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>        h <span class="op">=</span> sigmoid(z)</span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a><span class="co">#stats models, estabilidad</span></span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Gradiente con regularización L1</span></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>        gradiente <span class="op">=</span> np.dot(X.T, (h <span class="op">-</span> y)) <span class="op">/</span> m</span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>        gradiente[<span class="dv">1</span>:] <span class="op">+=</span> (lambda_reg <span class="op">*</span> np.sign(theta[<span class="dv">1</span>:])) <span class="op">/</span> m  <span class="co"># No regularizar el término independiente</span></span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Actualizar parámetros</span></span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a>        theta <span class="op">-=</span> alpha <span class="op">*</span> gradiente</span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calcular costo con regularización L1</span></span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a>        costo <span class="op">=</span> <span class="op">-</span>np.mean(y <span class="op">*</span> np.log(h <span class="op">+</span> <span class="fl">1e-10</span>) <span class="op">+</span> (<span class="dv">1</span><span class="op">-</span>y) <span class="op">*</span> np.log(<span class="dv">1</span><span class="op">-</span>h <span class="op">+</span> <span class="fl">1e-10</span>))</span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a>        costo <span class="op">+=</span> lambda_reg <span class="op">*</span> np.<span class="bu">sum</span>(np.<span class="bu">abs</span>(theta[<span class="dv">1</span>:])) <span class="op">/</span> m</span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a>        costos.append(costo)</span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> theta, costos</span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a><span class="co"># Entrenar el modelo de regresión logística.</span></span>
<span id="cb3-64"><a href="#cb3-64" aria-hidden="true" tabindex="-1"></a>theta, costos <span class="op">=</span> regresion_logistica(X_norm, y, alpha<span class="op">=</span><span class="fl">0.01</span>, num_iter<span class="op">=</span><span class="dv">1000</span>, lambda_reg<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb3-65"><a href="#cb3-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-66"><a href="#cb3-66" aria-hidden="true" tabindex="-1"></a><span class="co"># **5. Visualizar Convergencia**</span></span>
<span id="cb3-67"><a href="#cb3-67" aria-hidden="true" tabindex="-1"></a><span class="co"># Muestra cómo evoluciona el costo durante el entrenamiento.</span></span>
<span id="cb3-68"><a href="#cb3-68" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb3-69"><a href="#cb3-69" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(<span class="bu">len</span>(costos)), costos, label<span class="op">=</span><span class="st">'Costo'</span>)</span>
<span id="cb3-70"><a href="#cb3-70" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Convergencia del Costo'</span>)</span>
<span id="cb3-71"><a href="#cb3-71" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Iteraciones'</span>)</span>
<span id="cb3-72"><a href="#cb3-72" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Costo'</span>)</span>
<span id="cb3-73"><a href="#cb3-73" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb3-74"><a href="#cb3-74" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb3-75"><a href="#cb3-75" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb3-76"><a href="#cb3-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-77"><a href="#cb3-77" aria-hidden="true" tabindex="-1"></a><span class="co"># Hacer predicciones</span></span>
<span id="cb3-78"><a href="#cb3-78" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> predecir(X, theta):</span>
<span id="cb3-79"><a href="#cb3-79" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> np.dot(X, theta)</span>
<span id="cb3-80"><a href="#cb3-80" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sigmoid(z)</span>
<span id="cb3-81"><a href="#cb3-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-82"><a href="#cb3-82" aria-hidden="true" tabindex="-1"></a>predicciones <span class="op">=</span> predecir(X_norm, theta) <span class="op">&gt;=</span> <span class="fl">0.5</span></span>
<span id="cb3-83"><a href="#cb3-83" aria-hidden="true" tabindex="-1"></a>correctos <span class="op">=</span> np.<span class="bu">sum</span>(predicciones <span class="op">==</span> y)</span>
<span id="cb3-84"><a href="#cb3-84" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> <span class="bu">len</span>(y)</span>
<span id="cb3-85"><a href="#cb3-85" aria-hidden="true" tabindex="-1"></a>efectividad <span class="op">=</span> (correctos <span class="op">/</span> total) <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb3-86"><a href="#cb3-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-87"><a href="#cb3-87" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Efectividad del modelo: </span><span class="sc">{</span>efectividad<span class="sc">:.2f}</span><span class="ss">%"</span>)</span>
<span id="cb3-88"><a href="#cb3-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-89"><a href="#cb3-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-90"><a href="#cb3-90" aria-hidden="true" tabindex="-1"></a><span class="co"># **6. Clase para Análisis de Imágenes**</span></span>
<span id="cb3-91"><a href="#cb3-91" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CellImageAnalyzer:</span>
<span id="cb3-92"><a href="#cb3-92" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, theta, medias, desv_est, factor_intensidad<span class="op">=</span><span class="fl">2.5</span>):</span>
<span id="cb3-93"><a href="#cb3-93" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.theta <span class="op">=</span> theta</span>
<span id="cb3-94"><a href="#cb3-94" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.medias <span class="op">=</span> medias</span>
<span id="cb3-95"><a href="#cb3-95" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.desv_est <span class="op">=</span> desv_est</span>
<span id="cb3-96"><a href="#cb3-96" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.factor_intensidad <span class="op">=</span> factor_intensidad</span>
<span id="cb3-97"><a href="#cb3-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-98"><a href="#cb3-98" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> load_and_display_image(<span class="va">self</span>, image_path):</span>
<span id="cb3-99"><a href="#cb3-99" aria-hidden="true" tabindex="-1"></a>        img <span class="op">=</span> cv2.imread(image_path)</span>
<span id="cb3-100"><a href="#cb3-100" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> img <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb3-101"><a href="#cb3-101" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> img</span>
<span id="cb3-102"><a href="#cb3-102" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb3-103"><a href="#cb3-103" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Error al cargar la imagen </span><span class="sc">{</span>image_path<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-104"><a href="#cb3-104" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb3-105"><a href="#cb3-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-106"><a href="#cb3-106" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> segment_cells(<span class="va">self</span>, image, lower_hue<span class="op">=</span><span class="va">None</span>, upper_hue<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb3-107"><a href="#cb3-107" aria-hidden="true" tabindex="-1"></a>        lower_hue <span class="op">=</span> lower_hue <span class="kw">or</span> np.array([<span class="dv">110</span>, <span class="dv">100</span>, <span class="dv">50</span>])  <span class="co"># Límites inferiores</span></span>
<span id="cb3-108"><a href="#cb3-108" aria-hidden="true" tabindex="-1"></a>        upper_hue <span class="op">=</span> upper_hue <span class="kw">or</span> np.array([<span class="dv">160</span>, <span class="dv">255</span>, <span class="dv">255</span>])  <span class="co"># Límites superiores</span></span>
<span id="cb3-109"><a href="#cb3-109" aria-hidden="true" tabindex="-1"></a>        hsv <span class="op">=</span> cv2.cvtColor(image, cv2.COLOR_BGR2HSV)</span>
<span id="cb3-110"><a href="#cb3-110" aria-hidden="true" tabindex="-1"></a>        mask <span class="op">=</span> cv2.inRange(hsv, lower_hue, upper_hue)</span>
<span id="cb3-111"><a href="#cb3-111" aria-hidden="true" tabindex="-1"></a>        segmented <span class="op">=</span> cv2.bitwise_and(image, image, mask<span class="op">=</span>mask)</span>
<span id="cb3-112"><a href="#cb3-112" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> mask, segmented</span>
<span id="cb3-113"><a href="#cb3-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-114"><a href="#cb3-114" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> analyze_cells(<span class="va">self</span>, mask, image, min_area<span class="op">=</span><span class="dv">100</span>):</span>
<span id="cb3-115"><a href="#cb3-115" aria-hidden="true" tabindex="-1"></a>        contours, _ <span class="op">=</span> cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span>
<span id="cb3-116"><a href="#cb3-116" aria-hidden="true" tabindex="-1"></a>        cell_data <span class="op">=</span> []</span>
<span id="cb3-117"><a href="#cb3-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-118"><a href="#cb3-118" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> contour <span class="kw">in</span> contours:</span>
<span id="cb3-119"><a href="#cb3-119" aria-hidden="true" tabindex="-1"></a>            area <span class="op">=</span> cv2.contourArea(contour)</span>
<span id="cb3-120"><a href="#cb3-120" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> area <span class="op">&gt;</span> min_area:</span>
<span id="cb3-121"><a href="#cb3-121" aria-hidden="true" tabindex="-1"></a>                perimeter <span class="op">=</span> cv2.arcLength(contour, <span class="va">True</span>)</span>
<span id="cb3-122"><a href="#cb3-122" aria-hidden="true" tabindex="-1"></a>                circularity <span class="op">=</span> <span class="dv">4</span> <span class="op">*</span> np.pi <span class="op">*</span> (area <span class="op">/</span> (perimeter <span class="op">**</span> <span class="dv">2</span>))</span>
<span id="cb3-123"><a href="#cb3-123" aria-hidden="true" tabindex="-1"></a>                cell_mask <span class="op">=</span> np.zeros(mask.shape, dtype<span class="op">=</span>np.uint8)</span>
<span id="cb3-124"><a href="#cb3-124" aria-hidden="true" tabindex="-1"></a>                cv2.drawContours(cell_mask, [contour], <span class="op">-</span><span class="dv">1</span>, <span class="dv">255</span>, thickness<span class="op">=</span>cv2.FILLED)</span>
<span id="cb3-125"><a href="#cb3-125" aria-hidden="true" tabindex="-1"></a>                mean_intensity_gray <span class="op">=</span> cv2.mean(cv2.cvtColor(image, cv2.COLOR_BGR2GRAY), mask<span class="op">=</span>cell_mask)[<span class="dv">0</span>]</span>
<span id="cb3-126"><a href="#cb3-126" aria-hidden="true" tabindex="-1"></a>                cell_info <span class="op">=</span> {</span>
<span id="cb3-127"><a href="#cb3-127" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'Área'</span>: area,</span>
<span id="cb3-128"><a href="#cb3-128" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'Circularidad'</span>: circularity,</span>
<span id="cb3-129"><a href="#cb3-129" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'Intensidad_Grises'</span>: mean_intensity_gray</span>
<span id="cb3-130"><a href="#cb3-130" aria-hidden="true" tabindex="-1"></a>                }</span>
<span id="cb3-131"><a href="#cb3-131" aria-hidden="true" tabindex="-1"></a>                cell_data.append(cell_info)</span>
<span id="cb3-132"><a href="#cb3-132" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> cell_data</span>
<span id="cb3-133"><a href="#cb3-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-134"><a href="#cb3-134" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> process_and_display_images(<span class="va">self</span>, image_paths, lower_hue<span class="op">=</span><span class="va">None</span>, upper_hue<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb3-135"><a href="#cb3-135" aria-hidden="true" tabindex="-1"></a>        results <span class="op">=</span> []</span>
<span id="cb3-136"><a href="#cb3-136" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> image_path <span class="kw">in</span> image_paths:</span>
<span id="cb3-137"><a href="#cb3-137" aria-hidden="true" tabindex="-1"></a>            image <span class="op">=</span> <span class="va">self</span>.load_and_display_image(image_path)</span>
<span id="cb3-138"><a href="#cb3-138" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> image <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb3-139"><a href="#cb3-139" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb3-140"><a href="#cb3-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-141"><a href="#cb3-141" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Generar máscara y segmento</span></span>
<span id="cb3-142"><a href="#cb3-142" aria-hidden="true" tabindex="-1"></a>            mask, segmented <span class="op">=</span> <span class="va">self</span>.segment_cells(image, lower_hue, upper_hue)</span>
<span id="cb3-143"><a href="#cb3-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-144"><a href="#cb3-144" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Analizar células</span></span>
<span id="cb3-145"><a href="#cb3-145" aria-hidden="true" tabindex="-1"></a>            cell_data <span class="op">=</span> <span class="va">self</span>.analyze_cells(mask, image)</span>
<span id="cb3-146"><a href="#cb3-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-147"><a href="#cb3-147" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> cell_data:</span>
<span id="cb3-148"><a href="#cb3-148" aria-hidden="true" tabindex="-1"></a>                mean_intensity_gray <span class="op">=</span> np.mean([cell[<span class="st">'Intensidad_Grises'</span>] <span class="cf">for</span> cell <span class="kw">in</span> cell_data])</span>
<span id="cb3-149"><a href="#cb3-149" aria-hidden="true" tabindex="-1"></a>                num_cells <span class="op">=</span> <span class="bu">len</span>(cell_data)</span>
<span id="cb3-150"><a href="#cb3-150" aria-hidden="true" tabindex="-1"></a>                avg_area <span class="op">=</span> np.mean([cell[<span class="st">'Área'</span>] <span class="cf">for</span> cell <span class="kw">in</span> cell_data])</span>
<span id="cb3-151"><a href="#cb3-151" aria-hidden="true" tabindex="-1"></a>                total_area <span class="op">=</span> np.<span class="bu">sum</span>([cell[<span class="st">'Área'</span>] <span class="cf">for</span> cell <span class="kw">in</span> cell_data])</span>
<span id="cb3-152"><a href="#cb3-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-153"><a href="#cb3-153" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Normalizar las características</span></span>
<span id="cb3-154"><a href="#cb3-154" aria-hidden="true" tabindex="-1"></a>                X_nueva <span class="op">=</span> np.array([num_cells, avg_area, total_area, mean_intensity_gray])</span>
<span id="cb3-155"><a href="#cb3-155" aria-hidden="true" tabindex="-1"></a>                X_norm <span class="op">=</span> (X_nueva <span class="op">-</span> <span class="va">self</span>.medias) <span class="op">/</span> <span class="va">self</span>.desv_est</span>
<span id="cb3-156"><a href="#cb3-156" aria-hidden="true" tabindex="-1"></a>                X_norm[<span class="dv">3</span>] <span class="op">*=</span> <span class="va">self</span>.factor_intensidad</span>
<span id="cb3-157"><a href="#cb3-157" aria-hidden="true" tabindex="-1"></a>                X_norm <span class="op">=</span> np.concatenate(([<span class="dv">1</span>], X_norm))</span>
<span id="cb3-158"><a href="#cb3-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-159"><a href="#cb3-159" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Predicción</span></span>
<span id="cb3-160"><a href="#cb3-160" aria-hidden="true" tabindex="-1"></a>                prob <span class="op">=</span> sigmoid(np.dot(X_norm, <span class="va">self</span>.theta))</span>
<span id="cb3-161"><a href="#cb3-161" aria-hidden="true" tabindex="-1"></a>                pred <span class="op">=</span> <span class="dv">1</span> <span class="cf">if</span> prob <span class="op">&gt;=</span> <span class="fl">0.5</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb3-162"><a href="#cb3-162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-163"><a href="#cb3-163" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Agregar resultados</span></span>
<span id="cb3-164"><a href="#cb3-164" aria-hidden="true" tabindex="-1"></a>                results.append({</span>
<span id="cb3-165"><a href="#cb3-165" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'Imagen'</span>: os.path.basename(image_path),</span>
<span id="cb3-166"><a href="#cb3-166" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'Probabilidad de Leucemia'</span>: <span class="ss">f'</span><span class="sc">{</span>prob<span class="sc">:.3f}</span><span class="ss">'</span>,</span>
<span id="cb3-167"><a href="#cb3-167" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'Predicción'</span>: <span class="st">'Leucemia'</span> <span class="cf">if</span> pred <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> <span class="st">'Sano'</span>,</span>
<span id="cb3-168"><a href="#cb3-168" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'Número de Células'</span>: num_cells,</span>
<span id="cb3-169"><a href="#cb3-169" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'Área Promedio'</span>: <span class="ss">f'</span><span class="sc">{</span>avg_area<span class="sc">:.2f}</span><span class="ss">'</span>,</span>
<span id="cb3-170"><a href="#cb3-170" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'Área Total'</span>: <span class="ss">f'</span><span class="sc">{</span>total_area<span class="sc">:.2f}</span><span class="ss">'</span>,</span>
<span id="cb3-171"><a href="#cb3-171" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'Intensidad Promedio'</span>: <span class="ss">f'</span><span class="sc">{</span>mean_intensity_gray<span class="sc">:.2f}</span><span class="ss">'</span></span>
<span id="cb3-172"><a href="#cb3-172" aria-hidden="true" tabindex="-1"></a>                })</span>
<span id="cb3-173"><a href="#cb3-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-174"><a href="#cb3-174" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Mostrar imágenes</span></span>
<span id="cb3-175"><a href="#cb3-175" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.display_images(image, mask, segmented, os.path.basename(image_path), prob, pred)</span>
<span id="cb3-176"><a href="#cb3-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-177"><a href="#cb3-177" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> pd.DataFrame(results)</span>
<span id="cb3-178"><a href="#cb3-178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-179"><a href="#cb3-179" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> display_images(<span class="va">self</span>, original, mask, segmented, image_name, prob, pred):</span>
<span id="cb3-180"><a href="#cb3-180" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Muestra la imagen original, la máscara generada y la imagen segmentada."""</span></span>
<span id="cb3-181"><a href="#cb3-181" aria-hidden="true" tabindex="-1"></a>        plt.figure(figsize<span class="op">=</span>(<span class="dv">16</span>, <span class="dv">8</span>))</span>
<span id="cb3-182"><a href="#cb3-182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-183"><a href="#cb3-183" aria-hidden="true" tabindex="-1"></a>        plt.subplot(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">1</span>)</span>
<span id="cb3-184"><a href="#cb3-184" aria-hidden="true" tabindex="-1"></a>        plt.imshow(cv2.cvtColor(original, cv2.COLOR_BGR2RGB))</span>
<span id="cb3-185"><a href="#cb3-185" aria-hidden="true" tabindex="-1"></a>        plt.title(<span class="ss">f'Original: </span><span class="sc">{</span>image_name<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb3-186"><a href="#cb3-186" aria-hidden="true" tabindex="-1"></a>        plt.axis(<span class="st">'off'</span>)</span>
<span id="cb3-187"><a href="#cb3-187" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-188"><a href="#cb3-188" aria-hidden="true" tabindex="-1"></a>        plt.subplot(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>)</span>
<span id="cb3-189"><a href="#cb3-189" aria-hidden="true" tabindex="-1"></a>        plt.imshow(mask, cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb3-190"><a href="#cb3-190" aria-hidden="true" tabindex="-1"></a>        plt.title(<span class="st">'Máscara'</span>)</span>
<span id="cb3-191"><a href="#cb3-191" aria-hidden="true" tabindex="-1"></a>        plt.axis(<span class="st">'off'</span>)</span>
<span id="cb3-192"><a href="#cb3-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-193"><a href="#cb3-193" aria-hidden="true" tabindex="-1"></a>        plt.subplot(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">3</span>)</span>
<span id="cb3-194"><a href="#cb3-194" aria-hidden="true" tabindex="-1"></a>        plt.imshow(cv2.cvtColor(segmented, cv2.COLOR_BGR2RGB))</span>
<span id="cb3-195"><a href="#cb3-195" aria-hidden="true" tabindex="-1"></a>        plt.title(<span class="ss">f'Segmentado: </span><span class="sc">{</span>pred<span class="sc">}</span><span class="ss"> (</span><span class="sc">{</span>prob<span class="sc">:.3f}</span><span class="ss">)'</span>)</span>
<span id="cb3-196"><a href="#cb3-196" aria-hidden="true" tabindex="-1"></a>        plt.axis(<span class="st">'off'</span>)</span>
<span id="cb3-197"><a href="#cb3-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-198"><a href="#cb3-198" aria-hidden="true" tabindex="-1"></a>        plt.tight_layout()</span>
<span id="cb3-199"><a href="#cb3-199" aria-hidden="true" tabindex="-1"></a>        plt.show()</span>
<span id="cb3-200"><a href="#cb3-200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-201"><a href="#cb3-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-202"><a href="#cb3-202" aria-hidden="true" tabindex="-1"></a><span class="co"># **7. Procesar Varias Imágenes**</span></span>
<span id="cb3-203"><a href="#cb3-203" aria-hidden="true" tabindex="-1"></a><span class="co"># Lista de rutas de imágenes.</span></span>
<span id="cb3-204"><a href="#cb3-204" aria-hidden="true" tabindex="-1"></a>image_paths <span class="op">=</span> [</span>
<span id="cb3-205"><a href="#cb3-205" aria-hidden="true" tabindex="-1"></a>    <span class="st">'/content/drive/MyDrive/archive/Original/Benign/WBC-Benign-016.jpg'</span>,</span>
<span id="cb3-206"><a href="#cb3-206" aria-hidden="true" tabindex="-1"></a>    <span class="st">'/content/drive/MyDrive/archive/Original/Benign/WBC-Benign-025.jpg'</span>,</span>
<span id="cb3-207"><a href="#cb3-207" aria-hidden="true" tabindex="-1"></a>    <span class="st">'/content/drive/MyDrive/archive/Original/Early/WBC-Malignant-Early-017.jpg'</span>,</span>
<span id="cb3-208"><a href="#cb3-208" aria-hidden="true" tabindex="-1"></a>    <span class="st">'/content/drive/MyDrive/archive/Original/Early/WBC-Malignant-Early-008.jpg'</span>,</span>
<span id="cb3-209"><a href="#cb3-209" aria-hidden="true" tabindex="-1"></a>    <span class="st">'/content/drive/MyDrive/archive/Original/Pre/WBC-Malignant-Pre-026.jpg'</span>,</span>
<span id="cb3-210"><a href="#cb3-210" aria-hidden="true" tabindex="-1"></a>    <span class="st">'/content/drive/MyDrive/archive/Original/Pre/WBC-Malignant-Pre-032.jpg'</span></span>
<span id="cb3-211"><a href="#cb3-211" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb3-212"><a href="#cb3-212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-213"><a href="#cb3-213" aria-hidden="true" tabindex="-1"></a><span class="co"># Instanciar el analizador de imágenes.</span></span>
<span id="cb3-214"><a href="#cb3-214" aria-hidden="true" tabindex="-1"></a>analyzer <span class="op">=</span> CellImageAnalyzer(theta, medias, desv_est)</span>
<span id="cb3-215"><a href="#cb3-215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-216"><a href="#cb3-216" aria-hidden="true" tabindex="-1"></a><span class="co"># Procesar todas las imágenes y mostrar resultados.</span></span>
<span id="cb3-217"><a href="#cb3-217" aria-hidden="true" tabindex="-1"></a>results_df <span class="op">=</span> analyzer.process_and_display_images(image_paths)</span>
<span id="cb3-218"><a href="#cb3-218" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-219"><a href="#cb3-219" aria-hidden="true" tabindex="-1"></a><span class="co"># Mostrar resultados en formato tabla.</span></span>
<span id="cb3-220"><a href="#cb3-220" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Resultados del análisis:"</span>)</span>
<span id="cb3-221"><a href="#cb3-221" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(results_df.to_string(index<span class="op">=</span><span class="va">False</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Proyecto_PSIM_files/figure-html/cell-3-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Efectividad del modelo: 97.92%</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Proyecto_PSIM_files/figure-html/cell-3-output-3.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Proyecto_PSIM_files/figure-html/cell-3-output-4.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Proyecto_PSIM_files/figure-html/cell-3-output-5.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Proyecto_PSIM_files/figure-html/cell-3-output-6.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Proyecto_PSIM_files/figure-html/cell-3-output-7.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Proyecto_PSIM_files/figure-html/cell-3-output-8.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Resultados del análisis:
                     Imagen Probabilidad de Leucemia Predicción  Número de Células Área Promedio Área Total Intensidad Promedio
         WBC-Benign-016.jpg                    0.031       Sano                 12        301.17    3614.00              108.81
         WBC-Benign-025.jpg                    0.097       Sano                  6        362.92    2177.50              112.98
WBC-Malignant-Early-017.jpg                    0.842   Leucemia                  9        487.56    4388.00              137.08
WBC-Malignant-Early-008.jpg                    0.869   Leucemia                 13        313.08    4070.00              140.66
  WBC-Malignant-Pre-026.jpg                    0.998   Leucemia                  5        196.00     980.00              163.07
  WBC-Malignant-Pre-032.jpg                    0.995   Leucemia                  1        717.50     717.50              152.45</code></pre>
</div>
</div>
</section>
<section id="descripción-matemática-del-análisis-de-células" class="level1">
<h1>Descripción Matemática del Análisis de Células</h1>
<section id="preparación-y-etiquetado-de-datos" class="level3">
<h3 class="anchored" data-anchor-id="preparación-y-etiquetado-de-datos">1. Preparación y Etiquetado de Datos</h3>
<p>Los datos se dividen en dos grupos con etiquetas binarias:</p>
<p><span class="math display">\[
y_{\text{Sanas}} = 0 \quad \text{y} \quad y_{\text{Leucemia}} = 1
\]</span></p>
</section>
<section id="variables-predictoras" class="level3">
<h3 class="anchored" data-anchor-id="variables-predictoras">2. Variables Predictoras</h3>
<p>El modelo utiliza cuatro variables principales:</p>
<ul>
<li><span class="math inline">\(X_1 = \text{Número de Células}\)</span></li>
<li><span class="math inline">\(X_2 = \text{Área Promedio}\)</span></li>
<li><span class="math inline">\(X_3 = \text{Área Total}\)</span></li>
<li><span class="math inline">\(X_4 = \text{Intensidad Promedio}\)</span></li>
</ul>
</section>
<section id="normalización-de-variables" class="level3">
<h3 class="anchored" data-anchor-id="normalización-de-variables">3. Normalización de Variables</h3>
<p>Para cada variable <span class="math inline">\(j\)</span>, se calcula:</p>
<p>Media:
<span class="math display">\[
\mu_j = \frac{1}{m} \sum_{i=1}^{m} X_{ij}
\]</span></p>
<p>Desviación estándar:
<span class="math display">\[
\sigma_j = \sqrt{\frac{1}{m} \sum_{i=1}^{m} (X_{ij} - \mu_j)^2}
\]</span></p>
<p>Normalización con peso adicional para intensidad:
<span class="math display">\[
X'_{ij} = \begin{cases}
\frac{X_{ij} - \mu_j}{\sigma_j} &amp; \text{para } j = 1,2,3 \\
\frac{X_{ij} - \mu_j}{\sigma_j} \times 3 &amp; \text{para } j = 4
\end{cases}
\]</span></p>
</section>
<section id="matriz-de-características" class="level3">
<h3 class="anchored" data-anchor-id="matriz-de-características">4. Matriz de Características</h3>
<p>La matriz final incluye el término independiente:</p>
<p><span class="math display">\[
X = \begin{bmatrix}
1 &amp; X'_{11} &amp; X'_{12} &amp; X'_{13} &amp; X'_{14} \\
1 &amp; X'_{21} &amp; X'_{22} &amp; X'_{23} &amp; X'_{24} \\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots \\
1 &amp; X'_{m1} &amp; X'_{m2} &amp; X'_{m3} &amp; X'_{m4}
\end{bmatrix}
\]</span></p>
</section>
<section id="función-sigmoide" class="level3">
<h3 class="anchored" data-anchor-id="función-sigmoide">5. Función Sigmoide</h3>
<p>La transformación sigmoide se define como:</p>
<p><span class="math display">\[
\sigma(z) = \frac{1}{1 + e^{-z}}
\]</span></p>
<p>donde <span class="math inline">\(z = \theta^T X\)</span></p>
</section>
<section id="función-de-costo-con-regularización-l1" class="level3">
<h3 class="anchored" data-anchor-id="función-de-costo-con-regularización-l1">6. Función de Costo con Regularización L1</h3>
<p>La función de costo incluye el término de regularización L1:</p>
<p><span class="math display">\[
J(\theta) = -\frac{1}{m} \sum_{i=1}^{m} [y_i \log(h_\theta(x_i)) + (1-y_i)\log(1-h_\theta(x_i))] + \frac{\lambda}{m} \sum_{j=1}^{n} |\theta_j|
\]</span></p>
<p>Donde:
- <span class="math inline">\(h_\theta(x_i) = \sigma(\theta^T x_i)\)</span>
- <span class="math inline">\(\alpha\)</span> = velocidad de convergencia y estabilidad
- <span class="math inline">\(\lambda\)</span> = parámetro de regularización
- <span class="math inline">\(m\)</span> = número de muestras
- <span class="math inline">\(n\)</span> = número de características</p>
</section>
<section id="actualización-de-parámetros" class="level3">
<h3 class="anchored" data-anchor-id="actualización-de-parámetros">7. Actualización de Parámetros</h3>
<p>Los parámetros se actualizan mediante:</p>
<p><span class="math display">\[
\theta_j := \theta_j - \alpha \left[\frac{1}{m} \sum_{i=1}^{m} (h_\theta(x_i) - y_i)x_{ij} + \frac{\lambda}{m} \text{sign}(\theta_j)\right]
\]</span></p>
</section>
<section id="predicción-final" class="level3">
<h3 class="anchored" data-anchor-id="predicción-final">8. Predicción Final</h3>
<p>Para una nueva muestra, la predicción se realiza:</p>
<p><span class="math display">\[
\text{predicción} = \begin{cases}
1 \text{ (Leucemia)} &amp; \text{si } \sigma(\theta^T X) \geq 0.5 \\
0 \text{ (Sana)} &amp; \text{si } \sigma(\theta^T X) &lt; 0.5
\end{cases}
\]</span></p>
</section>
<section id="evaluación-del-modelo" class="level3">
<h3 class="anchored" data-anchor-id="evaluación-del-modelo">9. Evaluación del Modelo</h3>
<p>La efectividad se calcula como:</p>
<p><span class="math display">\[
\text{Efectividad} = \frac{\text{Predicciones correctas}}{\text{Total de predicciones}} \times 100\%
\]</span></p>
<ol type="1">
<li>Cálculo de Vector entre Puntos
<em>Fórmula:</em> Vector = [x₂ - x₁, y₂ - y₁]</li>
</ol>
<ul>
<li>Resta las coordenadas de dos puntos consecutivos</li>
<li>Determina dirección y sentido del movimiento</li>
</ul>
<ol start="2" type="1">
<li>Magnitud del Vector
<em>Fórmula:</em> |v| = √(x² + y²)</li>
</ol>
<ul>
<li>Calcula la longitud del vector</li>
<li>Usa el teorema de Pitágoras</li>
<li>Mide la distancia recorrida</li>
</ul>
<ol start="3" type="1">
<li>Producto Punto de Vectores
<em>Fórmula:</em> v₁ · v₂ = x₁x₂ + y₁y₂</li>
</ol>
<ul>
<li>Multiplica componentes x e y de dos vectores</li>
<li>Ayuda a determinar la similitud entre vectores</li>
</ul>
<ol start="4" type="1">
<li>Ángulo entre Vectores
<em>Fórmula:</em> θ = arccos((v₁ · v₂) / (|v₁| * |v₂|))</li>
</ol>
<ul>
<li>Calcula el ángulo de cambio de dirección</li>
<li>Compara la orientación de vectores consecutivos</li>
<li>Fundamental para decidir qué puntos conservar</li>
</ul>
</section>
</section>
<section id="producto-punto-en-regresión-logística" class="level1">
<h1>Producto Punto en Regresión Logística</h1>
<p><span class="math display">\[
z = X\theta = \begin{bmatrix} 1 &amp; x_1 &amp; x_2 &amp; x_3 &amp; x_4 \end{bmatrix} \begin{bmatrix} \theta_0 \\ \theta_1 \\ \theta_2 \\ \theta_3 \\ \theta_4 \end{bmatrix} = \theta_0 \cdot 1 + \theta_1 \cdot x_1 + \theta_2 \cdot x_2 + \theta_3 \cdot x_3 + \theta_4 \cdot x_4
\]</span></p>
<p>Donde:
- <span class="math inline">\(x_1\)</span>: Número de Células (normalizado)
- <span class="math inline">\(x_2\)</span>: Área Promedio (normalizada)
- <span class="math inline">\(x_3\)</span>: Área Total (normalizada)
- <span class="math inline">\(x_4\)</span>: Intensidad Promedio en Grises (normalizada y ponderada)
- <span class="math inline">\(\theta_0\)</span>: Término independiente o sesgo (bias)
- <span class="math inline">\(\theta_1, \theta_2, \theta_3, \theta_4\)</span>: Coeficientes para cada característica</p>
<section id="significado-en-el-contexto-del-modelo" class="level2">
<h2 class="anchored" data-anchor-id="significado-en-el-contexto-del-modelo">Significado en el Contexto del Modelo</h2>
<ol type="1">
<li><p><strong>Combinación Lineal</strong></p>
<ul>
<li>Cada característica <span class="math inline">\(x_i\)</span> se pondera por su importancia relativa <span class="math inline">\(\theta_i\)</span></li>
<li>El término independiente <span class="math inline">\(\theta_0\)</span> añade un sesgo base</li>
</ul></li>
<li><p><strong>Interpretación de los Coeficientes</strong></p>
<ul>
<li><span class="math inline">\(\theta_i &gt; 0\)</span>: La característica aumenta la probabilidad de leucemia</li>
<li><span class="math inline">\(\theta_i &lt; 0\)</span>: La característica disminuye la probabilidad de leucemia</li>
<li><span class="math inline">\(|\theta_i|\)</span>: Magnitud del impacto de la característica</li>
</ul></li>
<li><p><strong>Flujo del Modelo</strong>
<span class="math display">\[
X\theta \xrightarrow{\text{producto punto}} z \xrightarrow{\text{sigmoide}} h_\theta(x) = \frac{1}{1 + e^{-z}}
\]</span></p></li>
<li><p><strong>Resultado</strong></p>
<ul>
<li><span class="math inline">\(z\)</span>: Puntuación lineal (puede ser cualquier número real)</li>
<li><span class="math inline">\(h_\theta(x)\)</span>: Probabilidad entre 0 y 1 después de aplicar la sigmoide</li>
</ul></li>
</ol>
<p>La regularización L1 (también conocida como LASSO - Least Absolute Shrinkage and Selection Operator) es una técnica para prevenir el sobreajuste (overfitting).</p>
<section id="qué-es-la-regularización-l1" class="level3">
<h3 class="anchored" data-anchor-id="qué-es-la-regularización-l1">¿Qué es la regularización L1?</h3>
<p>Es un término que se añade a la función de costo:</p>
<p><span class="math display">\[
\frac{\lambda}{m} \sum_{j=1}^{n} |\theta_j|
\]</span></p>
<p>Donde:
- λ (lambda) es el parámetro que controla la fuerza de la regularización
- m es el número de muestras
- θj son los parámetros del modelo
- |θj| es el valor absoluto de cada parámetro</p>
</section>
<section id="por-qué-se-implementa" class="level3">
<h3 class="anchored" data-anchor-id="por-qué-se-implementa">¿Por qué se implementa?</h3>
<ol type="1">
<li>Prevención de sobreajuste:
<ul>
<li>Penaliza coeficientes muy grandes que podrían hacer que el modelo se ajuste demasiado a los datos de entrenamiento</li>
<li>Ayuda al modelo a generalizar mejor con nuevos datos</li>
</ul></li>
<li>Selección de características:
<ul>
<li>La regularización L1 tiende a producir coeficientes exactamente iguales a cero</li>
<li>Esto efectivamente selecciona las características más importantes y descarta las menos relevantes</li>
</ul></li>
</ol>
</section>
<section id="efectos-prácticos" class="level3">
<h3 class="anchored" data-anchor-id="efectos-prácticos">Efectos prácticos:</h3>
<ol type="1">
<li>Con lambda_reg = 0:
<ul>
<li>No hay regularización</li>
<li>El modelo puede sobreajustarse</li>
</ul></li>
<li>Con lambda_reg pequeño (ej: 0.1):
<ul>
<li>Regularización suave</li>
<li>Balance entre ajuste y generalización</li>
</ul></li>
<li>Con lambda_reg grande (ej: 10):
<ul>
<li>Regularización fuerte</li>
<li>Más coeficientes se vuelven cero</li>
<li>Modelo más simple pero puede subajustarse (underfitting)</li>
</ul></li>
</ol>
</section>
<section id="ventajas" class="level3">
<h3 class="anchored" data-anchor-id="ventajas">Ventajas:</h3>
<ol type="1">
<li>Selección automática de características más relevantes para detectar leucemia</li>
<li>Reducción del ruido en las mediciones de células</li>
<li>Modelo más robusto y generalizable a nuevas muestras</li>
<li>Interpretabilidad mejorada al identificar las características más importantes</li>
</ol>
</section>
</section>
</section>
<section id="fórmulas-geométricas-para-análisis-de-contornos" class="level1">
<h1>Fórmulas Geométricas para Análisis de Contornos</h1>
<section id="área-del-contorno" class="level2">
<h2 class="anchored" data-anchor-id="área-del-contorno">1. Área del Contorno</h2>
<p>El área de un contorno cerrado se calcula utilizando la fórmula del área de un polígono mediante coordenadas:</p>
<p><span class="math display">\[
\text{Área} = \frac{1}{2} \sum_{i=1}^{n} (x_i y_{i+1} - y_i x_{i+1})
\]</span></p>
<p>Donde:
- <span class="math inline">\(n\)</span> : Número total de puntos en el contorno
- <span class="math inline">\((x_i, y_i)\)</span> : Coordenadas del punto <span class="math inline">\(i\)</span> del contorno
- <span class="math inline">\((x_{i+1}, y_{i+1})\)</span> : Coordenadas del siguiente punto en el contorno
- El punto <span class="math inline">\(n+1\)</span> se considera igual al punto 1, cerrando el polígono</p>
<p>Esta fórmula:
- Utiliza el método de triangulación para calcular el área
- Funciona para cualquier polígono cerrado, sea cóncavo o convexo
- El resultado es positivo si los puntos están ordenados en sentido antihorario
- El valor absoluto del resultado da el área real</p>
</section>
<section id="perímetro-del-contorno" class="level2">
<h2 class="anchored" data-anchor-id="perímetro-del-contorno">2. Perímetro del Contorno</h2>
<p>El perímetro se calcula sumando las distancias entre todos los puntos consecutivos del contorno:</p>
<p><span class="math display">\[
\text{Perímetro} = \sum_{i=1}^{n} \sqrt{(x_{i+1} - x_i)^2 + (y_{i+1} - y_i)^2}
\]</span></p>
<p>Donde:
- <span class="math inline">\(n\)</span> : Número total de puntos en el contorno
- <span class="math inline">\((x_i, y_i)\)</span> : Coordenadas del punto actual
- <span class="math inline">\((x_{i+1}, y_{i+1})\)</span> : Coordenadas del siguiente punto
- El último punto se conecta con el primero para cerrar el contorno</p>
<p>Esta fórmula:
- Utiliza la distancia euclidiana entre puntos consecutivos
- La suma total representa la longitud del contorno completo
- Es independiente de la orientación del contorno</p>
</section>
<section id="circularidad" class="level2">
<h2 class="anchored" data-anchor-id="circularidad">3. Circularidad</h2>
<p>La circularidad es una medida adimensional que cuantifica qué tan similar es una forma a un círculo perfecto:</p>
<p><span class="math display">\[
\text{Circularidad} = \frac{4\pi \times \text{Área}}{\text{Perímetro}^2}
\]</span></p>
<p>Donde:
- <span class="math inline">\(\text{Área}\)</span> : Área del contorno calculada con la primera fórmula
- <span class="math inline">\(\text{Perímetro}\)</span> : Perímetro del contorno calculado con la segunda fórmula
- <span class="math inline">\(\pi\)</span> : Constante matemática pi (≈ 3.14159)</p>
<p>Interpretación de los valores:
- <span class="math inline">\(\text{Circularidad} = 1\)</span> : Círculo perfecto
- <span class="math inline">\(0 &lt; \text{Circularidad} &lt; 1\)</span> : Formas no circulares
- Valores cercanos a 1: Formas casi circulares
- Valores cercanos a 0: Formas muy alargadas o irregulares</p>
<p>Propiedades importantes:
1. Es invariante a la escala (el tamaño no afecta el resultado)
2. Es adimensional (no tiene unidades)
3. Siempre es menor o igual a 1 (la igualdad solo se da en círculos perfectos)
4. Es sensible a irregularidades en el contorno</p>
<p>Ejemplo de interpretación:
- Circularidad = 0.95: Forma muy circular
- Circularidad = 0.7: Forma moderadamente circular
- Circularidad = 0.3: Forma muy irregular o alargadas</p>
</section>
</section>
<section id="regresión-logística" class="level1">
<h1>Regresión Logística</h1>
<p>La <strong>regresión logística</strong> es un método de clasificación utilizado para predecir la probabilidad de una clase binaria (0 o 1). A diferencia de la regresión lineal, que predice un valor continuo, la regresión logística modela la probabilidad de una clase como una función de la combinación lineal de las características.</p>
<section id="función-logística" class="level2">
<h2 class="anchored" data-anchor-id="función-logística">Función Logística</h2>
<p>La función logística, o función sigmoide, se define como:</p>
<p><span class="math display">\[
P(y = 1|x) = \frac{1}{1 + e^{-(w^T x + b)}}
\]</span></p>
<p>Donde:
- ( P(y = 1|x) ) es la probabilidad de que la clase sea 1 dado un vector de características ( x ).
- ( w ) es el vector de pesos del modelo.
- ( b ) es el sesgo o término independiente.
- ( x ) es el vector de características de entrada.</p>
<p>La función sigmoide convierte la salida lineal ( w^T x + b ) en un valor entre 0 y 1, que puede interpretarse como una probabilidad.</p>
</section>
<section id="función-de-costo" class="level2">
<h2 class="anchored" data-anchor-id="función-de-costo">Función de Costo</h2>
<p>Para entrenar el modelo, se utiliza la función de costo de entropía cruzada:</p>
<p><span class="math display">\[
J(w, b) = -\frac{1}{m} \sum_{i=1}^{m} \left[ y^{(i)} \log(P(y^{(i)}|x^{(i)})) + (1 - y^{(i)}) \log(1 - P(y^{(i)}|x^{(i)})) \right]
\]</span></p>
<p>Donde:
- ( m ) es el número total de ejemplos en el conjunto de datos.
- ( y^{(i)} ) es la etiqueta verdadera para el i-ésimo ejemplo.
- ( P(y<sup>{(i)}|x</sup>{(i)}) ) es la probabilidad predicha para el i-ésimo ejemplo.</p>
</section>
<section id="gradientes-y-actualización" class="level2">
<h2 class="anchored" data-anchor-id="gradientes-y-actualización">Gradientes y Actualización</h2>
<p>Los gradientes de la función de costo con respecto a los parámetros ( w ) y ( b ) se utilizan para actualizar los pesos y el sesgo mediante descenso por gradiente:</p>
<ul>
<li><strong>Gradiente del peso ( w ):</strong></li>
</ul>
<p><span class="math display">\[
\frac{\partial J(w, b)}{\partial w} = \frac{1}{m} \sum_{i=1}^{m} (P(y^{(i)}|x^{(i)}) - y^{(i)}) x^{(i)}
\]</span></p>
<ul>
<li><strong>Gradiente del sesgo ( b ):</strong></li>
</ul>
<p><span class="math display">\[
\frac{\partial J(w, b)}{\partial b} = \frac{1}{m} \sum_{i=1}^{m} (P(y^{(i)}|x^{(i)}) - y^{(i)})
\]</span></p>
<p>Los parámetros se actualizan de la siguiente manera:</p>
<ul>
<li><strong>Actualización del peso ( w ):</strong></li>
</ul>
<p><span class="math display">\[
w := w - \alpha \frac{\partial J(w, b)}{\partial w}
\]</span></p>
<ul>
<li><strong>Actualización del sesgo ( b ):</strong></li>
</ul>
<p><span class="math display">\[
b := b - \alpha \frac{\partial J(w, b)}{\partial b}
\]</span></p>
<p>Donde ( ) es la tasa de aprendizaje.</p>
<p>La precisión del modelo se evalúa comparando las predicciones con las etiquetas verdaderas en el conjunto de prueba, utilizando métricas como la precisión (accuracy), precisión (precision), sensibilidad (recall), y especificidad.</p>
</section>
</section>
<section id="contraste-de-resultados" class="level1">
<h1>Contraste de Resultados</h1>
<p>Este modelo basado en aprendizaje profundo alcanzó una precisión, sensibilidad y especificidad de 99,85, 99,52 y 99,89 %, respectivamente. El método propuesto puede ayudar a distinguir la LLA de los casos benignos.</p>
<p>Se utilizó un conjunto de datos específico que contenía 3256 imágenes PBS de 89 pacientes sospechosos de LLA</p>
<p>En el enfoque propuesto, mediante el uso de un método de bajo costo, primero se segmentaron las células blásticas y luego, cada dos conjuntos de imágenes iniciales y segmentadas pasaron al procesamiento.</p>
<p>El paso de procesamiento consiste en descodificación, cambio de tamaño, normalización y aumento. Después del preprocesamiento preliminar de las imágenes, cada dos grupos de imágenes, es decir, cada par de imágenes de muestra y su versión segmentada, se utilizaron como entrada para la arquitectura.</p>
<p>La arquitectura del modelo propuesto comprendía dos secciones generales. Un bloque de extracción de características basado en DenseNet-201 este estaba a cargo de la extracción de características.</p>
<p>Las características extraídas de la imagen principal y sus células segmentadas correspondientes se concatenaron e ingresaron al bloque de clasificación, que fue responsable de la clasificación de los datos en grupos benignos y malignos, con tres subtipos de LLA: pre-B, pre-B temprana y pro-B. [4]</p>
</section>
<section id="conclusiones" class="level1">
<h1>Conclusiones</h1>
<ol type="1">
<li><p>Desempeño del modelo: El modelo ha alcanzado un desempeño notable con una precisión del 86.6% para las imágenes sanas y del 85.4% para las imágenes con leucemia. Esto sugiere que el modelo es bastante eficaz en la clasificación binaria entre imágenes sanas y con leucemia, con una ligera diferencia en el rendimiento entre ambas clases.</p></li>
<li><p>Equilibrio entre las clases: Aunque existe una pequeña variación entre la precisión en las imágenes sanas y las de leucemia, ambas precisiones están bastante cerca, lo que indica que el modelo está generalizando bien a ambas clases sin sesgarse excesivamente hacia una u otra.</p></li>
<li><p>Posible mejora en la precisión global: Aunque las precisiones son buenas, hay un margen para mejorar el modelo. La diferencia entre las precisiones para imágenes sanas y con leucemia puede estar relacionada con la calidad o complejidad de las características extraídas de las imágenes de leucemia, lo que podría sugerir que el modelo tiene más dificultad para capturar patrones específicos de la leucemia.</p></li>
<li><p>Impacto del preprocesamiento y la extracción de características: La buena precisión en general puede estar atribuida a un adecuado preprocesamiento de las imágenes y la extracción de características relevantes que permiten al modelo diferenciar entre las clases de manera efectiva. Sin embargo, la diferencia en las precisiones puede indicar que algunas características clave podrían necesitar un ajuste para mejorar la discriminación en las imágenes con leucemia.</p></li>
</ol>
</section>
<section id="referencias" class="level1">
<h1>Referencias:</h1>
<ol type="1">
<li>Cáncer en la niñez y la adolescencia - OPS/OMS | Organización Panamericana de la Salud [Internet]. 2024 [citado 1 de diciembre de 2024]. Disponible en: https://www.paho.org/es/temas/cancer-ninez-adolescencia</li>
<li>Estadísticas importantes sobre la leucemia en niños [Internet]. [citado 1 de diciembre de 2024]. Disponible en: https://www.cancer.org/es/cancer/tipos/leucemia-en-ninos/acerca/estadisticas-clave.html</li>
<li>Leukemia &amp; Lymphoma Society. Leucemia linfoblástica aguda (ALL) [Internet]. 2024 [citado 2024 Dec 1]. Disponible en: https://www.lls.org/sites/default/files/2024-08/PS62S_ALL_2024_spanish.pdf</li>
<li>Ghaderzadeh, M, Aria, M, Hosseini, A, Asadi, F, Bashash, D, Abolghasemi, H. A fast and efficient CNN model for B-ALL diagnosis and its subtypes classification using peripheral blood smear images. Int J Intell Syst. 2022; 37: 5113- 5133. doi:10.1002/int.22753</li>
</ol>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>