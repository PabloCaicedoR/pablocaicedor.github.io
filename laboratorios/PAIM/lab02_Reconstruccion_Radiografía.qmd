---
title: "Laboratorio (hands-on): Reconstrucción básica de una radiografía (Beer–Lambert + haz paralelo)"
subtitle: "Fuente → Objeto → Detector → (normalización + log) → Radiografía lista para ver"
lang: es
author: "Ph.D. Pablo Eduardo Caicedo Rodríguez"
date: "`r Sys.Date()`"
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: true
    code-tools: true
    code-overflow: wrap
    code-line-numbers: true
    code-copy: true
    fig-align: center
    self-contained: true
    theme:
      - simple
      - ../../recursos/estilos/metropolis.scss
    preview-links: auto
    logo: ../../recursos/imagenes/generales/Escuela_Rosario_logo.png
    css: ../../recursos/estilos/styles_pres.scss
    footer: <https://pablocaicedor.github.io/>
    transition: fade
    progress: true
    scrollable: true
execute:
  echo: true
  warning: false
  message: false
jupyter: python3
---

## 1) Introducción

Una radiografía (en este laboratorio) es una **imagen de “cuánta atenuación”** produjo un objeto cuando un haz ideal lo atravesó.
Entradas: **fuente** (cuántos fotones salen), **objeto** (qué tan “bloqueador” es cada zona), **detector** (cuántos llegan).
Salida: una imagen final donde **zonas más atenuantes** aparecen con valores más altos (más “densas” en la imagen).

**Cadena conceptual (muy simple):**
**Fuente** $(I_0) → atraviesa **objeto** ($\mu$) → llega al **detector** $(I) → aplico $-log\left(\frac{I}{I_0}\right)$ → obtengo “radiografía” (proporcional a atenuación proyectada).

> Importante: aquí NO hay ruido, NO hay dispersión (scatter), NO hay endurecimiento de haz. Solo Beer–Lambert.

---

## 2) Preparación (imports y parámetros)

Idea clave: trabajaremos en 2D con un mapa `mu[y,x]` de tamaño `N×N`.
En geometría 2D, el detector real sería una línea 1D (un valor por rayo).
Para **verlo como imagen**, repetiremos (tile) esa línea en la dirección horizontal.

```{python}
import numpy as np
import matplotlib.pyplot as plt

plt.rcParams["figure.dpi"] = 120

N = 256         # tamaño del phantom (rápido)
dx = 1.0        # tamaño de pixel (unidades arbitrarias)
eps = 1e-12     # para evitar log(0)
```

---

## 3) Modelo físico: Beer–Lambert (en palabras simples)

Piensa en el objeto como una “**niebla**”: si es más densa, más fotones se pierden.
`μ(x,y)` mide esa “densidad de bloqueo” (atenuación): más μ → menos fotones pasan.
Al atravesar una fila del objeto, se acumula atenuación: eso es la **integral de línea**.
Resultado: el detector mide menos intensidad donde el camino atraviesa más material.

$$
I = I_0 \exp\left(-\int \mu(x,y)\,dl\right)
$$

**Traducción directa:**
- `I0`: fotones que **saldrían** si no hubiera objeto.
- `I`: fotones que **llegan** al detector después del objeto.
- `∫ μ dl`: “atenuación total” vista por ese rayo (camino óptico).

---

## 4) Construcción de un phantom (objetos sintéticos)

Un *phantom* aquí es un mapa 2D de `μ` (como un “mapa de materiales”).
El fondo tendrá un μ pequeño (poco atenuante).
Las formas internas tendrán μ más grande (más atenuantes) para crear contraste.

```{python}
def crear_phantom_circulo(N, mu_fondo=0.02, mu_circulo=0.06, radio_frac=0.25, centro=None):
    """Phantom A: fondo + círculo."""
    if centro is None:
        centro = (N//2, N//2)  # (y, x)

    y = np.arange(N)[:, None]
    x = np.arange(N)[None, :]
    cy, cx = centro
    r = radio_frac * N

    phantom = np.full((N, N), mu_fondo, dtype=float)
    mascara = (x - cx)**2 + (y - cy)**2 <= r**2
    phantom[mascara] = mu_circulo
    return phantom

def crear_phantom_dos_materiales(N, mu_fondo=0.02, mu_bloque=0.10, mu_circulo=0.05):
    """Phantom B: fondo + bloque + círculo."""
    phantom = np.full((N, N), mu_fondo, dtype=float)

    # Bloque (material más atenuante)
    y1, y2 = int(0.35*N), int(0.75*N)
    x1, x2 = int(0.15*N), int(0.45*N)
    phantom[y1:y2, x1:x2] = mu_bloque

    # Círculo (material intermedio)
    y = np.arange(N)[:, None]
    x = np.arange(N)[None, :]
    cy, cx = int(0.45*N), int(0.70*N)
    r = int(0.15*N)
    mascara = (x - cx)**2 + (y - cy)**2 <= r**2
    phantom[mascara] = mu_circulo

    return phantom

mu_A = crear_phantom_circulo(N)
mu_B = crear_phantom_dos_materiales(N)

fig, ax = plt.subplots(1, 2, figsize=(9, 4))
im0 = ax[0].imshow(mu_A, cmap="gray")
ax[0].set_title("Phantom A: círculo en fondo")
plt.colorbar(im0, ax=ax[0], fraction=0.046)

im1 = ax[1].imshow(mu_B, cmap="gray")
ax[1].set_title("Phantom B: dos materiales")
plt.colorbar(im1, ax=ax[1], fraction=0.046)

for a in ax:
    a.set_axis_off()

plt.tight_layout()
plt.show()
```

**Ejercicio guiado 1:**
Cambia `mu_circulo` y `mu_bloque`. Predice: ¿sube o baja la intensidad en el detector dentro de esas zonas?

---

## 5) Generador polienergético idealizado (espectro simple)

En la vida real, el tubo emite fotones con **muchas energías** (espectro).
Aquí lo simplificamos a 3 energías con pesos (solo para “imaginar” polienergía).
Como **no** hacemos μ dependiente de energía, este espectro se reduce a un `I0` total efectivo.

```{python}
energias_keV = np.array([30, 60, 90], dtype=float)
pesos = np.array([0.50, 0.30, 0.20], dtype=float)
pesos = pesos / pesos.sum()

I0_total = 1e5
I0_por_energia = I0_total * pesos

print("Energías (keV):", energias_keV)
print("Pesos:", pesos)
print("I0 por energía:", I0_por_energia)
print("I0 efectivo:", I0_por_energia.sum())
```

**Chequeo mental:** si el objeto “bloquea” igual a todas las energías, entonces cambiar los pesos casi no cambia `-log(I/I0)`.

---

## 6) Simulación de proyecciones (haz paralelo, integral discreta)

Haz paralelo (2D) significa: muchos rayos horizontales, uno por cada fila `y`.
Cada rayo “ve” una fila completa del phantom y acumula atenuación.
Aproximamos la integral como suma: `tau(y) = sum_x mu(y,x)*dx`.
`tau` es la “cantidad total de material” que atravesó el rayo (en ese modelo).

```{python}
def proyectar_haz_paralelo(mu, dx=1.0):
    """
    Proyección 2D→1D (izquierda→derecha):
    tau[y] = sum_x mu[y,x]*dx
    """
    tau = np.sum(mu, axis=1) * dx  # suma en x (columnas)
    return tau

tau_A = proyectar_haz_paralelo(mu_A, dx=dx)
tau_B = proyectar_haz_paralelo(mu_B, dx=dx)

fig, ax = plt.subplots(1, 2, figsize=(9, 3.2))
ax[0].plot(tau_A)
ax[0].set_title("Camino óptico τ(y) - Phantom A")
ax[0].set_xlabel("índice y (pixel)")
ax[0].set_ylabel("τ (aprox.)")

ax[1].plot(tau_B)
ax[1].set_title("Camino óptico τ(y) - Phantom B")
ax[1].set_xlabel("índice y (pixel)")

plt.tight_layout()
plt.show()
```

**Para visualizar como imagen 2D (solo por comodidad visual):**
Esto NO agrega física; solo repite la señal 1D para verla en forma de imagen.

```{python}
def tile_a_imagen(signal_1d, N):
    """Convierte una señal 1D (N,) a una imagen (N,N) repitiéndola en x."""
    return np.tile(signal_1d[:, None], (1, N))

tau_A_img = tile_a_imagen(tau_A, N)
tau_B_img = tile_a_imagen(tau_B, N)

fig, ax = plt.subplots(1, 2, figsize=(9, 4))
im0 = ax[0].imshow(tau_A_img, cmap="magma")
ax[0].set_title("τ(y) como imagen (tiling) - A")
plt.colorbar(im0, ax=ax[0], fraction=0.046)

im1 = ax[1].imshow(tau_B_img, cmap="magma")
ax[1].set_title("τ(y) como imagen (tiling) - B")
plt.colorbar(im1, ax=ax[1], fraction=0.046)

for a in ax:
    a.set_axis_off()

plt.tight_layout()
plt.show()
```

---

## 7) Detector ideal (sin blur, sin ruido)

El detector ideal solo “cuenta” fotones que llegaron: más atenuación → menos conteos.
Para cada energía `k`: `I_k(y) = I0_k * exp(-tau(y))`.
Luego sumamos energías: `I(y)=sum_k I_k(y)`.
En este laboratorio, eso es equivalente a `I0_total * exp(-tau)`.

```{python}
def detector_ideal_polienergetico(tau, I0_por_energia):
    """
    Detector ideal:
    I(y) = sum_k I0_k * exp(-tau(y))
    """
    I = np.zeros_like(tau, dtype=float)
    for I0_k in I0_por_energia:
        I += I0_k * np.exp(-tau)
    return I

I_det_A = detector_ideal_polienergetico(tau_A, I0_por_energia)
I_det_B = detector_ideal_polienergetico(tau_B, I0_por_energia)

fig, ax = plt.subplots(1, 2, figsize=(9, 3.2))
ax[0].plot(I_det_A)
ax[0].set_title("Intensidad ideal en detector I(y) - A")
ax[0].set_xlabel("índice y (pixel)")
ax[0].set_ylabel("conteos (ideal)")

ax[1].plot(I_det_B)
ax[1].set_title("Intensidad ideal en detector I(y) - B")
ax[1].set_xlabel("índice y (pixel)")

plt.tight_layout()
plt.show()
```

---

## 8) Reconstrucción tipo radiografía: normalización + log

¿Por qué normalizar? Porque el detector depende de cuántos fotones salieron (`I0`).
Al usar `I/I0`, “quitamos” el brillo de la fuente y nos quedamos con efecto del objeto.
¿Por qué el log? Porque Beer–Lambert tiene `exp(-tau)`; el log “deshace” la exponencial.
Así: `rad = -log(I/I0)` ≈ `tau` (atenuación proyectada).

```{python}
def reconstruir_radiografia(I_det, I0_total, eps=1e-12):
    """rad(y) = -log( I_det(y) / I0_total )"""
    I_norm = (I_det + eps) / (I0_total + eps)
    rad = -np.log(I_norm)
    return rad, I_norm

rad_A, I_norm_A = reconstruir_radiografia(I_det_A, I0_total, eps=eps)
rad_B, I_norm_B = reconstruir_radiografia(I_det_B, I0_total, eps=eps)

fig, ax = plt.subplots(1, 2, figsize=(9, 3.2))
ax[0].plot(tau_A, label="tau (verdad)")
ax[0].plot(rad_A, "--", label="rad (-log)")
ax[0].set_title("A: tau vs rad")
ax[0].legend()

ax[1].plot(tau_B, label="tau (verdad)")
ax[1].plot(rad_B, "--", label="rad (-log)")
ax[1].set_title("B: tau vs rad")
ax[1].legend()

plt.tight_layout()
plt.show()
```

**Ejercicio guiado 2:**
Cambia `I0_total` a `1e6`. ¿Qué pasa con `I_det`? ¿Qué pasa con `rad`? (Pista: `rad` debería cambiar muy poco).

---

## 9) Visualización: ventaneo (contraste simple)

Una “radiografía” es un arreglo de números; para verla bien, ajustamos el rango visible.
Ventaneo = escoger un intervalo `[low, high]` y mapearlo a la pantalla (0 a 1).
Si el ancho es pequeño, aumentas contraste pero puedes saturar zonas.
Si el ancho es grande, se ven más tonos pero con menos contraste local.

```{python}
def ventaneo_lineal(img, centro, ancho):
    """
    Ventaneo simple:
    - recorta a [centro - ancho/2, centro + ancho/2]
    - reescala a [0, 1]
    """
    low = centro - ancho/2
    high = centro + ancho/2
    out = np.clip(img, low, high)
    out = (out - low) / (high - low + 1e-12)
    return out

def tile_a_imagen(signal_1d, N):
    return np.tile(signal_1d[:, None], (1, N))

rad_A_img = tile_a_imagen(rad_A, N)
rad_B_img = tile_a_imagen(rad_B, N)

centro_A = float(np.median(rad_A))
ancho_A = float(np.percentile(rad_A, 95) - np.percentile(rad_A, 5))

centro_B = float(np.median(rad_B))
ancho_B = float(np.percentile(rad_B, 95) - np.percentile(rad_B, 5))

rad_A_win = ventaneo_lineal(rad_A_img, centro_A, ancho_A)
rad_B_win = ventaneo_lineal(rad_B_img, centro_B, ancho_B)

fig, ax = plt.subplots(1, 2, figsize=(9, 4))
ax[0].imshow(rad_A_win, cmap="gray", vmin=0, vmax=1)
ax[0].set_title("Radiografía A (ventaneada)")
ax[1].imshow(rad_B_win, cmap="gray", vmin=0, vmax=1)
ax[1].set_title("Radiografía B (ventaneada)")

for a in ax:
    a.set_axis_off()

plt.tight_layout()
plt.show()
```

**Ejercicio guiado 3:**
Pon `ancho` más pequeño (por ejemplo la mitad). ¿Qué detalle aparece más claro y qué se satura?

---

## 10) Comparación final: phantom vs detector vs radiografía

En una frase:
- `mu` = “cómo es el objeto” (verdad).
- `I_det` = “qué midió el detector” (más oscuro = menos fotones).
- `rad` = “radiografía” tras deshacer la exponencial (más alto = más atenuación).

```{python}
def resumen_pipeline(mu, I0_total, I0_por_energia, dx=1.0):
    tau = np.sum(mu, axis=1) * dx
    I_det = detector_ideal_polienergetico(tau, I0_por_energia)
    rad, _ = reconstruir_radiografia(I_det, I0_total, eps=eps)
    return tau, I_det, rad

tauA, IA, radA = resumen_pipeline(mu_A, I0_total, I0_por_energia, dx=dx)
tauB, IB, radB = resumen_pipeline(mu_B, I0_total, I0_por_energia, dx=dx)

fig, ax = plt.subplots(2, 3, figsize=(10, 6))

ax[0,0].imshow(mu_A, cmap="gray"); ax[0,0].set_title("A: phantom μ(y,x)")
ax[1,0].imshow(mu_B, cmap="gray"); ax[1,0].set_title("B: phantom μ(y,x)")

ax[0,1].imshow(tile_a_imagen(IA, N), cmap="gray"); ax[0,1].set_title("A: detector I(y) (tiling)")
ax[1,1].imshow(tile_a_imagen(IB, N), cmap="gray"); ax[1,1].set_title("B: detector I(y) (tiling)")

ax[0,2].imshow(tile_a_imagen(radA, N), cmap="inferno"); ax[0,2].set_title("A: rad = -log(I/I0)")
ax[1,2].imshow(tile_a_imagen(radB, N), cmap="inferno"); ax[1,2].set_title("B: rad = -log(I/I0)")

for a in ax.ravel():
    a.set_axis_off()

plt.tight_layout()
plt.show()
```

---

## 11) Mini-proyecto final (entregable)

Tu objetivo: crear un phantom nuevo (al menos 2 materiales) y correr el pipeline.
Debes mostrar 3 figuras: phantom, detector ideal, radiografía final ventaneada.
En 5–8 líneas, interpreta: “más atenuación” ↔ “menos fotones” ↔ “rad más alto”.

```{python}
def crear_phantom_estudiante(N):
    mu_fondo = 0.02
    phantom = np.full((N, N), mu_fondo, dtype=float)

    # TODO: forma 1 (más atenuante)
    phantom[int(0.30*N):int(0.60*N), int(0.20*N):int(0.35*N)] = 0.09

    # TODO: forma 2 (atenuación intermedia)
    y = np.arange(N)[:, None]
    x = np.arange(N)[None, :]
    cy, cx = int(0.65*N), int(0.65*N)
    r = int(0.12*N)
    phantom[(x - cx)**2 + (y - cy)**2 <= r**2] = 0.05

    return phantom

mu_est = crear_phantom_estudiante(N)

# Proyección + detector + radiografía
tau_est = np.sum(mu_est, axis=1) * dx
I_det_est = detector_ideal_polienergetico(tau_est, I0_por_energia)
rad_est, _ = reconstruir_radiografia(I_det_est, I0_total, eps=eps)

# A imagen para visualizar
I_det_est_img = tile_a_imagen(I_det_est, N)
rad_est_img = tile_a_imagen(rad_est, N)

# Ventaneo automático simple
centro_est = float(np.median(rad_est))
ancho_est = float(np.percentile(rad_est, 95) - np.percentile(rad_est, 5))
rad_est_win = ventaneo_lineal(rad_est_img, centro_est, ancho_est)

fig, ax = plt.subplots(1, 3, figsize=(12, 4))

ax[0].imshow(mu_est, cmap="gray")
ax[0].set_title("1) Phantom μ(y,x)")
ax[0].set_axis_off()

ax[1].imshow(I_det_est_img, cmap="gray")
ax[1].set_title("2) Detector ideal I(y) (tiling)")
ax[1].set_axis_off()

ax[2].imshow(rad_est_win, cmap="gray", vmin=0, vmax=1)
ax[2].set_title("3) Radiografía final (ventaneada)")
ax[2].set_axis_off()

plt.tight_layout()
plt.show()
```

**Interpretación (5–8 líneas, escribe aquí en tu entrega):**
- ¿Dónde está el material más atenuante? ¿Cómo se ve en `I_det` y en `rad`?
- ¿Qué zonas dejan pasar más fotones?
- ¿El ventaneo te ayudó a ver bordes o materiales? ¿Por qué?

---

## 12) Entregables (checklist de evaluación)

- [ ] El código corre sin errores al renderizar el HTML.
- [ ] Se ven (o se exportan) 3 figuras del mini-proyecto:
  - [ ] Phantom (`mu_est`)
  - [ ] Intensidad en detector (`I_det_est`)
  - [ ] Radiografía final (`rad_est` con ventaneo)
- [ ] Interpretación corta (5–8 líneas).
- [ ] (Opcional) Cambia el “espectro simple” (`pesos`) y comenta qué cambia.
  - Pista: con este modelo (sin μ dependiente de energía), la radiografía `rad` debería cambiar muy poco.

---

## Apéndice (opcional): exportar figuras a PNG

Si necesitas entregar archivos, usa `savefig`.
Esto no es obligatorio si ya quedan visibles en el HTML.

```{python}
# Ejemplo (descomenta si quieres guardar):
# plt.figure()
# plt.imshow(mu_est, cmap="gray")
# plt.axis("off")
# plt.title("Phantom del estudiante")
# plt.savefig("phantom_est.png", dpi=150, bbox_inches="tight")
# plt.close()
```
